%code {:
/*
 * The Arsenal Library
 * Copyright (c) 2009 by Solidus
 * 
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.It is provided "as is" without express 
 * or implied warranty.
 *
 */
:}
;



/******************************************PreDefined code********************************************/
%code syntax_node {:

:}
;





%code syntax_tree_handler {:

    static void        AR_STDCALL on_free_node(psrNode_t *node, void *ctx)
    {
		AR_ASSERT(node != NULL && ctx != NULL);
		
        
    }

    static arStatus_t        AR_STDCALL on_error(const psrToken_t *tok, const size_t expected[], size_t count, void *ctx)
    {
/*
            tguParser_t    *parser;
            size_t        i;
            arString_t    *str;
            wchar_t        *tok_str;
            AR_ASSERT(tok != NULL && ctx != NULL);

            parser = (tguParser_t*)ctx;
            str = AR_CreateString();

            if(tok->term_val == 0)
            {
                    tok_str = AR_wcsdup(L"EOI");
            }else
            {
                    tok_str = AR_wcsndup(tok->str, tok->str_cnt);
            }
        
            AR_AppendFormatString(str, L"Invalid token : '%ls', expected ", tok_str);
            
            for(i = 0; i < count; ++i)
            {
                    AR_AppendFormatString(str, L"'%ls'", TGU_TokenValToString(expected[i]));
            }
            
            TGU_ReportError(&parser->report, AR_GetStringCString(str), tok->line);
        
            AR_DestroyString(str);
            str = NULL;
            AR_DEL(tok_str);
            tok_str = NULL;
*/
            return AR_S_YES;
    }
    
    static const psrHandler_t    __g_handler = {on_error, on_free_node};
:}
;






%name    delim             :     "[\x{000A}\x{000B}\x{000C}\x{000D}\x{0085}\x{2028}\x{2029}\x{0020}\f\n\r\t\v\x{0009}\x{0020}\x{00A0}\x{1680}\x{180E}\x{2000}-\x{200A}\x{202F}\x{205F}\x{3000}]"
                        ;

%name    comment        :    "/\*([^\*]|\*+[^\*/])*\*+/"    
                       ;

%name    comment_line        :    "(//[^\x{000A}\x{000B}\x{000C}\x{000D}\x{0085}\x{2028}\x{2029}]*(\x{000A}|\x{000B}|\x{000C}|\x{000D}|\x{0085}|\x{2028}|\x{2029}|$))"
                          ;

%name skip_lexem        :     "{delim}|{comment_line}|{comment}"
                ;


%name    digit                :    "[0-9]"                
                        ;

%name    number                :    "{digit}+"                
                        ;


/*
\x{4E00}-\x{9FA5}     (中文)
\x{3130}-\x{318F}     (韩文)
\x{AC00}-\x{D7A3}    (韩文)
\x{0800}-\x{4E00}    (日文)
*/

//ASCII + 中日韩

%name    letter         :    "[A-Z_a-z\x{0800}-\x{4E00}\x{4E00}-\x{9FA5}\x{3130}-\x{318F}\x{AC00}-\x{D7AF}]"
                        ;



%name hex_digit         :    "[0-9a-fA-F]"
                        ;


%name hex_literal       :    "0(x|X){hex_digit}+"
                        ;

%name oct_literal       :    "0[0-7]+"
                        ;

%name dec_literal       :    "(0|[1-9][0-9]*)"
                        ;




%name    exponet            :    "(e|E)(\+|\-)?[0-9]+"
                            ;

%name float_literal         :    "(((([0-9]\.[0-9]*)){exponet}?)|([0-9]+{exponet}))"
                            ;




/*  '"'  == \x22,  '\'' == \x27 */

%name    escape_seq        :    "(\\(\x22|\x27))"    
                ;

%name    string_dq        :     "(\x22({escape_seq}|[^\x22])*\x22)"        //只能提取"..."或"\""此类串，其它词法规则要到语义例程中处理    
                ;

%name    string_sq        :    "\x27({escape_seq}|[^\x27])*\x27"        //提取'...'或'\''此类串，其它词法规则要到语义例程中处理    
                ;



%name    keyword_lhd           :    "{letter}|[0-9]"                        ;


%name        float_constant    :    "{float_literal}(?!{keyword_lhd})"
                    ;
%name        hex_constant        :    "{hex_literal}(?!{keyword_lhd})"
                    ;
%name        oct_constant        :    "{oct_literal}(?!{keyword_lhd})"
                    ;
%name        dec_constant        :    "{dec_literal}(?!{keyword_lhd})"
                    ;


%token     %skip            :    "{skip_lexem}"                ,1                %value    "TOK_DELIM_ID"             ;            //空白，需要过滤



%code token_operation{:
    
   
:}
;



%token        NAME     :    "{letter}({letter}|{digit})*"                    %value    "TOK_NAME"            %action default_leaf_handler        
	                ;


%token        STRING        :    "{string_dq}|{string_sq}"                        %value    "TOK_STRING"            %action on_string_leaf_handler        
		              ;


%token        FLOAT_NUMBER    :    "{float_constant}"                        ,2    %value    "TOK_FLOAT_NUMBER"        %action default_leaf_handler        ;
%token        INT_NUMBER    :    "{hex_constant}|{oct_constant}|{dec_constant}"        ,2    %value    "TOK_INT_NUMBER"        %action default_leaf_handler        ;




%token    "import"    :    '"import"(?!{keyword_lhd})'   ,1            %value    "TOK_IMPORT"            %action default_leaf_handler            ;
%token    "from"    	  :    '"from"(?!{keyword_lhd})'   ,1            %value    "TOK_FROM"            %action default_leaf_handler            ;

%token    "for"        :    '"for"(?!{keyword_lhd})'        ,1            %value    "TOK_FOR"            %action default_leaf_handler            ;
%token    "do"        :    '"do"(?!{keyword_lhd})'        ,1            %value    "TOK_DO"            %action default_leaf_handler            ;
%token    "while"    :    '"while"(?!{keyword_lhd})'        ,1            %value    "TOK_WHILE"            %action default_leaf_handler            ;
%token    "if"        :    '"if"(?!{keyword_lhd})'        ,1            %value    "TOK_IF"            %action default_leaf_handler            ;
%token    "else"        :    '"else"(?!{keyword_lhd})'        ,1            %value    "TOK_ELSE"            %action default_leaf_handler            ;

%token    "continue"    :    '"continue"(?!{keyword_lhd})'    ,1            %value    "TOK_CONTINUE"        %action default_leaf_handler            ;
%token    "break"    :    '"break"(?!{keyword_lhd})'        ,1            %value    "TOK_BREAK"            %action default_leaf_handler            ;
%token    "return"    :    '"return"(?!{keyword_lhd})'        ,1            %value    "TOK_RETURN"            %action default_leaf_handler            ;

%token    "null"        :    '"null"(?!{keyword_lhd})'        ,1            %value    "TOK_NULL"            %action default_leaf_handler            ;
%token    "true"        :    '"true"(?!{keyword_lhd})'        ,1            %value    "TOK_TRUE"            %action default_leaf_handler            ;
%token    "false"    :    '"false"(?!{keyword_lhd})'        ,1            %value    "TOK_FALSE"            %action default_leaf_handler            ;
%token    "var"        :    '"var"(?!{keyword_lhd})'        ,1            %value    "TOK_VAR"            %action default_leaf_handler            ;

%token    "in"        :    '"in"(?!{keyword_lhd})'        ,1            %value    "TOK_IN"            %action default_leaf_handler            ;

/*
%token    "list"    		:    '"list"(?!{keyword_lhd})'        ,1            %value    "TOK_LIST"            %action default_leaf_handler            ;
%token    "table"  		:    '"table"(?!{keyword_lhd})'        ,1            %value   "TOK_TABLE"            %action default_leaf_handler           ;
*/

%token    "try"    		:    '"try"(?!{keyword_lhd})'   ,1            	%value    	"TOK_TRY"        	%action default_leaf_handler            	;
%token    "catch"  		:    '"catch"(?!{keyword_lhd})'   ,1            %value    	"TOK_CATCH"        	%action default_leaf_handler        	;
%token    "finally"  	:    '"finally"(?!{keyword_lhd})'   ,1          %value    	"TOK_FINALLY"       	%action default_leaf_handler        	;
%token    "throw"  		:    '"throw"(?!{keyword_lhd})'   ,1          	%value    	"TOK_THROW"         	%action default_leaf_handler        	;




%token    "..."        :    '"..."'    ,2                        %value    "TOK_ELLIPSIS"        %action default_leaf_handler            ;    


%token    "++"        :    '"++"'        ,1                        %value    "TOK_INC"            %action default_leaf_handler            ;
%token    "--"        :    '"--"'        ,1                        %value    "TOK_DEC"            %action default_leaf_handler            ;


%token    "&&"        :    '"&&"'        ,1                        %value    "TOK_ANDAND"            %action default_leaf_handler            ;
%token    "||"        :    '"||"'        ,1                        %value    "TOK_OROR"            %action default_leaf_handler            ;






%token    "<="       :    '"<="'        ,1                        %value    "TOK_LE"            %action default_leaf_handler            ;
%token    ">="       :    '">="'        ,1                        %value    "TOK_GE"            %action default_leaf_handler            ;
%token    "=="       :    '"=="'        ,1                        %value    "TOK_EQ"            %action default_leaf_handler            ;
%token    "!="       :    '"!="'        ,1                        %value    "TOK_NE"            %action default_leaf_handler            ;
%token    "<"        :    '"<"'         ,0                    %value    "TOK_LESS"            %action default_leaf_handler           ;
%token    ">"        :    '">"'         ,0                    %value    "TOK_GREATER"            %action default_leaf_handler        ;




%token    "{"        :    '"{"'            ,0                    %value    "TOK_L_BRACES"        %action default_leaf_handler            ;
%token    "}"        :    '"}"'            ,0                    %value    "TOK_R_BRACES"        %action default_leaf_handler            ;
%token    "("        :    '"("'            ,0                    %value    "TOK_L_PAREN"            %action default_leaf_handler            ;
%token    ")"        :    '")"'            ,0                    %value    "TOK_R_PAREN"            %action default_leaf_handler            ;
%token    "["        :    '"["'            ,0                    %value    "TOK_L_SQUARE"        %action default_leaf_handler            ;
%token    "]"        :    '"]"'            ,0                    %value    "TOK_R_SQUARE"        %action default_leaf_handler            ;

%token    ";"        :    '";"'            ,0                    %value    "TOK_SEMICOLON"        %action default_leaf_handler            ;
%token    ","        :    '","'            ,0                    %value    "TOK_COMMA"            %action default_leaf_handler            ;
%token    "="        :    '"="'            ,0                    %value    "TOK_ASSIGN"            %action default_leaf_handler            ;



%token    "+"        :    '"+"'            ,0                    %value    "TOK_ADD"            %action default_leaf_handler            ;
%token    "-"        :    '"-"'            ,0                    %value    "TOK_SUB"            %action default_leaf_handler            ;
%token    "*"        :    '"*"'            ,0                    %value    "TOK_MUL"            %action default_leaf_handler            ;
%token    "/"        :    '"/"'            ,0                    %value    "TOK_DIV"            %action default_leaf_handler            ;
%token    "%"        :    '"%"'            ,0                    %value    "TOK_MOD"            %action default_leaf_handler            ;

%token    "!"        :    '"!"'            ,0                    %value    "TOK_NOT"            %action default_leaf_handler            ;


%token    ":"        :    '":"'            ,0                    %value    "TOK_COLON"            %action default_leaf_handler            ;
%token    "?"        :    '"?"'            ,0                    %value    "TOK_QUEST"            %action default_leaf_handler            ;


%token    "."        :    '"."'            ,0                    %value    "TOK_DOT"            %action default_leaf_handler            ;





/**************************************************优先级*****************************************************/

%right       "?"    ":"                          			;
%left        "||"                                			;
%left        "&&"                                			;
%left        "=="    "!="    "<"    "<="    ">"    ">="            	;
%left        "+"    "-"                          			;
%left        "*"    "/"    "%"                   			;




/*
"if" "(" expression ")" statement "else" statement 
产生式的优先级依赖于其最右终结符或显性指定,这里就是"else"
*/
%nonassoc IF_WITHOUT_ELSE                        ;
%nonassoc "else"                            ;






/**********************************************产生式****************************************/


%start    module	;


module		  :    element_list             %action    on_module
                |    .                        %action    on_module
	         ;



element_list	:	element                	%action    auto_return_null
		|	element_list    element  	%action    auto_return_null
              ;


element	:	declaration            	%action    auto_return_null
		|	function_defination        %action    auto_return_null
		|	statement
		;






/**************************************function_defination***********************************************/


%code    handle_function    {:
    
:}
;


function_signature		:    	"var"        NAME "(" params ")"                        %action    on_function_signature
				;


function_defination        :    function_signature    compound_statement    %action    on_function_defination
                           ;



params          :    namelist    ","    "..."        %action on_namelist_ellipsis
                |    namelist        		     %action    auto_return_0
                |    "..."            		     %action    on_ellipsis
                |    .            			     %action    NULL
                ;



namelist        :    namelist    "," NAME        %action    on_name_list
                |    NAME				 %action    on_name
                ;






/*************************************声明语句***************************************************/


declaration         :    "var"        init_declarator_list     semi       %action    auto_return_null
                    |    "var"        error                ";"            %action    auto_return_null
                    ;



init_declarator_list            :    init_declarator                        	      %action    auto_return_null
                    		     |    init_declarator_list "," init_declarator            %action    auto_return_null
                                ;



%code    handle_init_declarator{:
    
:};




init_declarator	:    	NAME    "="     expression                %action    	on_declarator
			|   	NAME	"=" 	aggregate_constructor	%action	on_declarator
                    	|    	NAME                            		%action    on_declarator
                    ;



aggregate_constructor	:	list_constructor 
				|	table_constructor
				;



list_constructor    		:   "["    list_field_list     optional_dot    "]"		%action on_list_contructor
                    		|   "["    "]"							%action on_list_contructor
                    		|   "["    error "]"							%action on_list_contructor
                    		;




list_field_list            	:    	list_field_list  "," list_field
				|	list_field
                    		;

list_field			:	expression
				|	aggregate_constructor
				;


table_constructor		:     "{"    table_field_list optional_dot    "}"        	%action    on_table_constructor
				|     "{"    "}"                					%action    on_table_constructor
				|     "{" error "}"                				%action    on_table_constructor
                    		;


table_field_list		:    table_field_list ","        table_field
				|    table_field
				;


table_field                	:	expression    ":"    expression
				|	expression	":"	aggregate_constructor
                    	      	;



optional_dot        		:    ","
                    		|    .
                    		;


/*************************************语句***************************************************/


statement		:    	compound_statement            %action    auto_return_0
			|    	expression_statement            %action    auto_return_0
			|    	selection_statement            %action    auto_return_0
			|    	iteration_statement            %action    auto_return_0
			|    	jump_statement            %action    auto_return_0
			|    	empty_statement            %action    auto_return_0
			|	import_statement 		%action auto_return_0
			|	throw_statement		%action auto_return_0
			|	try_statement			%action auto_return_0
                    ;




/**************************************************Exception statement*************************************************/

throw_statement	:	"throw" expression semi
			;

try_statement		:	"try"	compound_statement        "finally"	compound_statement
			|	"try" 	compound_statement        "catch"	"("	NAME ")"	compound_statement
			|	"try" 	compound_statement        "catch"	"("	NAME ")"	compound_statement	"finally" 	compound_statement
			;





/**************************************compound_statement*****************************/


%code {:
    
:};



compound_statement        :    start_block    compound_element_list        "}"        %action    on_compound_statement
	                    |    start_block                        "}"        %action    on_empty_compound_statement
		             |    start_block      error                  "}"        %action    on_compound_error_statement
                           ;



start_block            :    "{"        %action    on_start_block
	                ;








compound_element_list        :    compound_element_list        compound_element   
                    		  |    compound_element                        		
                    ;
















compound_element        :    statement        %action    on_compound_element
		          |    declaration        %action    auto_return_null
                	   ;













/**************************************statement*****************************/

%code {:
          

:};


import_statement	:	"import"	NAME ";"				%action on_import_statement
			|	"import"	NAME "from" STRING	";"		%action on_import_statement
			|	"import"	error ";"				%action on_import_statement
			;







%code {:
          

:};


empty_statement            :    ";"        %action    on_empty_statement
                           ;



expression_statement            :    expression     semi        %action on_expression_statement
		                  |    error    ";"            %action auto_return_null
              		     ;





selection_statement            :    if_statement        %action auto_return_0
		                 |    if_else_statement    %action auto_return_0
		                 ;





%code    {:
:};


if_statement    :    "if" "(" expression ")" statement            %prec IF_WITHOUT_ELSE        %action on_if_statement
                |    "if" "(" error ")" statement            %prec IF_WITHOUT_ELSE        %action on_if_statement
                ;


if_else_statement        :    "if" "(" expression ")" statement "else" statement    %action on_if_else_statement
                	    |    "if" "(" error ")" statement "else" statement        %action on_if_else_statement
		           ;




iteration_statement        :    while_statement            %action    auto_return_0
		             |    do_while_statement            %action    auto_return_0
                	      |    for_statement                %action    auto_return_0
		             ;






%code {:
 
:}
;






while_statement     :    "while" enter_loop  "(" expression ")" statement leave_loop    %action    on_while_statement
                    |    "while" enter_loop  "(" error ")" statement leave_loop        %action    on_while_statement
                    ;





do_while_statement           :    "do" enter_loop statement "while" "(" expression ")" leave_loop     semi            %action    on_do_while_statement
                    		  |    "do" enter_loop statement "while" "(" error ")" leave_loop         semi            %action    on_do_while_statement
		                ;	




for_statement            :    "for"    "("    for_in_expression    ")"     enter_loop  statement leave_loop    %action    on_for_statement
		           |    "for"    "("    error    ")"    enter_loop  statement leave_loop    %action    on_error_for_statement
                         ;

for_in_expression        :    NAME "in" expression    
                	    ;



enter_loop                :    .                    %action on_enter_loop
		            ;






leave_loop                :    .                    %action on_leave_loop
	                   ;






%code{:
    
:}
;


jump_statement       :    "continue"     semi                %action on_continue_statement
                    |    "break"     semi                %action on_break_statement
                    |    "return"     semi                %action on_return_statement
                    |    "return"     expression semi        %action on_return_statement
                    ;




semi                :    ";"                                %action    auto_return_0
                    |    error                                %action    on_semi_error
                    ;


/*****************************************表达式*********************************************/


expression          :    assignment_expression        %action auto_return_0
                    ;



%code {:
:}
;



assignment_expression	:    constant_expression                        %action     auto_return_0
				|    unary_expression    "="    assignment_expression    %action    on_assignment_expression
				;




%code {:

:}
;







constant_expression            :    binary_expression                                    %action     auto_return_0
                   		    |    binary_expression    "?"    expression    ":"        expression        %action    on_condition_expression
		                  ;





%code {:
:}
;

binary_expression   :    unary_expression                        %action     auto_return_0
	             |    binary_expression    "+"    binary_expression        %action    on_binary_expression
                    |    binary_expression    "-"    binary_expression        %action    on_binary_expression
                    |    binary_expression    "*"    binary_expression        %action    on_binary_expression
                    |    binary_expression    "/"    binary_expression        %action    on_binary_expression
                    |    binary_expression    "%"    binary_expression        %action    on_binary_expression
                    |    binary_expression    "<"    binary_expression        %action    on_binary_expression
                    |    binary_expression    "<="    binary_expression        %action    on_binary_expression
                    |    binary_expression    ">"    binary_expression        %action    on_binary_expression
                    |    binary_expression    ">="    binary_expression        %action    on_binary_expression
                    |    binary_expression    "=="    binary_expression        %action    on_binary_expression
                    |    binary_expression    "!="    binary_expression        %action    on_binary_expression
                    |    binary_expression    "&&"    binary_expression        %action    on_binary_expression
                    |    binary_expression    "||"    binary_expression        %action    on_binary_expression
                    ;


%code {:

:}
;


%code handle_constant {:
   
:}
;

%code handle_identifier{:
    


:}
;



unary_expression       :    "+"    unary_expression    %action    on_unary_expression
               	  |    "-"    unary_expression    %action    on_unary_expression
                       |    "!"    unary_expression    %action    on_unary_expression
       	         |    "++"     unary_expression    %action    on_unary_expression
	                |    "--"    unary_expression    %action    on_unary_expression
	                |    postfix_expression        %action     auto_return_0
       	         ;



postfix_expression        	:    postfix_expression    "++"        %action    on_post_add_minus_expression
                		|    postfix_expression    "--"        %action    on_post_add_minus_expression
               		|    postfix_expression "[" expression "]"        %action    on_index_expression
		              |    postfix_expression "[" error "]"            %action    on_index_expression
	                     |    postfix_expression     "."    NAME    %action    on_access_name_expression
	                     |    call_expression                %action auto_return_0
             			|    primary_expression                %action auto_return_0
		              ;    
                




primary_expression        	:    	"(" expression")"                            %action    on_lp_rp_expression
                	     	|    	"(" error ")"                                %action    on_lp_rp_expression
		            	|    	NAME                                        %action    on_identifier_expression
				|	constant            				%action    auto_return_0
		            	;



/**************************************import_expression***********************************************/

constant        :    FLOAT_NUMBER        %action    on_constant
                |    INT_NUMBER          %action    on_constant
                |    STRING              %action    on_constant
                |    "true"              %action    on_constant
                |    "false"            	%action    on_constant
                |    "null"              %action    on_constant
                ;





/*辅助函数*/
%code {:

:}
;



call_expression        :    postfix_expression "(" call_param_list ")"        	%action    on_call_expression
                |    postfix_expression "(" error ")"                		%action    on_call_expression
                |    postfix_expression "("     ")"                			%action    on_call_expression
                ;






/*
expression_list        :    expression                    %action    auto_return_0
                	  |    expression_list "," expression        %action    on_expression_list
                       ;
*/


call_param_list	:	call_param
			|	call_param_list "," call_param
			;


call_param		:	expression
			|	aggregate_constructor
			;











%token	'(' 	:	'"none"'
			;

%token 	')' 	:	'"none"'
			;


%token	'*' 	:	'"none"'
			;
%token	'+' 	:	'"none"'
			;

%token	',' 	:	'"none"'
			;


%token	'-'  	:	'"none"'
		;




%token	'.'  	:	'"none"'
			;
 


%token	'/'   	:	'"none"'
			;
%token	';'  	:	'"none"'
			;
%token	'['  	:	'"none"'
			;
%token	']'  	:	'"none"'
			;
 
%token	NAME  	:	'"none"'
			;
%token	STRING 	:	'"none"'
			; 
%token	WSTRING 	:	'"none"'
			;
%token	INTNUM  	:	'"none"'
			;
%token	APPROXNUM  	:	'"none"'
			;
%token	NUM_ERROR  	:	'"none"'
			;
%token	AMMSC 	:	'"none"'
			;
%token	PARAMETER_L  	:	'"none"'
			;
%token	NAMED_PARAMETER  	:	'"none"'
			;
%token	BEGIN_EQCALL_X  	:	'"none"'
			;
%token	HTMLSTR  	:	'"none"'
			;
%token	SQL_TSI  	:	'"none"'
			;
%token	TIMESTAMP_FUNC  	:	'"none"'
			;
%token	BINARYNUM  	:	'"none"'
			;
%token	MSSQL_XMLCOL_NAME  	:	'"none"'
			;
%token	MSSQL_XMLCOL_NAME1  	:	'"none"'
			;
%token	MSSQL_XMLCOL_NAMEYZ  	:	'"none"'
			;
%token	MSSQL_XMLCOL_NAMEZ  	:	'"none"'
			;
%token	MSSQL_XMLCOL_INTNUM  	:	'"none"'
			;
%token	TYPE  	:	'"none"'
			;
%token	FINAL_L  	:	'"none"'
			;
%token	METHOD  	:	'"none"'
			;
%token	CHECKED  	:	'"none"'
			;
%token	SYSTEM  	:	'"none"'
			;
%token	GENERATED  	:	'"none"'
			;
%token	SOURCE  	:	'"none"'
			;
%token	RESULT  	:	'"none"'
			;
%token	LOCATOR  	:	'"none"'
			;
%token	INSTANCE_L  	:	'"none"'
			;
%token	CONSTRUCTOR  	:	'"none"'
			;
%token	SELF_L   	:	'"none"'
			;
%token	OVERRIDING  	:	'"none"'
			;
%token	STYLE 	:	'"none"'
			; 
%token	SQL_L 	:	'"none"'
			; 
%token	GENERAL  	:	'"none"'
			;
%token	DETERMINISTIC  	:	'"none"'
			;
%token	NO  	:	'"none"'
			;
%token	CONTAINS  	:	'"none"'
			;
%token	READS 	:	'"none"'
			; 
%token	DATA  	:	'"none"'
			;
%token	MODIFIES  	:	'"none"'
			;
%token	INPUT  	:	'"none"'
			;
%token	CALLED  	:	'"none"'
			;
%token	ADA  	:	'"none"'
			;
%token	C  	:	'"none"'
			;
%token	COBOL 	:	'"none"'
			; 
%token	FORTRAN  	:	'"none"'
			;
%token	MUMPS  	:	'"none"'
			;
%token	PASCAL_L  	:	'"none"'
			;
%token	PLI  	:	'"none"'
			;
%token	NAME_L  	:	'"none"'
			;
%token	TEXT_L  	:	'"none"'
			;
%token	JAVA  	:	'"none"'
			;
%token	INOUT_L  	:	'"none"'
			;
%token	REMOTE  	:	'"none"'
			;
%token	KEYSET  	:	'"none"'
			;
%token	VALUE  	:	'"none"'
			;
%token	PARAMETER  :	'"none"'
			;
%token	VARIABLE  	:	'"none"'
			;
%token	ADMIN_L  	:	'"none"'
			;
%token	ROLE_L  	:	'"none"'
			;
%token	TEMPORARY  :	'"none"'
			;
%token	CLR :	'"none"'
			;
%token	ATTRIBUTE :	'"none"'
			;
%token	__SOAP_DOC :	'"none"'
			;
%token	__SOAP_DOCW :	'"none"'
			;
%token	__SOAP_HEADER :	'"none"'
			;
%token	__SOAP_HTTP :	'"none"'
			;
%token	__SOAP_NAME :	'"none"'
			;
%token	__SOAP_TYPE :	'"none"'
			;
%token	__SOAP_XML_TYPE :	'"none"'
			;
%token	__SOAP_FAULT :	'"none"'
			;
%token	__SOAP_DIME_ENC :	'"none"'
			;
%token	__SOAP_ENC_MIME :	'"none"'
			;
%token	__SOAP_OPTIONS :	'"none"'
			;
%token	FOREACH :	'"none"'
			;
%token	ARE :	'"none"'
			;
%token	REF :	'"none"'
			;
%token	STATIC_L :	'"none"'
			;
%token	SPECIFIC :	'"none"'
			;
%token	DYNAMIC :	'"none"'
			;
%token	COLUMN :	'"none"'
			;
%token	START_L :	'"none"'
			;
%token	AS :	'"none"'
			;
    
    
%token	DOUBLE_COLON :	'"none"'
			;
%token	COLON :	'"none"'
			;
%token	OR :	'"none"'
			;
%token	AND :	'"none"'
			;
%token	NOT :	'"none"'
			;
%token	COMPARISON :	'"none"'
			;
%token	EQUALS :	'"none"'
			;
%token	STRING_CONCAT_OPERATOR :	'"none"'
			;
%token	UMINUS :	'"none"'
			;
%token	ALL :	'"none"'
			;
%token	ANY :	'"none"'
			;
%token	ATTACH :	'"none"'
			;
%token	ASC :	'"none"'
			;
%token	AUTHORIZATION :	'"none"'
			;
%token	BETWEEN :	'"none"'
			;
%token	BY :	'"none"'
			;
%token	CASCADE :	'"none"'
			;
%token	CHARACTER :	'"none"'
			;
%token	CHECK :	'"none"'
			;
%token	CLOSE:	'"none"'
			; 
%token	COMMIT :	'"none"'
			;
%token	CONSTRAINT :	'"none"'
			;
%token	CONTINUE :	'"none"'
			;
%token	CREATE :	'"none"'
			;
%token	CUBE :	'"none"'
			;
%token	CURRENT :	'"none"'
			;
%token	CURSOR :	'"none"'
			;
%token	DECIMAL :	'"none"'
			;
%token	DECLARE :	'"none"'
			;
%token	DEFAULT :	'"none"'
			;
%token	DELETE_L :	'"none"'
			;
%token	DESC :	'"none"'
			;
%token	DISTINCT :	'"none"'
			;
%token	DOUBLE :	'"none"'
			;
%token	DROP :	'"none"'
			;
    
%token	ESCAPE :	'"none"'
			;
%token	EXISTS :	'"none"'
			;
%token	FETCH :	'"none"'
			;
%token	FLOAT :	'"none"'
			;
%token	FOR :	'"none"'
			;
%token	FOREIGN :	'"none"'
			;
%token	FOUND :	'"none"'
			;
%token	FROM :	'"none"'
			;
    
%token	GOTO :	'"none"'
			;
%token	GO :	'"none"'
			;
%token	GRANT :	'"none"'
			;
%token	GROUP :	'"none"'
			;
%token	GROUPING :	'"none"'
			;
%token	HAVING :	'"none"'
			;
%token	IN_L :	'"none"'
			;
%token	INDEX :	'"none"'
			;
%token	INDICATOR :	'"none"'
			;
%token	INSERT :	'"none"'
			;
%token	INTEGER :	'"none"'
			;
%token	INTO :	'"none"'
			;
%token	IS :	'"none"'
			;
%token	KEY :	'"none"'
			;
%token	LANGUAGE :	'"none"'
			;
%token	ENCODING :	'"none"'
			;
%token	LIKE :	'"none"'
			;
%token	NULLX :	'"none"'
			;
%token	NUMERIC :	'"none"'
			;
%token	OF :	'"none"'
			;
%token	ON :	'"none"'
			;
%token	OPEN :	'"none"'
			;
%token	OPTION :	'"none"'
			;
%token	ORDER :	'"none"'
			;
%token	PRECISION :	'"none"'
			;
%token	PRIMARY :	'"none"'
			;
%token	PRIVILEGES :	'"none"'
			;
%token	PROCEDURE :	'"none"'
			;
%token	PUBLIC :	'"none"'
			;
%token	REAL :	'"none"'
			;
%token	REFERENCES :	'"none"'
			;
%token	RESTRICT :	'"none"'
			;
%token	ROLLBACK :	'"none"'
			;
%token	ROLLUP :	'"none"'
			;
%token	SCHEMA :	'"none"'
			;
%token	SELECT :	'"none"'
			;
%token	SET :	'"none"'
			;
%token	SMALLINT :	'"none"'
			;
%token	SOME :	'"none"'
			;
%token	SQLCODE :	'"none"'
			;
%token	SQLERROR :	'"none"'
			;
%token	TABLE :	'"none"'
			;
%token	TO :	'"none"'
			;
%token	UNION :	'"none"'
			;
%token	UNIQUE :	'"none"'
			;
%token	UPDATE :	'"none"'
			;
%token	USER :	'"none"'
			;
%token	VALUES :	'"none"'
			;
%token	VIEW :	'"none"'
			;
%token	WHENEVER :	'"none"'
			;
%token	WHERE :	'"none"'
			;
%token	WITH :	'"none"'
			;
    
%token	WORK :	'"none"'
			;
%token	ARRAY :	'"none"'
			;
%token	CONTIGUOUS :	'"none"'
			;
%token	OBJECT_ID :	'"none"'
			;
%token	UNDER :	'"none"'
			;
%token	CLUSTERED :	'"none"'
			;
%token	VARCHAR :	'"none"'
			;
%token	VARBINARY :	'"none"'
			;
%token	BINARY :	'"none"'
			;
%token	LONG :	'"none"'
			;
%token	REPLACING :	'"none"'
			;
%token	SOFT :	'"none"'
			;
%token	HASH :	'"none"'
			;
%token	LOOP :	'"none"'
			;
%token	SHUTDOWN :	'"none"'
			;
%token	CHECKPOINT :	'"none"'
			;
%token	BACKUP :	'"none"'
			;
%token	REPLICATION :	'"none"'
			;
%token	SYNC :	'"none"'
			;
%token	ALTER:	'"none"'
			; 
%token	ADD :	'"none"'
			;
%token	RENAME :	'"none"'
			;
%token	DISCONNECT :	'"none"'
			;
%token	MODIFY :	'"none"'
			;
%token	BEFORE :	'"none"'
			;
%token	AFTER :	'"none"'
			;
%token	INSTEAD :	'"none"'
			;
%token	TRIGGER :	'"none"'
			;
%token	REFERENCING :	'"none"'
			;
%token	OLD :	'"none"'
			;
%token	AGGREGATE :	'"none"'
			;
%token	FUNCTION :	'"none"'
			;
%token	OUT_L:	'"none"'
			; 
%token	HANDLER :	'"none"'
			;
%token	IF :	'"none"'
			;
%token	THEN :	'"none"'
			;
%token	ELSE :	'"none"'
			;
%token	ELSEIF :	'"none"'
			;
%token	WHILE :	'"none"'
			;
%token	BEGINX :	'"none"'
			;
%token	ENDX :	'"none"'
			;
    
%token	RETURN :	'"none"'
			;
%token	CALL :	'"none"'
			;
%token	RETURNS :	'"none"'
			;
%token	DO :	'"none"'
			;
%token	EXCLUSIVE :	'"none"'
			;
%token	PREFETCH :	'"none"'
			;
%token	SQLSTATE :	'"none"'
			;
%token	SQLWARNING :	'"none"'
			;
%token	SQLEXCEPTION :	'"none"'
			;
%token	EXIT :	'"none"'
			;
%token	RESIGNAL :	'"none"'
			;
%token	REVOKE :	'"none"'
			;
%token	PASSWORD :	'"none"'
			;
%token	OFF :	'"none"'
			;
%token	LOGX :	'"none"'
			;
%token	TIMESTAMP :	'"none"'
			;
%token	DATE :	'"none"'
			;
%token	DATETIME :	'"none"'
			;
%token	TIME :	'"none"'
			;
%token	EXECUTE :	'"none"'
			;
%token	REXECUTE :	'"none"'
			;
%token	MODULE :	'"none"'
			;
%token	BEGIN_FN_X :	'"none"'
			;
%token	BEGIN_CALL_X :	'"none"'
			;
%token	BEGIN_OJ_X :	'"none"'
			;
%token	BEGIN_U_X :	'"none"'
			;
%token	CONVERT :	'"none"'
			;
%token	CASE :	'"none"'
			;
%token	WHEN :	'"none"'
			;
%token	IDENTITY :	'"none"'
			;
%token	LEFT :	'"none"'
			;
%token	RIGHT:	'"none"'
			; 
%token	FULL :	'"none"'
			;
%token	OUTER:	'"none"'
			; 
%token	INNER:	'"none"'
			; 
%token	CROSS:	'"none"'
			; 
%token	NATURAL :	'"none"'
			;
%token	USING :	'"none"'
			;
%token	JOIN :	'"none"'
			;
%token	USE :	'"none"'
			;
%token	COALESCE :	'"none"'
			;
%token	CAST :	'"none"'
			;
%token	NULLIF :	'"none"'
			;
%token	NEW :	'"none"'
			;
%token	CORRESPONDING :	'"none"'
			;
%token	EXCEPT :	'"none"'
			;
%token	INTERSECT :	'"none"'
			;
%token	BEST :	'"none"'
			;
%token	TOP :	'"none"'
			;
%token	PERCENT :	'"none"'
			;
%token	TIES :	'"none"'
			;
%token	XML :	'"none"'
			;
%token	XPATH:	'"none"'
			; 
%token	PERSISTENT :	'"none"'
			;
%token	INTERVAL :	'"none"'
			;
%token	INCREMENT_L :	'"none"'
			;
%token	DTD :	'"none"'
			;
%token	INTERNAL :	'"none"'
			;
%token	EXTERNAL :	'"none"'
			;
%token	COLLATE :	'"none"'
			;
%token	NCHAR :	'"none"'
			;
%token	NVARCHAR :	'"none"'
			;
%token	INCREMENTAL :	'"none"'
			;
%token	NONINCREMENTAL :	'"none"'
			;
%token	PURGE :	'"none"'
			;
%token	SNAPSHOT :	'"none"'
			;
%token	IDENTIFIED :	'"none"'
			;
%token	EXTRACT :	'"none"'
			;
%token	KWD_TAG :	'"none"'
			;
%token	LEXICAL_ERROR :	'"none"'
			;
%token	CURRENT_DATE :	'"none"'
			;
%token	CURRENT_TIME :	'"none"'
			;
%token	CURRENT_TIMESTAMP :	'"none"'
			;
%token	PERMISSION_SET :	'"none"'
			;
%token	AUTOREGISTER_L :	'"none"'
			;
%token	LIBRARY_L :	'"none"'
			;
%token	ASSEMBLY_L :	'"none"'
			;
%token	SAFE_L :	'"none"'
			;
%token	UNRESTRICTED :	'"none"'
			;




sql_list		: sql_list1 ';'
             	| sql_list1
			;

sql_list1		: sql
			;

     sql: schema_element_list
        | view_def
        | xml_view
        | create_xml_schema
        | alter_constraint
        | create_library
       | create_assembly
       | drop_library
       | drop_assembly
		;

    schema_element_list: schema_element
                       | add_column
                       | schema_element_list schema_element
                       | schema_element_list add_column
					;

 	schema_element: base_table_def
                  | create_index_def
                  | drop_table
                  | drop_index
                  | table_rename
                  | privilege_def
                  | privilege_revoke
                  | create_user_statement
                  | delete_user_statement
                  | set_pass
                  | set_group_stmt
                  | add_group_stmt
                  | delete_group_stmt
                  | user_defined_type
                  | user_defined_type_drop
                  | user_defined_type_alter
			;

	    identifier: NAME
              | TYPE
              | FINAL_L
              | METHOD
              | CHECKED
              | SYSTEM
              | GENERATED
              | SOURCE
              | RESULT
              | LOCATOR
              | INSTANCE_L
              | CONSTRUCTOR
              | SELF_L
              | OVERRIDING
              | STYLE
              | SQL_L
              | GENERAL
              | DETERMINISTIC
              | NO
              | CONTAINS
              | READS
              | DATA
              | MODIFIES
              | INPUT
              | CALLED
              | ADA
              | C
              | COBOL
              | FORTRAN
              | MUMPS
              | PASCAL_L
              | PLI
              | NAME_L
              | TEXT_L
              | JAVA
              | INOUT_L
              | REMOTE
              | KEYSET
              | VALUE
              | PARAMETER
              | VARIABLE
              | CLR
              | TEMPORARY
              | ADMIN_L
              | __SOAP_DOC
              | __SOAP_DOCW
              | __SOAP_HEADER
              | __SOAP_HTTP
              | __SOAP_NAME
              | __SOAP_TYPE
              | __SOAP_XML_TYPE
              | __SOAP_FAULT
              | __SOAP_DIME_ENC
              | __SOAP_ENC_MIME
              | __SOAP_OPTIONS
              | START_L
              | ATTRIBUTE
              | REXECUTE
              | PERMISSION_SET
              | AUTOREGISTER_L
              | LIBRARY_L
              | ASSEMBLY_L
              | SAFE_L
              | UNRESTRICTED
              | INCREMENT_L
              | FOREACH
		
			;


    base_table_def: CREATE TABLE new_table_name '(' base_table_element_commalist ')'
			;

   base_table_element_commalist: base_table_element
                               | base_table_element_commalist ',' base_table_element
						;

   base_table_element: column_def
                     | table_constraint_def
				;

   column_def: column column_data_type column_def_opt_list
		;
   opt_referential_triggered_action: .
                                   | referential_rule
                                   | referential_rule referential_rule
						;

   referential_rule: ON UPDATE referential_action
                   | delete_referential_rule
				;

   delete_referential_rule: ON DELETE_L referential_action
					;
   opt_on_delete_referential_rule: .
                                 | delete_referential_rule
						;
   referential_action: CASCADE
                     | SET NULLX
                     | SET DEFAULT
				;

   references: REFERENCES q_table_name opt_column_commalist opt_referential_triggered_action
		;

   column_def_opt_list: .
                      | column_def_opt_list column_def_opt
				;
   identity_opt: START_L WITH signed_literal
               | INCREMENT_L BY INTNUM
			;
   
	identity_opt_list: identity_opt
                    | identity_opt_list ',' identity_opt
				;
   column_def_opt: NOT NULLX
                 | NULLX
                 | IDENTITY
                 | IDENTITY '(' identity_opt_list ')'
                 | PRIMARY KEY
                 | DEFAULT signed_literal
                 | COLLATE q_table_name
                 | references
                 | IDENTIFIED BY column
                 | CHECK '(' search_condition ')'
                 | WITH SCHEMA column_xml_schema_def
                 | UNIQUE
			;

   column_xml_schema_def: '(' STRING ',' STRING ')'
                        | '(' STRING ',' STRING ',' STRING ')'
					;

   table_constraint_def: UNDER q_table_name
                       | opt_constraint_name PRIMARY KEY '(' index_column_commalist ')' opt_index_option_list
                       | opt_constraint_name FOREIGN KEY '(' column_commalist ')' references
                       | opt_constraint_name CHECK '(' search_condition ')'
                       | opt_constraint_name UNIQUE '(' column_commalist ')'
				;

   opt_constraint_name: .
                      | CONSTRAINT identifier
				;
   column_commalist: column
                   | column_commalist ',' column
				;

   index_column_commalist: column opt_asc_desc
                         | index_column_commalist ',' column opt_asc_desc
					;

   index_option: CLUSTERED
               | UNIQUE
               | OBJECT_ID
			;

   index_option_list: index_option
                    | index_option_list index_option
				;

   opt_index_option_list: .
                        | index_option_list
					;

   create_index_def: CREATE opt_index_option_list INDEX index ON new_table_name '(' index_column_commalist ')'
				;

   drop_index: DROP INDEX identifier opt_table
			;

   opt_table: .
            | q_table_name
			;

   drop_table: DROP TABLE q_table_name
             | DROP VIEW q_table_name
			;
   opt_col_add_column: .
                     | COLUMN
				;

   add_col_column_def_list: column_def
                          | add_col_column_def_list ',' column_def
					;

   add_col_column_list: column
                      | add_col_column_list ',' column
				;

   add_column: ALTER TABLE q_table_name ADD opt_col_add_column add_col_column_def_list
             | ALTER TABLE q_table_name DROP opt_col_add_column add_col_column_list
             | ALTER TABLE q_table_name MODIFY opt_col_add_column column_def
			;

   table_rename: ALTER TABLE q_table_name RENAME new_table_name
			;

   constraint_op: ADD
                | DROP
                | MODIFY
			;


   opt_drop_behavior: .
                    | CASCADE
                    | RESTRICT
				;

   opt_table_constraint_def: CONSTRAINT identifier opt_drop_behavior
                           | table_constraint_def
					;


   alter_constraint: ALTER TABLE q_table_name constraint_op opt_table_constraint_def
				;

   create_xml_schema: CREATE XML SCHEMA STRING
				;

   view_query_spec: query_exp
                  | query_no_from_spec
			;

   empty_1: .
	;

   view_def: CREATE VIEW new_table_name empty_1 opt_column_commalist AS view_query_spec opt_with_check_option
         | CREATE PROCEDURE VIEW new_table_name AS q_table_name '(' column_commalist_or_empty ')' '(' proc_col_list ')'
		;

 opt_with_check_option: .
                      | WITH CHECK OPTION
				;

 opt_column_commalist: .
                     | '(' column_commalist ')'
				;

 priv_opt_column_commalist: .
                          | '(' column_commalist ')'
					;

 privilege_def: GRANT ALL PRIVILEGES TO grantee
              | GRANT privileges ON table TO grantee_commalist opt_with_grant_option
              | GRANT EXECUTE ON function_name TO grantee_commalist opt_with_grant_option
              | GRANT REXECUTE ON STRING TO grantee_commalist
              | GRANT UNDER ON q_old_type_name TO grantee_commalist opt_with_grant_option
              | GRANT grantee_commalist TO grantee_commalist opt_with_admin_option
			;


 opt_with_admin_option: .
                      | WITH ADMIN_L OPTION
				;

 privilege_revoke: REVOKE privileges ON table FROM grantee_commalist
                 | REVOKE EXECUTE ON function_name FROM grantee_commalist
                 | REVOKE UNDER ON q_old_type_name FROM grantee_commalist
                 | REVOKE REXECUTE ON STRING FROM grantee_commalist
                 | REVOKE grantee_commalist FROM grantee_commalist
			;

 opt_with_grant_option: .
                      | WITH GRANT OPTION
				;

 privileges: ALL PRIVILEGES
           | ALL
           | operation_commalist
		;

 operation_commalist: operation
                    | operation_commalist ',' operation
				;

 operation: SELECT priv_opt_column_commalist
          | INSERT
          | DELETE_L
          | UPDATE priv_opt_column_commalist
          | REFERENCES priv_opt_column_commalist
		;

 grantee_commalist: grantee
                  | grantee_commalist ',' grantee
				;


 grantee: PUBLIC
        | user
		;

 set_pass: SET PASSWORD identifier identifier
		;

 create_user_statement: CREATE USER user
                      | CREATE ROLE_L user
				;

 delete_user_statement: DELETE_L USER user
                      | DELETE_L USER user CASCADE
                      | DROP USER user
                      | DROP USER user CASCADE
                      | DROP ROLE_L user
				;

 set_group_stmt: SET USER GROUP user user
			;

 add_group_stmt: ADD USER GROUP user user
			;

 delete_group_stmt: DELETE_L USER GROUP user user
				;

 opt_attach_primary_key: .
                       | PRIMARY KEY '(' column_commalist ')'
					;

 attach_table: ATTACH TABLE attach_q_table_name opt_attach_primary_key opt_as FROM literal opt_login opt_not_select opt_remote_name
			;


 opt_as: .
       | AS new_table_name
		;

 opt_login:	. 
          | USER scalar_exp PASSWORD scalar_exp
		;

 opt_not_select: .
               | NOT SELECT
			;


 opt_remote_name: .
                | REMOTE AS scalar_exp
			;

 cursor_type: STATIC_L
            | DYNAMIC
            | KEYSET
		;

 cursor_def: DECLARE identifier CURSOR FOR query_exp
           | DECLARE identifier cursor_type CURSOR FOR query_exp
		;

 opt_order_by_clause: .
                    | ORDER BY ordering_spec_commalist
				;

 ordering_spec_commalist: ordering_spec
                        | ordering_spec_commalist ',' ordering_spec
					;

 ordering_spec: scalar_exp opt_asc_desc
              | mssql_xml_col opt_asc_desc
			;

 opt_asc_desc: .
             | ASC
             | DESC
		;
 create_snapshot_log: CREATE SNAPSHOT LOGX FOR q_table_name
				;

 drop_snapshot_log: DROP SNAPSHOT LOGX FOR q_table_name
				;

 purge_snapshot_log: PURGE SNAPSHOT LOGX FOR q_table_name
				;

 opt_snapshot_string_literal: .
                            | STRING
						;


 opt_snapshot_where_clause: .
                          | WHERE STRING
					;

 create_snapshot: CREATE SNAPSHOT q_table_name FROM q_table_name opt_snapshot_string_literal opt_snapshot_where_clause
                | CREATE NONINCREMENTAL SNAPSHOT q_table_name AS STRING
			;

 opt_with_delete: .
                | WITH DELETE_L
			;

 drop_snapshot: DROP SNAPSHOT q_table_name opt_with_delete
			;

 opt_nonincremental: .
                   | AS NONINCREMENTAL
			;

 refresh_snapshot: UPDATE SNAPSHOT q_table_name opt_nonincremental
			;

 create_freetext_index: CREATE TEXT_L opt_xml INDEX ON q_table_name '(' column ')' opt_with_key opt_deffer_generation opt_with opt_data_modification_action opt_lang opt_enc
				;

 opt_data_modification_action: .
                             | USING FUNCTION
					;

 opt_column:	.
           | '(' column ')'
		;

 create_freetext_trigger: CREATE TEXT_L TRIGGER ON q_table_name opt_column
					;

 drop_freetext_trigger: DROP TEXT_L TRIGGER ON q_table_name opt_column
				;

 opt_xml: .
        | XML
	;

 opt_with_key: .
             | WITH KEY column
		;

 opt_with: .
         | CLUSTERED WITH '(' column_commalist ')'
		;

 opt_lang: .
         | LANGUAGE STRING
		;

 opt_enc: .
        | ENCODING STRING
		;

 opt_deffer_generation: .
                      | NOT INSERT
				;


 manipulative_statement: query_exp
                       | query_no_from_spec
                       | update_statement_positioned
                       | update_statement_searched
                       | insert_statement
                       | delete_statement_positioned
                       | delete_statement_searched
                       | call_statement
                       | static_method_invocation
                       | METHOD CALL static_method_invocation
                       | top_level_method_invocation
                       | set_statement
                       | drop_xml_view
                       | commit_statement
                       | rollback_statement
                       | admin_statement
                       | use_statement
                       | attach_table
                       | create_snapshot_log
                       | drop_snapshot_log
                       | purge_snapshot_log
                       | create_snapshot
                       | drop_snapshot
                       | refresh_snapshot
                       | create_freetext_index
                       | create_freetext_trigger
                       | drop_freetext_trigger
				;

 use_statement: USE identifier
			;

 close_statement: CLOSE cursor
			;
	
 commit_statement: COMMIT WORK
			;

 delete_statement_positioned: DELETE_L FROM table WHERE CURRENT OF cursor
					;

 delete_statement_searched: DELETE_L FROM table opt_where_clause
					;

 fetch_statement: FETCH cursor INTO target_commalist
                | FETCH cursor NAME INTO target_commalist
                | FETCH cursor NAME scalar_exp INTO target_commalist
			;

 insert_mode: INTO
            | REPLACING
            | SOFT
		;

 insert_statement: INSERT insert_mode table priv_opt_column_commalist values_or_query_spec
			;

 values_or_query_spec: VALUES '(' insert_atom_commalist ')'
                     | query_spec
				;

 insert_atom_commalist: insert_atom
                      | insert_atom_commalist ',' insert_atom
				;

 insert_atom: scalar_exp
			;

 sql_option: ORDER
           | HASH
           | LOOP
           | INDEX identifier
           | INDEX PRIMARY KEY
           | INDEX TEXT_L KEY
           | NAME INTNUM
		;

 sql_opt_commalist: sql_option
                  | sql_opt_commalist ',' sql_option
			;
 opt_sql_opt: .
            | OPTION '(' sql_opt_commalist ')'
		;

 opt_table_opt: .
              | TABLE OPTION '(' sql_opt_commalist ')'
			;

 cursor_option: EXCLUSIVE
              | PREFETCH INTNUM
			;

 cursor_options_commalist: cursor_option
                         | cursor_options_commalist ',' cursor_option
					;

 opt_cursor_options_list: .
                        | '(' cursor_options_commalist ')'
					;

 open_statement: OPEN cursor opt_cursor_options_list
			;

 rollback_statement: ROLLBACK WORK
				;

 with_opt_cursor_options_list: .
                             | WITH opt_cursor_options_list
					;

 select_statement: SELECT opt_top selection INTO target_commalist table_exp with_opt_cursor_options_list
			;

 opt_all_distinct: .
                 | ALL
                 | DISTINCT
			;

 opt_ties: .
         | WITH TIES
		;

 opt_top: opt_all_distinct
        | opt_all_distinct TOP INTNUM opt_ties
        | opt_all_distinct TOP '(' scalar_exp ')' opt_ties
        | opt_all_distinct TOP INTNUM ',' INTNUM opt_ties
        | opt_all_distinct TOP '(' scalar_exp ',' scalar_exp ')' opt_ties
		;

 update_statement_positioned: UPDATE table SET assignment_commalist WHERE CURRENT OF cursor
					;

 assignment_commalist: .
                     | assignment
                     | assignment_commalist ',' assignment
				;

 assignment: column COMPARISON scalar_exp
		;

 update_statement_searched: UPDATE table SET assignment_commalist opt_where_clause
					;

 target_commalist: target
                 | target_commalist ',' target
			;

 target: column_ref
       | member_observer
       | lvalue_array_ref
		;

 opt_where_clause: .
                 | where_clause
			;

 opt_best: .
         | BEST
		;

 query_exp: query_term
          | non_final_union_exp opt_best UNION opt_corresponding query_term
          | non_final_union_exp opt_best UNION ALL opt_corresponding query_term
          | non_final_union_exp INTERSECT opt_corresponding query_term
          | non_final_union_exp INTERSECT ALL opt_corresponding query_term
          | non_final_union_exp EXCEPT opt_corresponding query_term
          | non_final_union_exp EXCEPT ALL opt_corresponding query_term
		;

 non_final_union_exp: non_final_query_term
                    | non_final_union_exp opt_best UNION opt_corresponding non_final_query_term
                    | non_final_union_exp opt_best UNION ALL opt_corresponding non_final_query_term
                    | non_final_union_exp INTERSECT opt_corresponding non_final_query_term
                    | non_final_union_exp INTERSECT ALL opt_corresponding non_final_query_term
                    | non_final_union_exp EXCEPT opt_corresponding non_final_query_term
                    | non_final_union_exp EXCEPT ALL opt_corresponding non_final_query_term
				;

 non_final_query_term: non_final_query_spec
                     | XPATH STRING
				;

 query_term: query_spec
           | '(' query_exp ')' opt_order_by_clause
           | XPATH STRING
		;

 opt_corresponding: .
                  | CORRESPONDING BY '(' column_commalist ')'
			;

 non_final_query_spec: SELECT opt_top selection non_final_table_exp
				;

 query_spec: SELECT opt_top selection table_exp
			;

 query_no_from_spec: SELECT opt_top selection
				;

 selection: select_scalar_exp_commalist
		;

 non_final_table_exp: from_clause opt_where_clause opt_group_by_clause opt_having_clause
				;

 table_exp: from_clause opt_where_clause opt_group_by_clause opt_having_clause opt_order_by_clause opt_lock_mode opt_sql_opt
		;

 from_clause: FROM table_ref_commalist
			;

 table_ref_commalist: table_ref
                    | table_ref_commalist ',' table_ref
				;


 proc_col_list: column_def
              | proc_col_list ',' column_def
			;

 opt_proc_col_list: '(' proc_col_list ')'
				;

 column_commalist_or_empty: .
                          | column_commalist
					;

 table_ref: table	
          | '(' query_exp ')' identifier
          | '(' query_exp ')' AS identifier
          | joined_table
          | q_table_name '(' column_commalist_or_empty ')' opt_proc_col_list identifier
		;

 table_ref_nj: table
             | subquery identifier
             | subquery AS identifier
             | '(' joined_table ')'
			;

 jtype: .
      | LEFT opt_outer
      | RIGHT opt_outer
      | FULL opt_outer
      | INNER
      | CROSS
	;



 opt_outer: .
          | OUTER
		;

 join: NATURAL jtype
     | jtype
	;

 joined_table: joined_table_1
             | BEGIN_OJ_X joined_table_1 ENDX
             | '(' joined_table_1 ')'
			;

 joined_table_1: table_ref join JOIN table_ref_nj join_condition
			;

 join_condition: .
               | ON search_condition
               | USING '(' column_commalist ')'
			;


 where_clause: WHERE search_condition
			;

 opt_group_by_clause: .
                    | GROUP BY ordering_spec_commalist
                    | GROUP BY ROLLUP '(' ordering_spec_commalist ')'
                    | GROUP BY CUBE '(' ordering_spec_commalist ')'
				;


 opt_having_clause: .
                  | HAVING search_condition
			;

 opt_lock_mode: .
              | FOR UPDATE
              | FOR XML NAME
              | FOR XML NAME NAME
			;

 search_condition: search_condition OR search_condition
                 | search_condition AND search_condition
                 | NOT search_condition
                 | '(' search_condition ')'
                 | predicate
			;

 predicate: comparison_predicate
          | between_predicate
          | like_predicate
          | test_for_null
          | in_predicate
          | all_or_any_predicate
          | existence_test
          | scalar_exp_predicate
		;

 scalar_exp_predicate: scalar_exp
				;

 comparison_predicate: scalar_exp COMPARISON scalar_exp
				;

 between_predicate: scalar_exp NOT BETWEEN scalar_exp AND scalar_exp
                  | scalar_exp BETWEEN scalar_exp AND scalar_exp
				;

 like_predicate: scalar_exp NOT LIKE scalar_exp opt_escape
               | scalar_exp LIKE scalar_exp opt_escape
			;

 opt_escape: .
           | ESCAPE atom
           | BEGINX ESCAPE atom ENDX
		;

 test_for_null: scalar_exp IS NOT NULLX
              | scalar_exp IS NULLX
			;

 in_predicate: scalar_exp NOT IN_L subquery
             | scalar_exp IN_L subquery
             | scalar_exp NOT IN_L '(' scalar_exp_commalist ')'
             | scalar_exp IN_L '(' scalar_exp_commalist ')'
			;


 all_or_any_predicate: scalar_exp COMPARISON any_all_some subquery
				;

 any_all_some: ANY
             | ALL
             | SOME
			;


 existence_test: EXISTS subquery
			;

 scalar_subquery: subquery
			;

 subquery: '(' SELECT opt_top selection table_exp ')'
		;

 scalar_exp: scalar_exp '-' scalar_exp
           | scalar_exp '+' scalar_exp
           | scalar_exp '*' scalar_exp
           | scalar_exp '/' scalar_exp
           | '+' scalar_exp
           | '-' scalar_exp
           | assignment_statement
           | string_concatenation_operator
           | column_ref
           | scalar_exp_no_col_ref
           | obe_literal
		;


 scalar_exp_no_col_ref: atom_no_obe
                      | aggregate_ref
                      | scalar_subquery
                      | '(' scalar_exp ')'
                      | '(' scalar_exp ',' scalar_exp_commalist ')'
                      | function_call
                      | new_invocation
                      | cvt_exp
                      | cast_exp
                      | simple_case
                      | searched_case
                      | coalesce_exp
                      | nullif_exp
                      | array_ref
                      | static_method_invocation
                      | method_invocation
                      | member_observer
				;

 scalar_exp_no_col_ref_no_mem_obs_chain: atom_no_obe
                                       | aggregate_ref
                                       | scalar_subquery
                                       | '(' scalar_exp ')'
                                       | '(' scalar_exp ',' scalar_exp_commalist ')'
                                       | function_call
                                       | new_invocation
                                       | cvt_exp
                                       | cast_exp
                                       | simple_case
                                       | searched_case
                                       | coalesce_exp
                                       | nullif_exp
                                       | array_ref
                                       | static_method_invocation
                                       | method_invocation
                                       | member_observer_no_id_chain
							;

 cvt_exp: CONVERT '(' data_type ',' scalar_exp ')'
		;

 opt_collate_exp: .
                | COLLATE q_table_name
			;

 cast_exp: CAST '(' scalar_exp AS data_type opt_collate_exp ')'
		;

 mssql_xml_col: MSSQL_XMLCOL_NAME1 MSSQL_XMLCOL_INTNUM MSSQL_XMLCOL_NAMEZ
              | MSSQL_XMLCOL_NAME1 MSSQL_XMLCOL_INTNUM MSSQL_XMLCOL_NAMEYZ
              | MSSQL_XMLCOL_NAME1 MSSQL_XMLCOL_INTNUM MSSQL_XMLCOL_NAME MSSQL_XMLCOL_NAMEZ
			;

 as_expression: scalar_exp AS identifier data_type
              | scalar_exp AS identifier
              | scalar_exp identifier
              | scalar_exp AS mssql_xml_col
			;


 array_ref: scalar_exp_no_col_ref '[' scalar_exp ']'
          | lvalue_array_ref
		;

 lvalue_array_ref: column_ref '[' scalar_exp ']'
			;

 opt_scalar_exp_commalist: .
                         | scalar_exp_commalist
					;


 function_name: identifier
              | identifier '.' method_identifier
              | identifier '.' identifier '.' method_identifier
              | identifier '.' identifier '.' identifier '.' method_identifier
              | identifier '.' '.' method_identifier
              | identifier '.' '.' identifier '.' method_identifier
              | LEFT
              | RIGHT
              | LOGX
			;


 kwd_commalist: identifier KWD_TAG scalar_exp
              | kwd_commalist ',' identifier KWD_TAG scalar_exp
			;


 as_commalist: as_expression
             | as_commalist ',' as_expression
             | as_commalist ',' scalar_exp
			;


 opt_arg_commalist: .
                  | kwd_commalist
                  | scalar_exp_commalist
                  | scalar_exp_commalist ',' kwd_commalist
                  | scalar_exp_commalist ',' as_commalist
                  | as_commalist
				;

 function_call: function_name '(' opt_arg_commalist ')'
              | TIMESTAMP_FUNC '(' SQL_TSI ',' scalar_exp ',' scalar_exp ')'
              | EXTRACT '(' NAME FROM scalar_exp ')'
              | BEGIN_FN_X identifier '(' opt_scalar_exp_commalist ')' ENDX
              | BEGIN_FN_X LEFT '(' opt_scalar_exp_commalist ')' ENDX
              | BEGIN_FN_X RIGHT '(' opt_scalar_exp_commalist ')' ENDX
              | BEGIN_FN_X LOGX '(' opt_scalar_exp_commalist ')' ENDX
              | BEGIN_FN_X identifier '(' scalar_exp IN_L scalar_exp ')' ENDX
              | BEGIN_CALL_X function_name '(' opt_scalar_exp_commalist ')' ENDX
              | BEGIN_CALL_X function_name ENDX
              | BEGIN_FN_X USER '(' opt_scalar_exp_commalist ')' ENDX
              | BEGIN_FN_X CHARACTER '(' opt_scalar_exp_commalist ')' ENDX
              | BEGIN_FN_X TIMESTAMP_FUNC '(' SQL_TSI ',' scalar_exp ',' scalar_exp ')' ENDX
              | BEGIN_FN_X CONVERT '(' scalar_exp ',' NAME ')' ENDX
              | BEGIN_FN_X EXTRACT '(' NAME FROM scalar_exp ')' ENDX
              | CALL '(' scalar_exp ')' '(' opt_arg_commalist ')'
              | CURRENT_DATE
              | CURRENT_TIME
              | CURRENT_TIME '(' scalar_exp ')'
              | CURRENT_TIMESTAMP
              | CURRENT_TIMESTAMP '(' scalar_exp ')'
              | GROUPING '(' column_ref ')'
			;


 
 obe_literal: BEGINX identifier atom ENDX
            | BEGIN_U_X STRING ENDX
		;


 scalar_exp_commalist: scalar_exp
                     | scalar_exp_commalist ',' scalar_exp
				;

 select_scalar_exp_commalist: scalar_exp
                            | as_expression
                            | select_scalar_exp_commalist ',' scalar_exp
                            | select_scalar_exp_commalist ',' as_expression
					;

 atom_no_obe: parameter_ref
            | literal
            | USER
			;


 atom: atom_no_obe
     | obe_literal
	;

 simple_case: CASE scalar_exp simple_when_list ENDX
			;

 searched_case: CASE searched_when_list ENDX
			;

 searched_when_list: searched_when
                   | searched_when_list searched_when
				;

 simple_when_list: simple_when
                 | simple_when_list simple_when
			;

 simple_when: WHEN scalar_exp THEN scalar_exp
            | ELSE scalar_exp
			;

 searched_when: WHEN search_condition THEN scalar_exp
              | ELSE scalar_exp
			;

 coalesce_exp: COALESCE '(' scalar_exp_commalist ')'
			;

 nullif_exp: NULLIF '(' scalar_exp ',' scalar_exp ')'
		;

 parameter_ref: parameter
              | parameter parameter
              | parameter INDICATOR parameter
			;

 aggregate_ref: AGGREGATE function_name '(' opt_arg_commalist ')'
              | AMMSC '(' DISTINCT scalar_exp ')'
              | AMMSC '(' ALL scalar_exp ')'
              | AMMSC '(' scalar_exp ')'
			;

 literal: STRING
        | WSTRING
        | INTNUM
        | APPROXNUM
        | BINARYNUM
        | NULLX
		;

 signed_literal: STRING
               | WSTRING
               | INTNUM
               | '-' INTNUM
               | '+' INTNUM
               | APPROXNUM
               | '-' APPROXNUM
               | '+' APPROXNUM
               | BINARYNUM
               | NULLX
			;

 q_table_name: identifier
             | identifier '.' identifier
             | identifier '.' identifier '.' identifier
             | identifier '.' '.' identifier
			;

 attach_q_table_name: identifier
                    | identifier '.' identifier
                    | identifier '.' identifier '.' identifier
                    | identifier '.' '.' identifier
				;


 new_proc_or_bif_name: identifier
                     | identifier '.' identifier
                     | identifier '.' identifier '.' identifier
                     | identifier '.' '.' identifier
				;

 new_table_name: identifier
               | identifier '.' identifier
               | identifier '.' identifier '.' identifier
               | identifier '.' '.' identifier
			;

 table: q_table_name opt_table_opt
      | q_table_name AS identifier opt_table_opt
      | q_table_name identifier opt_table_opt
		;

 column_ref: identifier
           | identifier '.' identifier
           | identifier '.' identifier '.' identifier
           | identifier '.' identifier '.' identifier '.' identifier
           | identifier '.' '.' identifier '.' identifier
           | '*'
           | identifier '.' '*'
           | identifier '.' identifier '.' '*'
           | identifier '.' identifier '.' identifier '.' '*'
           | identifier '.' '.' identifier '.' '*'
		;

 base_data_type: NUMERIC
               | NUMERIC '(' INTNUM ')'
               | NUMERIC '(' INTNUM ',' INTNUM ')'
               | DECIMAL
               | DECIMAL '(' INTNUM ')'
               | DECIMAL '(' INTNUM ',' INTNUM ')'
               | INTEGER
               | SMALLINT
               | FLOAT
               | FLOAT '(' INTNUM ')'
               | REAL
               | DOUBLE PRECISION
               | LONG VARCHAR
               | LONG VARBINARY
               | VARBINARY
               | VARBINARY '(' INTNUM ')'
               | BINARY '(' INTNUM ')'
               | TIMESTAMP
               | DATETIME
               | TIME
               | DATE
               | NCHAR
               | NCHAR '(' INTNUM ')'
               | NVARCHAR
               | NVARCHAR '(' INTNUM ')'
               | LONG NVARCHAR
               | ANY
               | ANY '(' INTNUM ')'
			;

 data_type: base_data_type
          | CHARACTER
          | VARCHAR
          | VARCHAR '(' INTNUM ')'
          | CHARACTER '(' INTNUM ')'
		;

 array_modifier: ARRAY
               | ARRAY '[' INTNUM ']'
			;

 data_type_ref: data_type_ref array_modifier
              | data_type
              | q_type_name
			;

 column_data_type: base_data_type
                 | CHARACTER
                 | VARCHAR
                 | VARCHAR '(' INTNUM ')'
                 | CHARACTER '(' INTNUM ')'
                 | q_type_name
                 | LONG q_type_name
                 | LONG XML
			;

 column: identifier
       | identifier '.' identifier '.' identifier '.' identifier
		;

 index: identifier
	;

 cursor: identifier
	;


 parameter: PARAMETER_L
          | NAMED_PARAMETER
		;

 user: identifier
	;

 opt_log: .
        | STRING
		;

 comma_opt_log: .
              | ',' STRING
			;

 admin_statement: SHUTDOWN opt_log
                | CHECKPOINT opt_log
                | CHECKPOINT STRING STRING
                | BACKUP STRING
                | CHECK
                | SYNC REPLICATION opt_log comma_opt_log
                | DISCONNECT REPLICATION opt_log
                | LOGX ON
                | LOGX OFF
			;

 sql: user_aggregate_declaration
    | routine_declaration
    | module_declaration
    | method_declaration
    | trigger_def
    | drop_trigger
    | drop_proc
    |manipulative_statement
    | BEGIN_EQCALL_X q_table_name ENDX
    | BEGIN_EQCALL_X q_table_name '(' opt_scalar_exp_commalist ')' ENDX
	;




 user_aggregate_declaration: CREATE AGGREGATE new_table_name rout_parameter_list opt_return FROM new_proc_or_bif_name ',' new_proc_or_bif_name ',' new_proc_or_bif_name user_aggregate_merge_opt
					;

 user_aggregate_merge_opt: .
                         | ',' new_proc_or_bif_name
					;

 routine_declaration: CREATE routine_head new_table_name rout_parameter_list opt_return rout_alt_type compound_statement
                    | ATTACH routine_head attach_q_table_name rout_parameter_list opt_return rout_alt_type opt_as FROM literal
                    | CREATE routine_head new_table_name rout_parameter_list opt_return rout_alt_type LANGUAGE external_language_name EXTERNAL NAME_L STRING opt_type_option_list
				;

 module_body_part: routine_head identifier rout_parameter_list opt_return rout_alt_type compound_statement
			;

 module_body: module_body_part ';'
            | module_body module_body_part ';'
		;

 module_declaration: CREATE MODULE new_table_name BEGINX module_body ENDX
				;

 routine_head: FUNCTION
             | PROCEDURE
			;

 opt_return: .
           | RETURNS data_type_ref
		;

 rout_parameter_list: '(' ')'
                    | '(' parameter_commalist ')'
				;

 parameter_commalist: rout_parameter
                    | parameter_commalist ',' rout_parameter
				;

 rout_parameter: parameter_mode column_ref data_type_ref rout_alt_type
               | parameter_mode column_ref data_type_ref DEFAULT signed_literal rout_alt_type
               | parameter_mode column_ref data_type_ref EQUALS signed_literal rout_alt_type
			;

 parameter_mode: IN_L
               | OUT_L
               | INOUT_L
			;

 opt_parameter_mode: .
                   | parameter_mode
				;

 opt_soap_enc_mode: .
                  | __SOAP_DIME_ENC IN_L
                  | __SOAP_DIME_ENC OUT_L
                  | __SOAP_DIME_ENC INOUT_L
                  | __SOAP_ENC_MIME IN_L
                  | __SOAP_ENC_MIME OUT_L
                  | __SOAP_ENC_MIME INOUT_L
				;

 soap_proc_opt_list: soap_proc_opt
                   | soap_proc_opt_list ',' soap_proc_opt
				;

 soap_proc_opt: NAME EQUALS signed_literal
			;

 soap_kwd: __SOAP_TYPE
         | __SOAP_HEADER
         | __SOAP_FAULT
         | __SOAP_DOC
         | __SOAP_XML_TYPE
         | __SOAP_DOCW
         | __SOAP_HTTP
		;

 rout_alt_type: .
              | __SOAP_OPTIONS '(' soap_kwd EQUALS STRING opt_soap_enc_mode ',' soap_proc_opt_list ')'
              | soap_kwd STRING opt_soap_enc_mode
			;

 routine_statement: select_statement
                  | update_statement_positioned
                  | update_statement_searched
                  | insert_statement
                  | delete_statement_positioned
                  | delete_statement_searched
                  | close_statement
                  | fetch_statement
                  | open_statement
                  | rollback_statement
                  | commit_statement
                  | .
			;

 empty2: .
	;

 compound_statement: BEGINX empty2 statement_list ENDX
				;

 statement_list: statement_in_cs
               | statement_list statement_in_cs
			;

 statement_in_cs: local_declaration ';'
                | compound_statement
			;

empty3: .
	;

 statement_in_cs: empty3 statement_in_cs_oper
			;

 statement_in_cs_oper: routine_statement ';'
                     | control_statement
                     | identifier COLON statement_in_cs
                     | HTMLSTR
                     | COMPARISON scalar_exp HTMLSTR
                     | '/' scalar_exp HTMLSTR
				;

 statement: compound_statement
		;


 empty4: .
	;

 statement: empty4 routine_statement ';'
		;


 empty5: .
	;

 statement: empty5 control_statement
		;

 local_declaration: cursor_def
                  | variable_declaration
                  | handler_declaration
			;

 variable_declaration: DECLARE variable_list data_type_ref
				;

 variable_list: identifier
              | variable_list ',' identifier
			;

 condition: NOT FOUND
          | SQLSTATE STRING
          | SQLSTATE VALUE STRING
          | SQLEXCEPTION
          | SQLWARNING
		;

 handler_statement: compound_statement
                  | routine_statement
                  | call_statement
                  | method_invocation
                  | static_method_invocation
                  | set_statement
                  | RESIGNAL
                  | RESIGNAL scalar_exp
                  | return_statement
                  | assignment_statement
                  | if_statement
                  | goto_statement
                  | for_statement
                  | while_statement
				;


 handler_declaration: WHENEVER condition GOTO identifier
                    | WHENEVER condition GO TO identifier
                    | WHENEVER condition DEFAULT
                    | DECLARE handler_type HANDLER FOR cond_value_list handler_statement
				;

 handler_type: CONTINUE
             | EXIT
			;

 cond_value_list: condition
                | cond_value_list ',' condition
			;

 control_statement: call_statement ';'
                  | method_invocation ';'
                  | static_method_invocation ';'
                  | set_statement ';'
                  | RESIGNAL ';'
                  | RESIGNAL scalar_exp ';'
                  | return_statement ';'
                  | assignment_statement ';'
                  | if_statement
                  | goto_statement ';'
                  | for_statement
                  | while_statement
				;


 assignment_statement: lvalue EQUALS scalar_exp
                     | column_ref '[' scalar_exp ']' EQUALS scalar_exp
				;

 lvalue: column_ref
       | member_observer
		;

 if_statement: IF '(' search_condition ')' statement opt_else
		;

 opt_else: .
         | ELSE statement
		;


 call_statement: CALL function_name '(' opt_arg_commalist ')'
               | function_call
			;

 set_statement: SET identifier COMPARISON scalar_exp
              | SET identifier ON
              | SET identifier OFF
			;

 goto_statement: GOTO identifier
               | GO TO identifier
			;


 return_statement: RETURN scalar_exp
                 | RETURN
			;

 while_statement: WHILE '(' search_condition ')' statement
		;

 for_init_statement: assignment_statement
                   | variable_declaration
                   | call_statement
                   | static_method_invocation
				;

 for_init_statement_list: .
                        | for_init_statement
                        | for_init_statement_list ',' for_init_statement
					;

 for_inc_statement: assignment_statement
                  | call_statement
                  | static_method_invocation
			;

 for_inc_statement_list: .
                       | for_inc_statement
                       | for_inc_statement_list ',' for_inc_statement
				;

 for_opt_search_cond: .
                    | search_condition
				;

 for_statement: FOR query_exp DO statement
              | FOR '(' for_init_statement_list ';' for_opt_search_cond ';' for_inc_statement_list ')' statement
              | FOREACH '(' data_type_ref identifier IN_L scalar_exp ')' DO statement
			;

 trigger_def: CREATE TRIGGER identifier action_time event ON q_table_name opt_order opt_old_ref trig_action
			;

 opt_order: .
          | ORDER INTNUM
		;

 trig_action: compound_statement
		;

 action_time: BEFORE
            | AFTER
            | INSTEAD OF
			;

 event: INSERT
      | UPDATE opt_column_commalist
      | DELETE_L
		;

 opt_old_ref: .
            | REFERENCING old_commalist
		;

 old_commalist: old_alias
              | old_commalist ',' old_alias
			;

 old_alias: OLD AS identifier
          | NEW AS identifier
		;

 drop_trigger: DROP TRIGGER q_table_name
		;

 drop_proc: DROP AGGREGATE q_table_name
          | DROP routine_head q_table_name
          | DROP MODULE q_table_name
		;

 opt_element: .
            | AS identifier
			;

 xml_col: column_ref
        | scalar_exp AS identifier
        | scalar_exp IN_L identifier
		;

 xml_col_list: xml_col
             | xml_col_list ',' xml_col
			;

 opt_xml_col_list: '(' xml_col_list ')'
			;

 opt_pk: .
       | PRIMARY KEY '(' column_commalist ')'
		;


 opt_join: .
         | ON '(' search_condition ')'
		;

 opt_elt: .
        | NAME
		;


 xml_join_elt: q_table_name identifier opt_element opt_xml_col_list opt_join opt_pk opt_elt opt_xml_child
		;

 opt_xml_child: .
              | BEGINX xml_join_list ENDX
			;


 top_xml_child: query_spec
              | BEGINX xml_join_list ENDX
			;


 xml_join_list: xml_join_elt
              | xml_join_list ',' xml_join_elt
			;

 opt_persist: .
            | PERSISTENT
			;

 opt_interval: .
             | INTERVAL INTNUM
			;


 opt_metas: .
          | DTD INTERNAL
          | DTD EXTERNAL
          | DTD STRING
          | SCHEMA EXTERNAL
          | SCHEMA STRING
		;

 opt_publish: .
            | PUBLIC STRING identifier STRING opt_persist opt_interval opt_metas
		;

 xmlview_param_value: NAME
                    | STRING
				;

 xmlview_param: NAME COMPARISON xmlview_param_value
			;


 xmlview_params: xmlview_param
               | xmlview_params xmlview_param
			;

 opt_xmlview_params: .
                   | '[' xmlview_params ']'
				;

 xml_view: CREATE XML VIEW new_table_name AS opt_xmlview_params top_xml_child opt_elt opt_publish
		;

 drop_xml_view: DROP XML VIEW q_table_name
			;

 string_concatenation_operator: scalar_exp STRING_CONCAT_OPERATOR scalar_exp
						;

 q_type_name: identifier
            | identifier '.' identifier
            | identifier '.' identifier '.' identifier
            | identifier '.' '.' identifier
		;

 q_old_type_name: identifier
                | identifier '.' identifier
                | identifier '.' identifier '.' identifier
                | identifier '.' '.' identifier
			;

 new_type_name: identifier
              | identifier '.' identifier
              | identifier '.' identifier '.' identifier
              | identifier '.' '.' identifier
			;

empty6: .
		;

 user_defined_type: CREATE TYPE new_type_name opt_subtype_clause opt_external_and_language_clause empty6 opt_as_type_representation opt_type_option_list opt_method_specification_list
			;

 user_defined_type_drop: DROP TYPE q_old_type_name opt_drop_behavior
				;

 opt_external_and_language_clause: .
                                 | LANGUAGE language_name EXTERNAL NAME_L STRING
                                 | EXTERNAL NAME_L STRING LANGUAGE language_name
                                 | LANGUAGE language_name
						;

 opt_subtype_clause: .
                   | UNDER q_type_name
				;

 opt_as_type_representation: .
                           | AS type_representation
					;

 type_representation: '(' type_member_list ')'
				;

 type_member_list: type_member
                 | type_member_list ',' type_member
			;

 opt_external_clause: .
                    | EXTERNAL NAME_L STRING
                    | EXTERNAL NAME_L STRING EXTERNAL TYPE STRING
                    | EXTERNAL TYPE STRING
				;

 opt_soap_clause: .
                | __SOAP_NAME STRING
                | __SOAP_TYPE STRING
                | __SOAP_TYPE STRING __SOAP_NAME STRING
                | __SOAP_NAME STRING __SOAP_TYPE STRING
			;

 opt_external_type: .
                  | EXTERNAL TYPE STRING
				;

 type_member: identifier data_type_ref opt_reference_scope_check opt_default_clause opt_collate_exp opt_external_clause opt_soap_clause
		;

 opt_reference_scope_check: .
                          | REFERENCES ARE CHECKED opt_on_delete_referential_rule
                          | REFERENCES ARE NOT CHECKED
					;

 opt_default_clause: .
                   | DEFAULT signed_literal
				;

 opt_type_option_list: .
                     | type_option_list
				;

 type_option_list: type_option
                 | type_option_list type_option
				;

 type_option: FINAL_L
            | NOT FINAL_L
            | REF USING data_type_ref
            | REF FROM '(' column_commalist ')'
            | REF IS SYSTEM GENERATED
            | CAST '(' SOURCE AS REF ')' WITH identifier
            | CAST '(' REF AS SOURCE ')' WITH identifier
            | SELF_L AS REF
            | TEMPORARY
            | UNRESTRICTED
            | __SOAP_TYPE STRING
			;

 opt_method_specification_list: .
                              | method_specification_list
						;

 method_specification_list: method_specification
                          | method_specification_list ',' method_specification
					;

 method_type: .
            | STATIC_L
            | INSTANCE_L	
			;

 decl_parameter_list: '(' ')'
                    | '(' decl_parameter_commalist ')'
				;

 decl_parameter_commalist: decl_parameter
                         | decl_parameter_commalist ',' decl_parameter
					;

 decl_parameter: opt_parameter_mode column_ref data_type_ref opt_external_type
			;

 partial_method_specification: method_type METHOD method_identifier decl_parameter_list RETURNS data_type_ref opt_specific_method_name
                             | CONSTRUCTOR METHOD method_identifier decl_parameter_list opt_specific_method_name
					;

 method_specification: partial_method_specification opt_self_result opt_method_characteristics
                     | OVERRIDING partial_method_specification
				;

 opt_self_result: .
                | SELF_L AS RESULT
                | SELF_L AS LOCATOR
                | SELF_L AS RESULT SELF_L AS LOCATOR
			;

 opt_specific_method_name: .
                         | SPECIFIC new_table_name
					;

 opt_method_characteristics: .
                           | method_characteristics
					;

 method_characteristics: method_characteristic
                       | method_characteristics method_characteristic
					;

 method_characteristic: LANGUAGE language_name
                      | PARAMETER STYLE SQL_L
                      | PARAMETER STYLE GENERAL
                      | DETERMINISTIC
                      | NOT DETERMINISTIC
                      | NO SQL_L
                      | CONTAINS SQL_L
                      | READS SQL_L DATA
                      | MODIFIES SQL_L DATA
                      | RETURNS NULLX ON NULLX INPUT
                      | CALLED ON NULLX INPUT
                      | EXTERNAL NAME_L STRING
                      | EXTERNAL VARIABLE NAME_L STRING
                      | EXTERNAL TYPE STRING
				;

 external_language_name: ADA
                       | C
                       | COBOL
                       | FORTRAN
                       | MUMPS
                       | PASCAL_L
                       | PLI
                       | JAVA
                       | CLR
				;

 language_name: external_language_name
              | SQL_L
			;

 opt_constructor_return: .
                       | RETURNS new_type_name
				;

 method_declaration: CREATE method_type METHOD method_identifier rout_parameter_list opt_return rout_alt_type FOR q_type_name compound_statement
                   | CREATE CONSTRUCTOR METHOD q_table_name rout_parameter_list opt_constructor_return FOR q_type_name compound_statement
				;

 static_method_invocation: q_type_name DOUBLE_COLON method_identifier '(' opt_arg_commalist ')'
					;

 identifier_chain: identifier '.' identifier '.' identifier '.' method_identifier
                 | identifier '.' '.' identifier '.' method_identifier
                 | identifier '.' identifier_chain
			;

 identifier_chain_method: identifier '.' identifier '.' identifier '.' identifier '.' method_identifier
                        | identifier '.' '.' identifier '.' identifier '.' method_identifier
                        | identifier '.' identifier_chain_method
					;

 method_invocation: scalar_exp_no_col_ref_no_mem_obs_chain '.' method_identifier '(' opt_arg_commalist ')'
                  | identifier_chain_method '(' opt_arg_commalist ')'
                  | '(' scalar_exp_no_col_ref AS q_type_name ')' '.' method_identifier '(' opt_arg_commalist ')'
                  | '(' column_ref AS q_type_name ')' '.' method_identifier '(' opt_arg_commalist ')'
			;

 top_level_method_invocation: METHOD CALL scalar_exp_no_col_ref_no_mem_obs_chain '.' method_identifier '(' opt_arg_commalist ')'
                            | METHOD CALL identifier_chain_method '(' opt_arg_commalist ')'
                            | METHOD CALL '(' scalar_exp_no_col_ref AS q_type_name ')' '.' method_identifier '(' opt_arg_commalist ')'
                            | METHOD CALL '(' column_ref AS q_type_name ')' '.' method_identifier '(' opt_arg_commalist ')'
					;

 member_observer: member_observer_no_id_chain
                | identifier '.' identifier_chain
			;

 member_observer_no_id_chain: scalar_exp_no_col_ref_no_mem_obs_chain '.' method_identifier
                            | '(' scalar_exp_no_col_ref AS q_type_name ')' '.' method_identifier
                            | '(' column_ref AS q_type_name ')' '.' method_identifier
					;

 method_identifier: identifier
                  | EXTRACT
				;

 new_invocation: NEW q_type_name '(' opt_arg_commalist ')'
			;

 user_defined_type_alter: ALTER TYPE q_type_name alter_type_action
					;

 alter_type_action: ADD ATTRIBUTE type_member
                  | DROP ATTRIBUTE identifier opt_drop_behavior
                  | ADD method_specification
                  | DROP partial_method_specification opt_drop_behavior
				;

 opt_with_permission_set: .
                        | WITH PERMISSION_SET COMPARISON SAFE_L
                        | WITH PERMISSION_SET COMPARISON UNRESTRICTED
					;

 opt_with_autoregister: .
                      | WITH AUTOREGISTER_L
				;

 create_library: CREATE LIBRARY_L q_table_name AS scalar_exp opt_with_permission_set opt_with_autoregister
			;

 create_assembly: CREATE ASSEMBLY_L q_table_name FROM scalar_exp opt_with_permission_set opt_with_autoregister
			;

 drop_library: DROP LIBRARY_L q_table_name
		;

 drop_assembly: DROP ASSEMBLY_L q_table_name
			;











%nonassoc IF			;
%nonassoc ELSE			;

/* Define the operator tokens and their precedences.
   The value is an integer because, if used, it is the tree code
   to use in the expression made from the operator.  */


%right	ASSIGN '='						;
%right	'?' ':'						;
%left		OROR							;
%left		ANDAND						;
%left  	'|'							;
%left  	'^'							;
%left  	'&'							;
%left  	EQCOMPARE						;
%left  	ARITHCOMPARE					;
%left  	LSHIFT RSHIFT					;
%left  	'+' '-'						;
%left  	'*' '/' '%'					;
%right  	UNARY		PLUSPLUS	MINUSMINUS		;
%left 	HYPERUNARY						;
%left  	POINTSAT	'.'	'('	'['			;



program	:	.
		|	extdefs
		;

extdefs: extdef
	| extdefs extdef
	;

extdef: extdef_1
	;

extdef_1:
	fndef
	| datadef
	| objcdef
	| ASM_KEYWORD '(' expr ')' ';'
	| extension extdef
	;

datadef:
	  setspecs notype_initdecls ';'
	| declspecs_nots setspecs notype_initdecls ';'
	| declspecs_ts setspecs initdecls ';'
	| declspecs ';'
	| error ';'
	| error '}'
	| ';'

;

fndef		:	declspecs_ts setspecs declarator
	  		old_style_parm_decls
	  		save_filename save_lineno compstmt_or_error
	| declspecs_ts setspecs declarator error
	| declspecs_nots setspecs notype_declarator
	  old_style_parm_decls
	  save_filename save_lineno compstmt_or_error
	| declspecs_nots setspecs notype_declarator error
	| setspecs notype_declarator
	  old_style_parm_decls
	  save_filename save_lineno compstmt_or_error
	| setspecs notype_declarator error
	;

identifier:
	IDENTIFIER
	| TYPENAME
	| OBJECTNAME
	| CLASSNAME
	;

unop: '&'
	| '-'
	| '+'
	| PLUSPLUS
	| MINUSMINUS
	| '~'
	| '!'
	;

expr:	nonnull_exprlist
	;

exprlist	:	.
		|	nonnull_exprlist
		;

nonnull_exprlist	:	expr_no_commas
				|	nonnull_exprlist ',' expr_no_commas
				;

unary_expr			:	primary
	| '*' cast_expr   %prec UNARY
	| extension cast_expr	  %prec UNARY
	| unop cast_expr  %prec UNARY
	| ANDAND identifier
	| sizeof unary_expr  %prec UNARY
	| sizeof '(' typename ')'  %prec HYPERUNARY
	| alignof unary_expr  %prec UNARY
	| alignof '(' typename ')'  %prec HYPERUNARY
	| REALPART cast_expr %prec UNARY
	| IMAGPART cast_expr %prec UNARY
	;

sizeof:
	SIZEOF
	;

alignof:
	ALIGNOF
	;

typeof:
	TYPEOF 
	;

cast_expr:
	unary_expr
	| '(' typename ')' cast_expr  %prec UNARY
	;

expr_no_commas:
	  cast_expr
	| expr_no_commas '+' expr_no_commas
	| expr_no_commas '-' expr_no_commas
	| expr_no_commas '*' expr_no_commas
	| expr_no_commas '/' expr_no_commas
	| expr_no_commas '%' expr_no_commas
	| expr_no_commas LSHIFT expr_no_commas
	| expr_no_commas RSHIFT expr_no_commas
	| expr_no_commas ARITHCOMPARE expr_no_commas
	| expr_no_commas EQCOMPARE expr_no_commas
	| expr_no_commas '&' expr_no_commas
	| expr_no_commas '|' expr_no_commas
	| expr_no_commas '^' expr_no_commas
	| expr_no_commas ANDAND expr_no_commas
	| expr_no_commas OROR  expr_no_commas
	| expr_no_commas '?'     expr ':'  expr_no_commas
	| expr_no_commas '?'  ':' expr_no_commas
	| expr_no_commas '=' expr_no_commas
	| expr_no_commas ASSIGN expr_no_commas
	;

primary:
	IDENTIFIER
	| CONSTANT
	| STRING
	| VAR_FUNC_NAME
	| '(' typename ')' '{'
	  initlist_maybe_comma '}'  %prec UNARY
	| '(' expr ')'
	| '(' error ')'
	| compstmt_primary_start compstmt_nostart ')'
	| compstmt_primary_start error ')'
	| primary '(' exprlist ')'   %prec '.'
	| VA_ARG '(' expr_no_commas ',' typename ')'
      | CHOOSE_EXPR '(' expr_no_commas ',' expr_no_commas ',' expr_no_commas ')'
      | TYPES_COMPATIBLE_P '(' typename ',' typename ')'
	| primary '[' expr ']'   %prec '.'
	| primary '.' identifier
	| primary POINTSAT identifier
	| primary PLUSPLUS
	| primary MINUSMINUS
	| objcmessageexpr
	| objcselectorexpr
	| objcprotocolexpr
	| objcencodeexpr
	| objc_string
	;

/* Produces an STRING_CST with perhaps more STRING_CSTs chained
   onto it, which is to be read as an ObjC string object. 
 */
objc_string	:	'@' STRING
			|	objc_string '@' STRING
			;

old_style_parm_decls	:	old_style_parm_decls_1
				;

old_style_parm_decls_1	:	.
					|	datadecls
					;

/* The following are analogous to lineno_decl, decls and decl
   except that they do not allow nested functions.
   They are used for old-style parm decls.  */
lineno_datadecl:
	  save_filename save_lineno datadecl
	;

datadecls:
	lineno_datadecl
	| errstmt
	| datadecls lineno_datadecl
	| lineno_datadecl errstmt
	;

/* We don't allow prefix attributes here because they cause reduce/reduce
   conflicts: we can't know whether we're parsing a function decl with
   attribute suffix, or function defn with attribute prefix on first old
   style parm.  */
datadecl:
	declspecs_ts_nosa setspecs initdecls ';'
	| declspecs_nots_nosa setspecs notype_initdecls ';'
	| declspecs_ts_nosa ';'
	| declspecs_nots_nosa ';'
	;

/* This combination which saves a lineno before a decl
   is the normal thing to use, rather than decl itself.
   This is to avoid shift/reduce conflicts in contexts
   where statement labels are allowed.  */
lineno_decl:
	  save_filename save_lineno decl
	;

/* records the type and storage class specs to use for processing
   the declarators that follow.
   Maintains a stack of outer-level values of current_declspecs,
   for the sake of parm declarations nested in function declarators.  */
setspecs	: .
		;

/* Possibly attributes after a comma, which should reset all_prefix_attributes
   to prefix_attributes with these ones chained on the front.  */
maybe_resetattrs:
	  maybe_attribute
	;

decl:
	declspecs_ts setspecs initdecls ';'
	| declspecs_nots setspecs notype_initdecls ';'
	| declspecs_ts setspecs nested_function
	| declspecs_nots setspecs notype_nested_function
	| declspecs ';'
	| extension decl
	;

/* A list of declaration specifiers.  These are:

   - Storage class specifiers (scspec), which for GCC currently includes
   function specifiers ("inline").

   - Type specifiers (typespec_*).

   - Type qualifiers (TYPE_QUAL).

   - Attribute specifier lists (attributes).

   These are stored as a TREE_LIST; the head of the list is the last
   item in the specifier list.  Each entry in the list has either a
   TREE_PURPOSE that is an attribute specifier list, or a TREE_VALUE that
   is a single other specifier or qualifier; and a TREE_CHAIN that is the
   rest of the list.  TREE_STATIC is set on the list if something other
   than a storage class specifier or attribute has been seen; this is used
   to warn for the obsolescent usage of storage class specifiers other than
   at the start of the list.  (Doing this properly would require function
   specifiers to be handled separately from storage class specifiers.)

   The various cases below are classified according to:

   (a) Whether a storage class specifier is included or not; some
   places in the grammar disallow storage class specifiers (_sc or _nosc).

   (b) Whether a type specifier has been seen; after a type specifier,
   a typedef name is an identifier to redeclare (_ts or _nots).

   (c) Whether the list starts with an attribute; in certain places,
   the grammar requires specifiers that don't start with an attribute
   (_sa or _nosa).

   (d) Whether the list ends with an attribute (or a specifier such that
   any following attribute would have been parsed as part of that specifier);
   this avoids shift-reduce conflicts in the parsing of attributes
   (_ea or _noea).

   TODO:

   (i) Distinguish between function specifiers and storage class specifiers,
   at least for the purpose of warnings about obsolescent usage.

   (ii) Halve the number of productions here by eliminating the _sc/_nosc
   distinction and instead checking where required that storage class
   specifiers aren't present.  */

/* Declspecs which contain at least one type specifier or typedef name.
   (Just `const' or `volatile' is not enough.)
   A typedef'd name following these is taken as a name to be declared.
   Declspecs have a non-NULL TREE_VALUE, attributes do not.  */

declspecs_nosc_nots_nosa_noea:
	  TYPE_QUAL
	| declspecs_nosc_nots_nosa_noea TYPE_QUAL
	| declspecs_nosc_nots_nosa_ea TYPE_QUAL
	;

declspecs_nosc_nots_nosa_ea:
	  declspecs_nosc_nots_nosa_noea attributes
	;

declspecs_nosc_nots_sa_noea:
	  declspecs_nosc_nots_sa_noea TYPE_QUAL
	| declspecs_nosc_nots_sa_ea TYPE_QUAL
	;

declspecs_nosc_nots_sa_ea:
	  attributes
	| declspecs_nosc_nots_sa_noea attributes
	;

declspecs_nosc_ts_nosa_noea:
	  typespec_nonattr
	| declspecs_nosc_ts_nosa_noea TYPE_QUAL
	| declspecs_nosc_ts_nosa_ea TYPE_QUAL
	| declspecs_nosc_ts_nosa_noea typespec_reserved_nonattr
	| declspecs_nosc_ts_nosa_ea typespec_reserved_nonattr
	| declspecs_nosc_nots_nosa_noea typespec_nonattr
	| declspecs_nosc_nots_nosa_ea typespec_nonattr
	;

declspecs_nosc_ts_nosa_ea:
	  typespec_attr
	| declspecs_nosc_ts_nosa_noea attributes
	| declspecs_nosc_ts_nosa_noea typespec_reserved_attr
	| declspecs_nosc_ts_nosa_ea typespec_reserved_attr
	| declspecs_nosc_nots_nosa_noea typespec_attr
	| declspecs_nosc_nots_nosa_ea typespec_attr
	;

declspecs_nosc_ts_sa_noea:
	  declspecs_nosc_ts_sa_noea TYPE_QUAL
	| declspecs_nosc_ts_sa_ea TYPE_QUAL
	| declspecs_nosc_ts_sa_noea typespec_reserved_nonattr
	| declspecs_nosc_ts_sa_ea typespec_reserved_nonattr
	| declspecs_nosc_nots_sa_noea typespec_nonattr
	| declspecs_nosc_nots_sa_ea typespec_nonattr
	;

declspecs_nosc_ts_sa_ea:
	  declspecs_nosc_ts_sa_noea attributes
	| declspecs_nosc_ts_sa_noea typespec_reserved_attr
	| declspecs_nosc_ts_sa_ea typespec_reserved_attr
	| declspecs_nosc_nots_sa_noea typespec_attr
	| declspecs_nosc_nots_sa_ea typespec_attr
	;

declspecs_sc_nots_nosa_noea:
	  scspec
	| declspecs_sc_nots_nosa_noea TYPE_QUAL
	| declspecs_sc_nots_nosa_ea TYPE_QUAL
	| declspecs_nosc_nots_nosa_noea scspec
	| declspecs_nosc_nots_nosa_ea scspec
	| declspecs_sc_nots_nosa_noea scspec
	| declspecs_sc_nots_nosa_ea scspec
	;

declspecs_sc_nots_nosa_ea:
	  declspecs_sc_nots_nosa_noea attributes
	;

declspecs_sc_nots_sa_noea:
	  declspecs_sc_nots_sa_noea TYPE_QUAL
	| declspecs_sc_nots_sa_ea TYPE_QUAL
	| declspecs_nosc_nots_sa_noea scspec
	| declspecs_nosc_nots_sa_ea scspec
	| declspecs_sc_nots_sa_noea scspec
	| declspecs_sc_nots_sa_ea scspec
	;

declspecs_sc_nots_sa_ea:
	  declspecs_sc_nots_sa_noea attributes
	;

declspecs_sc_ts_nosa_noea:
	  declspecs_sc_ts_nosa_noea TYPE_QUAL
	| declspecs_sc_ts_nosa_ea TYPE_QUAL
	| declspecs_sc_ts_nosa_noea typespec_reserved_nonattr
	| declspecs_sc_ts_nosa_ea typespec_reserved_nonattr
	| declspecs_sc_nots_nosa_noea typespec_nonattr
	| declspecs_sc_nots_nosa_ea typespec_nonattr
	| declspecs_nosc_ts_nosa_noea scspec
	| declspecs_nosc_ts_nosa_ea scspec
	| declspecs_sc_ts_nosa_noea scspec
	| declspecs_sc_ts_nosa_ea scspec
	;

declspecs_sc_ts_nosa_ea:
	  declspecs_sc_ts_nosa_noea attributes
	| declspecs_sc_ts_nosa_noea typespec_reserved_attr
	| declspecs_sc_ts_nosa_ea typespec_reserved_attr
	| declspecs_sc_nots_nosa_noea typespec_attr
	| declspecs_sc_nots_nosa_ea typespec_attr
	;

declspecs_sc_ts_sa_noea:
	  declspecs_sc_ts_sa_noea TYPE_QUAL
	| declspecs_sc_ts_sa_ea TYPE_QUAL
	| declspecs_sc_ts_sa_noea typespec_reserved_nonattr
	| declspecs_sc_ts_sa_ea typespec_reserved_nonattr
	| declspecs_sc_nots_sa_noea typespec_nonattr
	| declspecs_sc_nots_sa_ea typespec_nonattr
	| declspecs_nosc_ts_sa_noea scspec
	| declspecs_nosc_ts_sa_ea scspec
	| declspecs_sc_ts_sa_noea scspec
	| declspecs_sc_ts_sa_ea scspec
	;

declspecs_sc_ts_sa_ea:
	  declspecs_sc_ts_sa_noea attributes
	| declspecs_sc_ts_sa_noea typespec_reserved_attr
	| declspecs_sc_ts_sa_ea typespec_reserved_attr
	| declspecs_sc_nots_sa_noea typespec_attr
	| declspecs_sc_nots_sa_ea typespec_attr
	;

/* Particular useful classes of declspecs.  */
declspecs_ts:
	  declspecs_nosc_ts_nosa_noea
	| declspecs_nosc_ts_nosa_ea
	| declspecs_nosc_ts_sa_noea
	| declspecs_nosc_ts_sa_ea
	| declspecs_sc_ts_nosa_noea
	| declspecs_sc_ts_nosa_ea
	| declspecs_sc_ts_sa_noea
	| declspecs_sc_ts_sa_ea
	;

declspecs_nots:
	  declspecs_nosc_nots_nosa_noea
	| declspecs_nosc_nots_nosa_ea
	| declspecs_nosc_nots_sa_noea
	| declspecs_nosc_nots_sa_ea
	| declspecs_sc_nots_nosa_noea
	| declspecs_sc_nots_nosa_ea
	| declspecs_sc_nots_sa_noea
	| declspecs_sc_nots_sa_ea
	;

declspecs_ts_nosa:
	  declspecs_nosc_ts_nosa_noea
	| declspecs_nosc_ts_nosa_ea
	| declspecs_sc_ts_nosa_noea
	| declspecs_sc_ts_nosa_ea
	;

declspecs_nots_nosa:
	  declspecs_nosc_nots_nosa_noea
	| declspecs_nosc_nots_nosa_ea
	| declspecs_sc_nots_nosa_noea
	| declspecs_sc_nots_nosa_ea
	;

declspecs_nosc_ts:
	  declspecs_nosc_ts_nosa_noea
	| declspecs_nosc_ts_nosa_ea
	| declspecs_nosc_ts_sa_noea
	| declspecs_nosc_ts_sa_ea
	;

declspecs_nosc_nots:
	  declspecs_nosc_nots_nosa_noea
	| declspecs_nosc_nots_nosa_ea
	| declspecs_nosc_nots_sa_noea
	| declspecs_nosc_nots_sa_ea
	;

declspecs_nosc:
	  declspecs_nosc_ts_nosa_noea
	| declspecs_nosc_ts_nosa_ea
	| declspecs_nosc_ts_sa_noea
	| declspecs_nosc_ts_sa_ea
	| declspecs_nosc_nots_nosa_noea
	| declspecs_nosc_nots_nosa_ea
	| declspecs_nosc_nots_sa_noea
	| declspecs_nosc_nots_sa_ea
	;

declspecs:
	  declspecs_nosc_nots_nosa_noea
	| declspecs_nosc_nots_nosa_ea
	| declspecs_nosc_nots_sa_noea
	| declspecs_nosc_nots_sa_ea
	| declspecs_nosc_ts_nosa_noea
	| declspecs_nosc_ts_nosa_ea
	| declspecs_nosc_ts_sa_noea
	| declspecs_nosc_ts_sa_ea
	| declspecs_sc_nots_nosa_noea
	| declspecs_sc_nots_nosa_ea
	| declspecs_sc_nots_sa_noea
	| declspecs_sc_nots_sa_ea
	| declspecs_sc_ts_nosa_noea
	| declspecs_sc_ts_nosa_ea
	| declspecs_sc_ts_sa_noea
	| declspecs_sc_ts_sa_ea
	;

/* A (possibly empty) sequence of type qualifiers and attributes.  */
maybe_type_quals_attrs	:	.
					|	declspecs_nosc_nots
					;


/* A type specifier (but not a type qualifier).
   Once we have seen one of these in a declaration,
   if a typedef name appears then it is being redeclared.

   The _reserved versions start with a reserved word and may appear anywhere
   in the declaration specifiers; the _nonreserved versions may only
   appear before any other type specifiers, and after that are (if names)
   being redeclared.

   FIXME: should the _nonreserved version be restricted to names being
   redeclared only?  The other entries there relate only the GNU extensions
   and Objective C, and are historically parsed thus, and don't make sense
   after other type specifiers, but it might be cleaner to count them as
   _reserved.

   _attr means: specifiers that either end with attributes,
   or are such that any following attributes would
   be parsed as part of the specifier.

   _nonattr: specifiers.  */

typespec_nonattr:
	  typespec_reserved_nonattr
	| typespec_nonreserved_nonattr
	;

typespec_attr:
	  typespec_reserved_attr
	;

typespec_reserved_nonattr:
	  TYPESPEC
	| structsp_nonattr
	;

typespec_reserved_attr:
	  structsp_attr
	;

typespec_nonreserved_nonattr:
	  TYPENAME
	| CLASSNAME protocolrefs
	| OBJECTNAME protocolrefs
	| non_empty_protocolrefs
	| typeof '(' expr ')'
	| typeof '(' typename ')'
	;

/* typespec_nonreserved_attr does not exist.  */

initdecls:
	initdcl
	| initdecls ',' maybe_resetattrs initdcl
	;

notype_initdecls:
	notype_initdcl
	| notype_initdecls ',' maybe_resetattrs notype_initdcl
	;

maybeasm:
	  .
	| ASM_KEYWORD '(' STRING ')'
	;

initdcl: declarator maybeasm maybe_attribute '=' init
	| declarator maybeasm maybe_attribute
	;

notype_initdcl:
	  notype_declarator maybeasm maybe_attribute '=' init
	| notype_declarator maybeasm maybe_attribute
	;

maybe_attribute:
      .
  	| attributes
	;

attributes:
      attribute
	| attributes attribute
	;

attribute:
      ATTRIBUTE '(' '(' attribute_list ')' ')'
	;

attribute_list:
      attrib
	| attribute_list ',' attrib
	;

attrib:
    .
	| any_word
	| any_word '(' IDENTIFIER ')'
	| any_word '(' IDENTIFIER ',' nonnull_exprlist ')'
	| any_word '(' exprlist ')'
	;

/* This still leaves out most reserved keywords,
   shouldn't we include them?  */

any_word:
	  identifier
	| scspec
	| TYPESPEC
	| TYPE_QUAL
	;

scspec:
	  STATIC
	| SCSPEC
	;

/* Initializers.  `init' is the entry point.  */

init:
	expr_no_commas
	| '{'
	| error
	;

/* `initlist_maybe_comma' is the guts of an initializer in braces.  */
initlist_maybe_comma:
	  .
	| initlist1 maybecomma
	;

initlist1:
	  initelt
	| initlist1 ',' initelt
	;

/* `initelt' is a single element of an initializer.
   It may use braces.  */
initelt:
	  designator_list '=' initval
	| designator initval
	| identifier ':'
	  initval
	| initval
	;

initval: '{' initlist_maybe_comma '}'
	| expr_no_commas
	| error
	;

designator_list:
	  designator
	| designator_list designator
	;

designator:
	  '.' identifier
	| '[' expr_no_commas ELLIPSIS expr_no_commas ']'
	| '[' expr_no_commas ']'
	;

nested_function:
	  declarator
	   old_style_parm_decls
	  save_filename save_lineno compstmt
	;

notype_nested_function:
	  notype_declarator
	 old_style_parm_decls
	  save_filename save_lineno compstmt
	;

/* Any kind of declarator (thus, all declarators allowed
   after an explicit typespec).  */

declarator:
	  after_type_declarator
	| notype_declarator
	;

/* A declarator that is allowed only after an explicit typespec.  */

after_type_declarator:
	  '(' maybe_attribute after_type_declarator ')'
	| after_type_declarator '(' parmlist_or_identifiers  %prec '.'
	| after_type_declarator '(' error ')'  %prec '.'
	| after_type_declarator array_declarator  %prec '.'
	| '*' maybe_type_quals_attrs after_type_declarator  %prec UNARY
	| TYPENAME
	| OBJECTNAME
	;

/* Kinds of declarator that can appear in a parameter list
   in addition to notype_declarator.  This is like after_type_declarator
   but does not allow a typedef name in parentheses as an identifier
   (because it would conflict with a function with that typedef as arg).  */
parm_declarator:
	  parm_declarator_starttypename
	| parm_declarator_nostarttypename
	;

parm_declarator_starttypename:
	  parm_declarator_starttypename '(' parmlist_or_identifiers  %prec '.'
	| parm_declarator_starttypename '(' error ')'  %prec '.'
	| parm_declarator_starttypename array_declarator  %prec '.'
	| TYPENAME
	| OBJECTNAME
	;

parm_declarator_nostarttypename:
	  parm_declarator_nostarttypename '(' parmlist_or_identifiers  %prec '.'
/*	| parm_declarator_nostarttypename '(' error ')'  %prec '.' */
	| parm_declarator_nostarttypename array_declarator  %prec '.'
	| '*' maybe_type_quals_attrs parm_declarator_starttypename  %prec UNARY
	| '*' maybe_type_quals_attrs parm_declarator_nostarttypename  %prec UNARY
	| '(' maybe_attribute parm_declarator_nostarttypename ')'
	;

/* A declarator allowed whether or not there has been
   an explicit typespec.  These cannot redeclare a typedef-name.  */

notype_declarator:
	  notype_declarator '(' parmlist_or_identifiers  %prec '.'
/*	| notype_declarator '(' error ')'  %prec '.' */
	| '(' maybe_attribute notype_declarator ')'
	| '*' maybe_type_quals_attrs notype_declarator  %prec UNARY
	| notype_declarator array_declarator  %prec '.'
	| IDENTIFIER
	;

struct_head:
	  STRUCT
	| STRUCT attributes
	;

union_head:
	  UNION
	| UNION attributes
	;

enum_head:
	  ENUM
	| ENUM attributes
	;

/* structsp_attr: struct/union/enum specifiers that either
   end with attributes, or are such that any following attributes would
   be parsed as part of the struct/union/enum specifier.

   structsp_nonattr: other struct/union/enum specifiers.  */

structsp_attr:
	  struct_head identifier '{'
	  component_decl_list '}' maybe_attribute
	| struct_head '{' component_decl_list '}' maybe_attribute
	| union_head identifier '{'
	  component_decl_list '}' maybe_attribute
	| union_head '{' component_decl_list '}' maybe_attribute
	| enum_head identifier '{'
	  enumlist maybecomma_warn '}' maybe_attribute
	| enum_head '{'
	  enumlist maybecomma_warn '}' maybe_attribute
	;

structsp_nonattr:
	  struct_head identifier
	| union_head identifier
	| enum_head identifier
	;

maybecomma:
	  .
	| ','
	;

maybecomma_warn:
	  .
	| ','
	;

component_decl_list:
	  component_decl_list2
	| component_decl_list2 component_decl
	;

component_decl_list2:	.
	| component_decl_list2 component_decl ';'
	| component_decl_list2 ';'
	| DEFS '(' CLASSNAME ')'
	;

component_decl:
	  declspecs_nosc_ts setspecs components
	| declspecs_nosc_ts setspecs save_filename save_lineno
	| declspecs_nosc_nots setspecs components_notype
	| declspecs_nosc_nots
	| error
	| extension component_decl
	;

components:
	  component_declarator
	| components ',' maybe_resetattrs component_declarator
	;

components_notype:
	  component_notype_declarator
	| components_notype ',' maybe_resetattrs component_notype_declarator
	;

component_declarator:
	  save_filename save_lineno declarator maybe_attribute
	| save_filename save_lineno
	  declarator ':' expr_no_commas maybe_attribute
	| save_filename save_lineno ':' expr_no_commas maybe_attribute
	;

component_notype_declarator:
	  save_filename save_lineno notype_declarator maybe_attribute
	| save_filename save_lineno
	  notype_declarator ':' expr_no_commas maybe_attribute
	| save_filename save_lineno ':' expr_no_commas maybe_attribute
	;

/* We chain the enumerators in reverse order.
   They are put in forward order where enumlist is used.
   (The order used to be significant, but no longer is so.
   However, we still maintain the order, just to be clean.)  */

enumlist:
	  enumerator
	| enumlist ',' enumerator
	| error
	;


enumerator:
	  identifier
	| identifier '=' expr_no_commas
	;

typename:
	  declspecs_nosc
	  absdcl
	;

absdcl:   /* an absolute declarator */
	.
	| absdcl1
	;

absdcl_maybe_attribute:   /* absdcl maybe_attribute, but not just attributes */
	.
	| absdcl1
	| absdcl1_noea attributes
	;

absdcl1:  /* a nonempty absolute declarator */
	  absdcl1_ea
	| absdcl1_noea
	;

absdcl1_noea:
	  direct_absdcl1
	| '*' maybe_type_quals_attrs absdcl1_noea
	;

absdcl1_ea:
	  '*' maybe_type_quals_attrs
	| '*' maybe_type_quals_attrs absdcl1_ea
	;

direct_absdcl1:
	  '(' maybe_attribute absdcl1 ')'
	| direct_absdcl1 '(' parmlist
	| direct_absdcl1 array_declarator
	| '(' parmlist
	| array_declarator
	;

/* The [...] part of a declarator for an array type.  */

array_declarator:
	'[' maybe_type_quals_attrs expr ']'
	| '[' maybe_type_quals_attrs ']'
	| '[' maybe_type_quals_attrs '*' ']'
	| '[' STATIC maybe_type_quals_attrs expr ']'
	/* declspecs_nosc_nots is a synonym for type_quals_attrs.  */
	| '[' declspecs_nosc_nots STATIC expr ']'
	;

/* A nonempty series of declarations and statements (possibly followed by
   some labels) that can form the body of a compound statement.
   NOTE: we don't allow labels on declarations; this might seem like a
   natural extension, but there would be a conflict between attributes
   on the label and prefix attributes on the declaration.  */

stmts_and_decls:
	  lineno_stmt_decl_or_labels_ending_stmt
	| lineno_stmt_decl_or_labels_ending_decl
	| lineno_stmt_decl_or_labels_ending_label
	| lineno_stmt_decl_or_labels_ending_error
	;

lineno_stmt_decl_or_labels_ending_stmt:
	  lineno_stmt
	| lineno_stmt_decl_or_labels_ending_stmt lineno_stmt
	| lineno_stmt_decl_or_labels_ending_decl lineno_stmt
	| lineno_stmt_decl_or_labels_ending_label lineno_stmt
	| lineno_stmt_decl_or_labels_ending_error lineno_stmt
	;

lineno_stmt_decl_or_labels_ending_decl:
	  lineno_decl
	| lineno_stmt_decl_or_labels_ending_stmt lineno_decl
	| lineno_stmt_decl_or_labels_ending_decl lineno_decl
	| lineno_stmt_decl_or_labels_ending_error lineno_decl
	;

lineno_stmt_decl_or_labels_ending_label:
	  lineno_label
	| lineno_stmt_decl_or_labels_ending_stmt lineno_label
	| lineno_stmt_decl_or_labels_ending_decl lineno_label
	| lineno_stmt_decl_or_labels_ending_label lineno_label
	| lineno_stmt_decl_or_labels_ending_error lineno_label
	;

lineno_stmt_decl_or_labels_ending_error:
	errstmt
	| lineno_stmt_decl_or_labels errstmt
	;

lineno_stmt_decl_or_labels:
	  lineno_stmt_decl_or_labels_ending_stmt
	| lineno_stmt_decl_or_labels_ending_decl
	| lineno_stmt_decl_or_labels_ending_label
	| lineno_stmt_decl_or_labels_ending_error
	;

errstmt:  error ';'
	;

pushlevel:  .
	;

poplevel:  .
        ;

/* Start and end blocks created for the new scopes of C99.  */
c99_block_start: .
	;

/* Productions using c99_block_start and c99_block_end will need to do what's
   in compstmt: RECHAIN_STMTS ($1, COMPOUND_BODY ($1)); $$ = $2; where
   $1 is the value of c99_block_start and $2 of c99_block_end.  */
c99_block_end: .
	;

/* Read zero or more forward-declarations for labels
   that nested functions can jump to.  */
maybe_label_decls:
	  .
	| label_decls
	;

label_decls:
	  label_decl
	| label_decls label_decl
	;

label_decl:
	  LABEL identifiers_or_typenames ';'
	;

/* This is the body of a function definition.
   It causes syntax errors to ignore to the next openbrace.  */
compstmt_or_error:
	  compstmt
	| error compstmt
	;

compstmt_start: '{' 
        ;

compstmt_nostart: '}'
	| pushlevel maybe_label_decls compstmt_contents_nonempty '}' poplevel
	;

compstmt_contents_nonempty:
	  stmts_and_decls
	| error
	;

compstmt_primary_start:
	'(' '{'
        ;

compstmt: compstmt_start compstmt_nostart
	;

/* Value is number of statements counted as of the closeparen.  */
simple_if:
	  if_prefix c99_block_lineno_labeled_stmt
/* Make sure c_expand_end_cond is run once
   for each call to c_expand_start_cond.
   Otherwise a crash is likely.  */
	| if_prefix error
	;

if_prefix:
	  /* We must build the IF_STMT node before parsing its
	     condition so that STMT_LINENO refers to the line
	     containing the "if", and not the line containing
	     the close-parenthesis.

	     c_begin_if_stmt returns the IF_STMT node, which
	     we later pass to c_expand_start_cond to fill
	     in the condition and other tidbits.  */
          IF '(' expr ')'
        ;

/* This is a subroutine of stmt.
   It is used twice, once for valid DO statements
   and once for catching errors in parsing the end test.  */
do_stmt_start:
	  DO
	  c99_block_lineno_labeled_stmt WHILE
	;

/* The forced readahead in here is because we might be at the end of a
   line, and the line and file won't be bumped until yylex absorbs the
   first token on the next line.  */
save_filename:	.
	;

save_lineno:	.
	;

lineno_labeled_stmt:
	  lineno_stmt
	| lineno_label lineno_labeled_stmt
	;

/* Like lineno_labeled_stmt, but a block in C99.  */
c99_block_lineno_labeled_stmt:
	  c99_block_start lineno_labeled_stmt c99_block_end
	;

lineno_stmt:
	  save_filename save_lineno stmt
	;

lineno_label:
	  save_filename save_lineno label
	;

select_or_iter_stmt:
	  simple_if ELSE
	| simple_if %prec IF
/* Make sure c_expand_end_cond is run once
   for each call to c_expand_start_cond.
   Otherwise a crash is likely.  */
	| simple_if ELSE error
       /* We must build the WHILE_STMT node before parsing its
	  condition so that STMT_LINENO refers to the line
	  containing the "while", and not the line containing
	  the close-parenthesis.

	  c_begin_while_stmt returns the WHILE_STMT node, which
	  we later pass to c_finish_while_stmt_cond to fill
	  in the condition and other tidbits.  */
	| WHILE
	  '(' expr ')'
	  c99_block_lineno_labeled_stmt
	| do_stmt_start
	  '(' expr ')' ';'
	| do_stmt_start error
	| FOR
	  '(' for_init_stmt
	  xexpr ';'
	  xexpr ')'
	  c99_block_lineno_labeled_stmt
	| SWITCH '(' expr ')'
	  c99_block_lineno_labeled_stmt
	;

for_init_stmt:
	  xexpr ';'
	| decl
	;

/* Parse a single real statement, not including any labels.  */
stmt:
	  compstmt
	| expr ';'
	| c99_block_start select_or_iter_stmt c99_block_end
	| BREAK ';'
	| CONTINUE ';'
	| RETURN ';'
	| RETURN expr ';'
	| ASM_KEYWORD maybe_type_qual '(' expr ')' ';'
	/* This is the case with just output operands.  */
	| ASM_KEYWORD maybe_type_qual '(' expr ':' asm_operands ')' ';'
	/* This is the case with input operands as well.  */
	| ASM_KEYWORD maybe_type_qual '(' expr ':' asm_operands ':'
	  asm_operands ')' ';'
	/* This is the case with clobbered registers as well.  */
	| ASM_KEYWORD maybe_type_qual '(' expr ':' asm_operands ':'
  	  asm_operands ':' asm_clobbers ')' ';'
	| GOTO identifier ';'
	| GOTO '*' expr ';'
	| ';'
	;

/* Any kind of label, including jump labels and case labels.
   ANSI C accepts labels only before statements, but we allow them
   also at the end of a compound statement.  */

label:	  CASE expr_no_commas ':'
	| CASE expr_no_commas ELLIPSIS expr_no_commas ':'
	| DEFAULT ':'
	| identifier save_filename save_lineno ':' maybe_attribute
	;

/* Either a type-qualifier or nothing.  First thing in an `asm' statement.  */

maybe_type_qual:
	.
	| TYPE_QUAL
	;

xexpr:
	.
	| expr
	;

/* These are the operands other than the first string and colon
   in  asm ("addextend %2,%1": "=dm" (x), "0" (y), "g" (*x))  */
asm_operands: .
	| nonnull_asm_operands
	;

nonnull_asm_operands:
	  asm_operand
	| nonnull_asm_operands ',' asm_operand
	;

asm_operand:
	  STRING '(' expr ')'
	| '[' identifier ']' STRING '(' expr ')'
	;

asm_clobbers	:	STRING	
			|	asm_clobbers ',' STRING
			;

/* This is what appears inside the parens in a function declarator.
   Its value is a list of ..._TYPE nodes.  Attributes must appear here
   to avoid a conflict with their appearance after an open parenthesis
   in an abstract declarator, as in
   "void bar (int (__attribute__((__mode__(SI))) int foo));".  */
parmlist:
	  maybe_attribute
	  parmlist_1
	;

parmlist_1:
	  parmlist_2 ')'
	| parms ';'
	  maybe_attribute
	  parmlist_1
	| error ')'
	;

/* This is what appears inside the parens in a function declarator.
   Is value is represented in the format that grokdeclarator expects.  */
parmlist_2:  .
	| ELLIPSIS
		  /* Gcc used to allow this as an extension.  However, it does
		     not work for all targets, and thus has been disabled.
		     Also, since func (...) and func () are indistinguishable,
		     it caused problems with the code in expand_builtin which
		     tries to verify that BUILT_IN_NEXT_ARG is being used
		     correctly.  */
	| parms
	| parms ',' ELLIPSIS
	;

parms:
	firstparm
	| parms ',' parm
	;

/* A single parameter declaration or parameter type name,
   as found in a parmlist.  */
parm:
	  declspecs_ts setspecs parm_declarator maybe_attribute
	| declspecs_ts setspecs notype_declarator maybe_attribute
	| declspecs_ts setspecs absdcl_maybe_attribute
	| declspecs_nots setspecs notype_declarator maybe_attribute
	| declspecs_nots setspecs absdcl_maybe_attribute
	;

/* The first parm, which must suck attributes from off the top of the parser
   stack.  */
firstparm:
	  declspecs_ts_nosa setspecs_fp parm_declarator maybe_attribute
	| declspecs_ts_nosa setspecs_fp notype_declarator maybe_attribute
	| declspecs_ts_nosa setspecs_fp absdcl_maybe_attribute
	| declspecs_nots_nosa setspecs_fp notype_declarator maybe_attribute
	| declspecs_nots_nosa setspecs_fp absdcl_maybe_attribute
	;

setspecs_fp:
	  setspecs
	;

/* This is used in a function definition
   where either a parmlist or an identifier list is ok.
   Its value is a list of ..._TYPE nodes or a list of identifiers.  */
parmlist_or_identifiers:
	  maybe_attribute
	  parmlist_or_identifiers_1
	;

parmlist_or_identifiers_1:
	  parmlist_1
	| identifiers ')'
	;

/* A nonempty list of identifiers.  */
identifiers:
	IDENTIFIER
	| identifiers ',' IDENTIFIER
	;

/* A nonempty list of identifiers, including typenames.  */
identifiers_or_typenames:
	identifier
	| identifiers_or_typenames ',' identifier
	;


extension	:	EXTENSION
		;

/* Objective-C productions.  */

objcdef:
	  classdef
	| classdecl
	| aliasdecl
	| protocoldef
	| methoddef
	| END
	;

/* A nonempty list of identifiers.  */
identifier_list:
	identifier
	| identifier_list ',' identifier
	;

classdecl:
	  CLASS identifier_list ';'
	;

aliasdecl:
	  ALIAS identifier identifier ';'
	;

classdef:
	  INTERFACE identifier protocolrefs '{'
	  ivar_decl_list '}'
	  methodprotolist
	  END
	| INTERFACE identifier protocolrefs
	  methodprotolist
	  END
	| INTERFACE identifier ':' identifier protocolrefs '{'
	  ivar_decl_list '}'
	  methodprotolist
	  END
	| INTERFACE identifier ':' identifier protocolrefs
	  methodprotolist
	  END
	| IMPLEMENTATION identifier '{'
	  ivar_decl_list '}'
	| IMPLEMENTATION identifier
	| IMPLEMENTATION identifier ':' identifier '{'
	  ivar_decl_list '}'
	| IMPLEMENTATION identifier ':' identifier
	| INTERFACE identifier '(' identifier ')' protocolrefs
	  methodprotolist
	  END
	| IMPLEMENTATION identifier '(' identifier ')'
	;

protocoldef:
	  PROTOCOL identifier protocolrefs
	  methodprotolist END
	/* The @protocol forward-declaration production introduces a
	   reduce/reduce conflict on ';', which should be resolved in
	   favor of the production 'identifier_list -> identifier'.  */
	| PROTOCOL identifier_list ';'
	;

protocolrefs:
	  .
	| non_empty_protocolrefs
	;

non_empty_protocolrefs:
	  ARITHCOMPARE identifier_list ARITHCOMPARE
	;

ivar_decl_list:
          ivar_decl_list visibility_spec ivar_decls
        | ivar_decls
        ;

visibility_spec:
	  PRIVATE
	| PROTECTED
	| PUBLIC
	;

ivar_decls:
          .
	| ivar_decls ivar_decl ';'
	| ivar_decls ';'
	;


/* There is a shift-reduce conflict here, because `components' may
   start with a `typename'.  It happens that shifting (the default resolution)
   does the right thing, because it treats the `typename' as part of
   a `typed_typespecs'.

   It is possible that this same technique would allow the distinction
   between `notype_initdecls' and `initdecls' to be eliminated.
   But I am being cautious and not trying it.  */

ivar_decl:
	declspecs_nosc_ts setspecs ivars
	| declspecs_nosc_nots setspecs ivars
	| error
	;

ivars:
	  .
	| ivar_declarator
	| ivars ',' maybe_resetattrs ivar_declarator
	;

ivar_declarator:
	  declarator
	| declarator ':' expr_no_commas
	| ':' expr_no_commas
	;

methodtype: '+' | '-'
	;

methoddef:
	  methodtype
	  methoddecl
	  optarglist
	  compstmt_or_error
	;

/* the reason for the strange actions in this rule
 is so that notype_initdecls when reached via datadef
 can find a valid list of type and sc specs in $0. */

methodprotolist:	.
	|  methodprotolist2
	;

methodprotolist2:		 /* eliminates a shift/reduce conflict */
	   methodproto
	|  datadef
	| methodprotolist2 methodproto
	| methodprotolist2  datadef
	;

semi_or_error:
	  ';'
	| error
	;

methodproto:
	  methodtype
	  methoddecl
	  semi_or_error
	;

methoddecl:
	  '(' typename ')' unaryselector
	| unaryselector
	| '(' typename ')' keywordselector optparmlist
	| keywordselector optparmlist
	;

/* "optarglist" assumes that start_method_def has already been called...
   if it is not, the "xdecls" will not be placed in the proper scope */

optarglist:
	  .
	| ';' myxdecls
	;

/* to get around the following situation: "int foo (int a) int b; {}" that
   is synthesized when parsing "- a:a b:b; id c; id d; { ... }" */

myxdecls:
	  .
	| mydecls
	;

mydecls:
	mydecl
	| errstmt
	| mydecls mydecl
	| mydecl errstmt
	;

mydecl:
	declspecs_ts setspecs myparms ';'
	| declspecs_ts ';'
	| declspecs_nots ';'
	;

myparms:
	myparm
	| myparms ',' myparm
	;

/* A single parameter declaration or parameter type name,
   as found in a parmlist. DOES NOT ALLOW AN INITIALIZER OR ASMSPEC */

myparm:
	  parm_declarator maybe_attribute
	| notype_declarator maybe_attribute
	| absdcl_maybe_attribute
	;

optparmlist	:	.
			|	',' ELLIPSIS
			|	',' parmlist_2
			;

unaryselector:
	  selector
	;

keywordselector:
	  keyworddecl

	| keywordselector keyworddecl
	;

selector:
	  IDENTIFIER
	| TYPENAME
	| CLASSNAME
	| OBJECTNAME
	| reservedwords
	;

reservedwords:
	  ENUM | STRUCT	| UNION	| IF | ELSE | WHILE | DO | FOR
	| SWITCH | CASE | DEFAULT | BREAK | CONTINUE | RETURN
	| GOTO | ASM_KEYWORD | SIZEOF | TYPEOF | ALIGNOF
	| TYPESPEC | TYPE_QUAL
	;

keyworddecl:
	  selector ':' '(' typename ')' identifier
	| selector ':' identifier
	| ':' '(' typename ')' identifier
	| ':' identifier
	;

messageargs:
	  selector
        | keywordarglist
	;

keywordarglist:
	  keywordarg
	| keywordarglist keywordarg
	;


keywordexpr:
	  nonnull_exprlist
	;

keywordarg:
	  selector ':' keywordexpr
	| ':' keywordexpr
	;

receiver:
	  expr
	| CLASSNAME
	;

objcmessageexpr:
	  '[' receiver messageargs ']'
	;

selectorarg:
	  selector
        | keywordnamelist
	;

keywordnamelist:
	  keywordname
	| keywordnamelist keywordname
	;

keywordname:
	  selector ':'
	| ':'
	;

objcselectorexpr:
	  SELECTOR '(' selectorarg ')'
	;

objcprotocolexpr:
	  PROTOCOL '(' identifier ')'
	;

/* extension to support C-structures in the archiver */

objcencodeexpr:
	  ENCODE '(' typename ')'
	;
















%name	delim 			:	"[ \r\n\t]"			
				;
%name	comment		:	"/\*([^\*]|\*+[^\*/])*\*+/"	
				;
%name	comment_line	:	"//[^\n]*\n"			
				;
%name	digit			:	"[0-9]"				
				;
%name	number			:	"{digit}+"				
				;
%name	letter			:	"[A-Z_a-z]"
				;



%name hex_digit		:	"[0-9a-fA-F]"
				;

%name hex_literal 	:	"0(x|X){hex_digit}+"
				;


%name dec_literal	:	"(0|[1-9][0-9]*)"
				;




%name skip_lexem	: 	"{delim}|{comment}|{comment_line}"
				;

/*  '"'  == \x22,  '\'' == \x27 */

%name	escape_seq		:	"(\\(\x22|\x27))"	
				;

%name	string_dq		: 	"(\x22({escape_seq}|[^\x22])*\x22)"		//只提取"..."或"\""此类串，其它词法规则要到语义例程中处理	
				;

%name	string_sq		:	"\x27({escape_seq}|[^\x27])*\x27"		//提取'...'或'\''此类串，其它词法规则要到语义例程中处理	
				;

%name string_literal	:	"{string_sq}|{string_dq}"
				;

%token %skip 		:	"{delim}+|{comment}+|{comment_line}+"		,1		%value	"TOK_DELIM_ID"		;



			


/*
由于引擎本身的算法原因，必须把相同前缀最长的匹配的优先级提到最高，例如匹配
"=" 和"=="，需要把==的优先级设置到大于"="才可以正常匹配
*/


//%token	HEX_CONSTANT	:	"{hex_literal}(?!{keyword_lhd})"			,2	%value "TOK_HEX_CONSTANT"		;
//%token	DEC_CONSTANT	:	"{dec_literal}(?!{keyword_lhd})"			,1	%value "TOK_DEC_CONSTANT"		;

%token	NUMBER		:	"({hex_literal}|{dec_literal})(?!{keyword_lhd})"	,2	%value "TOK_NUMBER"	;


%token	STRING_LITERAL	:	"{string_literal}"					%value "TOK_STRING_LITERAL"	;	
%token	IDENTIFIER		:	"{letter}({letter}|{digit})*"			%value "TOK_IDENTIFIER"		;


%name		keyword_lhd	:	"[A-Z_a-z0-9]"														;




%token	"switch"	:	'"switch"(?!{keyword_lhd})'	,1					%value 	"TOK_SWITCH"		;//SWITCH
%token	"for"		:	'"for"(?!{keyword_lhd})'		,1				%value		"TOK_FOR"			;//FOR

%token	"return"	:	'"return"(?!{keyword_lhd})'	,1					%value	"TOK_RETURN"		;//RETURN
%token	"do"		:	'"do"(?!{keyword_lhd})'		,1					%value	"TOK_DO"			;//DO
%token	"while"	:	'"while"(?!{keyword_lhd})'		,1					%value	"TOK_WHILE"		;//WHILE
%token	"if"		:	'"if"(?!{keyword_lhd})'		,1					%value	"TOK_IF"			;//IF
%token	"else"		:	'"else"(?!{keyword_lhd})'		,1					%value	"TOK_ELSE"			;//ELSE



%token	"true"		:	'"true"(?!{keyword_lhd})'		,1					%value	"TOK_TRUE"			;
%token	"false"	:	'"false"(?!{keyword_lhd})'		,1					%value	"TOK_FALSE"		;
%token	"this"		:	'"this"(?!{keyword_lhd})'		,1					%value	"TOK_THIS"			;

%token	"null"		:	'"null"(?!{keyword_lhd})'		,1					%value	"TOK_NULL"			;
%token	"const"	:	'"const"(?!{keyword_lhd})'		,1					%value	"TOK_CONST"		;
%token	"in"		:	'"in"(?!{keyword_lhd})'		,1					%value	"TOK_IN"			;
%token	"new"		:	'"new"(?!{keyword_lhd})'		,1					%value	"TOK_NEW"			;
%token	"delete"	:	'"delete"(?!{keyword_lhd})'		,1				%value	"TOK_DELETE"		;
%token	"typeof"	:	'"typeof"(?!{keyword_lhd})'		,1				%value	"TOK_TYPEOF"		;
%token	"function"	:	'"function"(?!{keyword_lhd})'		,1				%value	"TOK_FUNCTION"		;
%token	"var"		:	'"var"(?!{keyword_lhd})'			,1				%value	"TOK_VAR"			;
%token	"with"	:	'"with"(?!{keyword_lhd})'			,1				%value	"TOK_WITH"			;
%token	"instanceof"	:	'"instanceof"(?!{keyword_lhd})'		,1			%value	"TOK_INSTANCEOF"	;
%token	"debugger"	:	'"debugger"(?!{keyword_lhd})'		,1			%value	"TOK_DEBUGGER"	;
%token	"try"		:	'"try"(?!{keyword_lhd})'		,1					%value	"TOK_TRY"			;
%token	"catch"	:	'"catch"(?!{keyword_lhd})'		,1					%value	"TOK_CATCH"		;
%token	"finally"	:	'"finally"(?!{keyword_lhd})'	,1					%value	"TOK_FINALLY"		;
%token	"throw"	:	'"throw"(?!{keyword_lhd})'		,1					%value	"TOK_THROW"		;


%token	"continue"	:	'"continue"(?!{keyword_lhd})'	,1					%value	"TOK_CONTINUE"		;//CONTINUE
%token	"default"	:	'"default"(?!{keyword_lhd})'	,1					%value	"TOK_DEFAULT"		;//DEFAULT
%token	"case"		:	'"case"(?!{keyword_lhd})'		,1					%value	"TOK_CASE"			;//CASE
%token	"break"	:	'"break"(?!{keyword_lhd})'		,1					%value	"TOK_BREAK"		;//BREAK





%token	"void"	:	'"void"(?!{keyword_lhd})'		,1					%value	"TOK_VOID"			;//VOID




%token	">>="		:	'">>="'		,2								%value	"TOK_RIGHT_ASSIGN"	;//RIGHT_ASSIGN
%token	"<<="		:	'"<<="'		,2								%value	"TOK_LEFT_ASSIGN"	;//LEFT_ASSIGN


%token	">>>="	:	'">>>="'		,3								%value	"TOK_UNSIGNED_RIGHT_ASSIGN"	;

%token	">>>"		:	'">>>"'		,2								%value	"TOK_UNSIGNED_RIGHT"			;

%token	"==="		:	'"==="'		,2								%value	"TOK_STRICT_EQ_OP"			;
%token	"!=="		:	'"!=="'		,2								%value	"TOK_STRICT_NE_OP"			;






%token	"+="		:	'"+="'		,1								%value	"TOK_ADD_ASSIGN"	;//ADD_ASSIGN
%token	"-="		:	'"-="'		,1								%value	"TOK_SUB_ASSIGN"	;//SUB_ASSIGN
%token	"*="		:	'"*="'		,1								%value	"TOK_MUL_ASSIGN"	;//MUL_ASSIGN
%token	"/="		:	'"/="'		,1								%value	"TOK_DIV_ASSIGN"	;//DIV_ASSIGN
%token	"%="		:	'"%="'		,1								%value	"TOK_MOD_ASSIGN"	;//MOD_ASSIGN
%token	"&="		:	'"&="'		,1								%value	"TOK_AND_ASSIGN"	;//AND_ASSIGN

%token	"^="		:	'"^="'		,1								%value	"TOK_XOR_ASSIGN"	;//XOR_ASSIGN
%token	"|="		:	'"|="'		,1								%value	"TOK_OR_ASSIGN"		;//OR_ASSIGN
%token	">>"		:	'">>"'		,1								%value	"TOK_RIGHT_OP"		;//RIGHT_OP
%token	"<<"		:	'"<<"'		,1								%value	"TOK_LEFT_OP"		;//LEFT_OP
%token	"++"		:	'"++"'		,1								%value	"TOK_INC_OP"		;//INC_OP
%token	"--"		:	'"--"'		,1								%value	"TOK_DEC_OP"		;//DEC_OP



%token	"&&"		:	'"&&"'		,1								%value	"TOK_AND_OP"		;//AND_OP
%token	"||"		:	'"||"'		,1								%value	"TOK_OR_OP"		;//OR_OP

%token	"<="		:	'"<="'		,1								%value 	"TOK_LE_OP"		;//LE_OP
%token	">="		:	'">="'		,1								%value 	"TOK_GE_OP"		;//GE_OP
%token	"=="		:	'"=="'		,1								%value 	"TOK_EQ_OP"		;//EQ_OP
%token	"!="		:	'"!="'		,1								%value	"TOK_NE_OP"		;//NE_OP
%token	"<"		:	'"<"'		,0								%value	"TOK_LESS_OP"		;//<
%token	">"		:	'">"'		,0								%value	"TOK_GREATER_OP"	;//>



%token	";"		:	'";"'		,0								%value "TOK_SEMICOLON"			;//;
%token	"{"		:	'"{"'		,0								%value "TOK_L_BRACES"			;//{
%token	"}"		:	'"}"'		,0								%value "TOK_R_BRACES"			;//}
%token	","		:	'","'		,0								%value "TOK_COMMA"				;//,
%token	":"		:	'":"'		,0								%value "TOK_COLON"				;//:
%token	"="		:	'"="'		,0								%value "TOK_ASSIGN"				;//=
%token	"("		:	'"("'		,0								%value "TOK_L_PAREN"				;//(
%token	")"		:	'")"'		,0								%value "TOK_R_PAREN"				;//)
%token	"["		:	'"["'		,0								%value "TOK_L_SQUARE"			;//[
%token	"]"		:	'"]"'		,0								%value "TOK_R_SQUARE"			;//]
%token	"."		:	'"."'		,0								%value "TOK_DOT"				;//.
%token	"&"		:	'"&"'		,0								%value "TOK_AND"				;//&
%token	"!"		:	'"!"'		,0								%value "TOK_NOT"				;//!
%token	"~"		:	'"~"'		,0								%value "TOK_TILDE"				;//~
%token	"+"		:	'"+"'		,0								%value "TOK_ADD"				;//+
%token	"-"		:	'"-"'		,0								%value "TOK_SUB"				;//-
%token	"*"		:	'"*"'		,0								%value "TOK_MUL"				;//*
%token	"/"		:	'"/"'		,0								%value "TOK_DIV"				;///
%token	"%"		:	'"%"'		,0								%value "TOK_MOD"				;//%

%token	"^"		:	'"^"'		,0								%value "TOK_XOR"				;//^
%token	"|"		:	'"|"'		,0								%value "TOK_OR"					;//|
%token	"?"		:	'"?"'		,0								%value "TOK_QUEST"				;//?




%nonassoc IF_WITHOUT_ELSE	;
%nonassoc "else"		;


%start	Program		;

Literal	:	"null"
  		|	"true"
  		|	"false"
		| 	NUMBER
  		| 	STRING_LITERAL
		;

Property	:    IDENTIFIER 	":"	AssignmentExpr 	
		|	STRING_LITERAL	":"	AssignmentExpr
		|	NUMBER 		":"	AssignmentExpr
		|	IDENTIFIER IDENTIFIER "(" ")" "{" 	FunctionBody 	"}"
		|	IDENTIFIER IDENTIFIER "(" FormalParameterList ")" 	"{" FunctionBody "}"
		;


PropertyList	:	Property
  			|	PropertyList "," Property
			;

PrimaryExpr	:	PrimaryExprNoBrace
  			|	"{" 	"}"
  			|	"{" PropertyList "}"
  			|	"{" PropertyList "," "}"
			;


PrimaryExprNoBrace	:   "this"
  				|	Literal
  				|	ArrayLiteral
				|	IDENTIFIER
  				|	"("	Expr	")"
				;

ArrayLiteral		:    	"[" ElisionOpt "]"
  			|	"[" ElementList "]" 
  			|	"[" ElementList "," ElisionOpt "]"
			;

ElementList		:	ElisionOpt AssignmentExpr
  			|	ElementList "," ElisionOpt AssignmentExpr
			;

ElisionOpt		:	.
  			|	Elision
			;

Elision		:	","                                 
  			| 	Elision ","                         
			;


MemberExpr		:	PrimaryExpr
  			|	FunctionExpr                        
  			|	MemberExpr "[" Expr "]"             
  			|	MemberExpr "." IDENTIFIER         
  			|	"new" MemberExpr Arguments     
			;

MemberExprNoBF	:	PrimaryExprNoBrace
  			|	MemberExprNoBF "[" Expr "]"  
  			|	MemberExprNoBF "." IDENTIFIER     
  			|	"new" MemberExpr Arguments     
			;

NewExpr		:    MemberExpr
  			|	"new"	NewExpr 
			;

NewExprNoBF	:	MemberExprNoBF
	 		|	"new" NewExpr         
			;

CallExpr		:	MemberExpr Arguments      
  			|	CallExpr Arguments        
  			|	CallExpr "[" Expr "]"     
  			|	CallExpr "." IDENTIFIER        
			;

CallExprNoBF	:	MemberExprNoBF Arguments     
			|	CallExprNoBF Arguments       
  			|	CallExprNoBF "[" Expr "]"    
			|	CallExprNoBF "." IDENTIFIER  
			;

Arguments		:	"(" ")"                   
  			|	"(" ArgumentList ")"      
			;

ArgumentList		:	AssignmentExpr            
  			|	ArgumentList "," AssignmentExpr 
			;

LeftHandSideExpr	:	NewExpr
  			|	CallExpr
			;

LeftHandSideExprNoBF	:	NewExprNoBF
  				|	CallExprNoBF
				;

PostfixExpr		:	LeftHandSideExpr
  				|	LeftHandSideExpr "++"
  				|	LeftHandSideExpr "--"
				;

PostfixExprNoBF		:	LeftHandSideExprNoBF
  				|	LeftHandSideExprNoBF "++"
  				|	LeftHandSideExprNoBF "--"
				;

UnaryExprCommon		:	"delete" UnaryExpr            
  				|	"void" UnaryExpr          
  				|	"typeof" UnaryExpr             
  				|	"++" UnaryExpr           
  				|	"--" UnaryExpr       
  				|	"+" UnaryExpr              
  				|	"-" UnaryExpr              
  				|	"~" UnaryExpr              
  				|	"!" UnaryExpr
//  | AUTOMINUSMINUS UnaryExpr   
//  | AUTOPLUSPLUS UnaryExpr     
				;

UnaryExpr			:	PostfixExpr
  				|	UnaryExprCommon
				;

UnaryExprNoBF		:	PostfixExprNoBF
  				|	UnaryExprCommon
				;

MultiplicativeExpr	:    UnaryExpr
  				|	MultiplicativeExpr "*" UnaryExpr 
  				|	MultiplicativeExpr "/" UnaryExpr 
  				|	MultiplicativeExpr "%" UnaryExpr 
				;

MultiplicativeExprNoBF:    UnaryExprNoBF
  				|	MultiplicativeExprNoBF "*" UnaryExpr
                     	|	MultiplicativeExprNoBF "/" UnaryExpr
  				|	MultiplicativeExprNoBF "%" UnaryExpr
				;

AdditiveExpr		:    MultiplicativeExpr
  				|	AdditiveExpr "+" MultiplicativeExpr
  				| 	AdditiveExpr "-" MultiplicativeExpr
				;

AdditiveExprNoBF	:	MultiplicativeExprNoBF
  				|	AdditiveExprNoBF "+" MultiplicativeExpr
  				| 	AdditiveExprNoBF "-" MultiplicativeExpr
				;

ShiftExpr			:	AdditiveExpr
  				|	ShiftExpr "<<"	AdditiveExpr    
  				|	ShiftExpr ">>"	AdditiveExpr    
  				|	ShiftExpr ">>>"	AdditiveExpr   
				;

ShiftExprNoBF		:    AdditiveExprNoBF
  				|	ShiftExprNoBF "<<" AdditiveExpr
  				|	ShiftExprNoBF ">>" AdditiveExpr
  				|	ShiftExprNoBF ">>>" AdditiveExpr
				;

RelationalExpr		:    ShiftExpr
  				|	RelationalExpr "<" ShiftExpr      
  				|	RelationalExpr ">" ShiftExpr      
  				|	RelationalExpr "<=" ShiftExpr       
  				|	RelationalExpr ">=" ShiftExpr       
	 			|	RelationalExpr "instanceof" ShiftExpr 
				|	RelationalExpr "in"	ShiftExpr    
				;

RelationalExprNoIn	:    ShiftExpr
  				|	RelationalExprNoIn "<" ShiftExpr    
  				|	RelationalExprNoIn ">" ShiftExpr    
  				|	RelationalExprNoIn "<=" ShiftExpr     
  				|	RelationalExprNoIn ">=" ShiftExpr     
  				|	RelationalExprNoIn "instanceof" ShiftExpr
				;

RelationalExprNoBF	:    ShiftExprNoBF
  				|	RelationalExprNoBF "<" ShiftExpr   
  				|	RelationalExprNoBF ">" ShiftExpr   
  				|	RelationalExprNoBF "<=" ShiftExpr    
  				|	RelationalExprNoBF ">=" ShiftExpr    
  				|	RelationalExprNoBF "instanceof" ShiftExpr
	 			|	RelationalExprNoBF "in" ShiftExpr 
				;

EqualityExpr		:	RelationalExpr
  				|	EqualityExpr "==" RelationalExpr  
  				|	EqualityExpr "!=" RelationalExpr    
  				|	EqualityExpr "===" RelationalExpr 
  				|	EqualityExpr "!==" RelationalExpr
				;

EqualityExprNoIn	:	RelationalExprNoIn
  				|	EqualityExprNoIn "==" RelationalExprNoIn
  				|	EqualityExprNoIn "!=" RelationalExprNoIn
				|	EqualityExprNoIn "===" RelationalExprNoIn
       			|	EqualityExprNoIn "!==" RelationalExprNoIn
				;

EqualityExprNoBF	:    RelationalExprNoBF
  				|	EqualityExprNoBF "==" RelationalExpr
  				| 	EqualityExprNoBF "!=" RelationalExpr  
  				|	EqualityExprNoBF "===" RelationalExpr
  				|	EqualityExprNoBF "!==" RelationalExpr
				;

BitwiseANDExpr		:	EqualityExpr
  				| 	BitwiseANDExpr "&" EqualityExpr     
				;

BitwiseANDExprNoIn:
    EqualityExprNoIn
  | BitwiseANDExprNoIn "&" EqualityExprNoIn
;

BitwiseANDExprNoBF:
    EqualityExprNoBF
  | BitwiseANDExprNoBF "&" EqualityExpr 
;

BitwiseXORExpr:
    BitwiseANDExpr
  | BitwiseXORExpr "^" BitwiseANDExpr   
;

BitwiseXORExprNoIn:
    BitwiseANDExprNoIn
  | BitwiseXORExprNoIn "^" BitwiseANDExprNoIn
                                        
;

BitwiseXORExprNoBF:
    BitwiseANDExprNoBF
  | BitwiseXORExprNoBF "^" BitwiseANDExpr
                                        
;

BitwiseORExpr:
    BitwiseXORExpr
  | BitwiseORExpr "|" BitwiseXORExpr    
;

BitwiseORExprNoIn:
    BitwiseXORExprNoIn
  | BitwiseORExprNoIn "|" BitwiseXORExprNoIn
                                        
;

BitwiseORExprNoBF:
    BitwiseXORExprNoBF
  | BitwiseORExprNoBF "|" BitwiseXORExpr
                                        
;

LogicalANDExpr:
    BitwiseORExpr
  | LogicalANDExpr "&&" BitwiseORExpr    
;

LogicalANDExprNoIn:
    BitwiseORExprNoIn
  | LogicalANDExprNoIn "&&" BitwiseORExprNoIn
                                        
;

LogicalANDExprNoBF:
    BitwiseORExprNoBF
  | LogicalANDExprNoBF "&&" BitwiseORExpr
                                        
;

LogicalORExpr:
    LogicalANDExpr
  | LogicalORExpr "||" LogicalANDExpr     
;

LogicalORExprNoIn:
    LogicalANDExprNoIn
  | LogicalORExprNoIn "||" LogicalANDExprNoIn
                                        
;

LogicalORExprNoBF:
    LogicalANDExprNoBF
  | LogicalORExprNoBF "||" LogicalANDExpr 
;

ConditionalExpr:
    LogicalORExpr
  | LogicalORExpr "?" AssignmentExpr ":" AssignmentExpr
                                        
;

ConditionalExprNoIn:
    LogicalORExprNoIn
  | LogicalORExprNoIn "?" AssignmentExprNoIn ":" AssignmentExprNoIn
                                        
;

ConditionalExprNoBF:
    LogicalORExprNoBF
  | LogicalORExprNoBF "?" AssignmentExpr ":" AssignmentExpr
                                        
;

AssignmentExpr:
    ConditionalExpr
  | LeftHandSideExpr AssignmentOperator AssignmentExpr
                                        
;

AssignmentExprNoIn	:	ConditionalExprNoIn
  				|	LeftHandSideExpr AssignmentOperator AssignmentExprNoIn
				;


AssignmentExprNoBF:
    ConditionalExprNoBF
  | LeftHandSideExprNoBF AssignmentOperator AssignmentExpr
	;

AssignmentOperator	:    "="                                
  				|	"+="                          
  				|	"-="
  				|	"*="
  				|	"/="
  				|	"<<="
  				|	">>="
  				| ">>>="
  				| "&="
  				| "^="
  				| "|="
  				| "%="
;

Expr:
    AssignmentExpr
  | Expr "," AssignmentExpr            
;

ExprNoIn:
    AssignmentExprNoIn
  | ExprNoIn "," AssignmentExprNoIn    
;

ExprNoBF:
    AssignmentExprNoBF
  | ExprNoBF "," AssignmentExpr        
;

Statement:
    Block
  | VariableStatement
  | ConstStatement
  | FunctionDeclaration
  | EmptyStatement
  | ExprStatement
  | IfStatement
  | IterationStatement
  | ContinueStatement
  | BreakStatement
  | ReturnStatement
  | WithStatement
  | SwitchStatement
  | LabelledStatement
  | ThrowStatement
  | TryStatement
  | DebuggerStatement
;

Block:
    "{" "}"               
  | "{" SourceElements "}"
;

VariableStatement:
    "var" VariableDeclarationList ";"    
  | "var" VariableDeclarationList error  
;

VariableDeclarationList:
    IDENTIFIER                               
  | IDENTIFIER Initializer                   
  | VariableDeclarationList "," IDENTIFIER
                                        
  | VariableDeclarationList "," IDENTIFIER Initializer
                                        
;

VariableDeclarationListNoIn:
    IDENTIFIER                               
  | IDENTIFIER InitializerNoIn               
  | VariableDeclarationListNoIn "," IDENTIFIER
                                        
  | VariableDeclarationListNoIn "," IDENTIFIER InitializerNoIn
                                        
;

ConstStatement	:    "const" ConstDeclarationList ";" 
  			|	"const" ConstDeclarationList error
			;


ConstDeclarationList	:	ConstDeclaration                    
  				|	ConstDeclarationList "," ConstDeclaration
				;

ConstDeclaration:
    IDENTIFIER                               
  | IDENTIFIER Initializer                   
;

Initializer:
    "=" AssignmentExpr                  
;

InitializerNoIn:
    "=" AssignmentExprNoIn              
;

EmptyStatement:
    ";"                                 
;

ExprStatement:
    ExprNoBF ";"                        
  | ExprNoBF error                      
;

IfStatement	:	"if" "(" Expr ")" Statement %prec IF_WITHOUT_ELSE
  			|	"if" "(" Expr ")" Statement "else" Statement
			;

IterationStatement:
    "do" Statement "while" "(" Expr ")" ";"    
  | "do" Statement "while" "(" Expr ")" error   // Always performs automatic semicolon insertion.
  | "while" "(" Expr ")" Statement        
  | "for" "(" ExprNoInOpt ";" ExprOpt ";" ExprOpt ")" Statement
                                        
  | "for" "(" "var" VariableDeclarationListNoIn ";" ExprOpt ";" ExprOpt ")" Statement
                                        
  | "for" "(" LeftHandSideExpr "in" Expr ")" Statement
                                        
  | "for" "(" "var" IDENTIFIER "in" Expr ")" Statement
                                        
  | "for" "(" "var" IDENTIFIER InitializerNoIn "in" Expr ")" Statement
                                        
;

ExprOpt	:	.
  		|	Expr
		;

ExprNoInOpt	:	.
  			|	ExprNoIn
			;

ContinueStatement:
    "continue" ";"                        
  | "continue" error                      
  | "continue" IDENTIFIER ";"                  
  | "continue" IDENTIFIER error                
;

BreakStatement:
    "break" ";"                           
  | "break" error                         
  | "break" IDENTIFIER ";"                     
  | "break" IDENTIFIER error                   
;

ReturnStatement:
    "return" ";"                          
  | "return" error                        
  | "return" Expr ";"                     
  | "return" Expr error                   
;

WithStatement:
    "with" "(" Expr ")" Statement         
;

SwitchStatement:
    "switch" "(" Expr ")" CaseBlock       
;

CaseBlock:
    "{" CaseClausesOpt "}"              
  | "{" CaseClausesOpt DefaultClause CaseClausesOpt "}"
                                        
;

CaseClausesOpt	:	.                         
  			|	CaseClauses
			;


CaseClauses:
    CaseClause                          
  | CaseClauses CaseClause              
;

CaseClause:
    "case" Expr ":"                       
  | "case" Expr ":" SourceElements        
;

DefaultClause:
    "default" ":"                         
  | "default" ":" SourceElements          
;

LabelledStatement:
    IDENTIFIER ":" Statement                 
;

ThrowStatement:
    "throw" Expr ";"                      
  | "throw" Expr error                    
;

TryStatement:
    "try" Block "finally" Block             
  | "try" Block "catch" "(" IDENTIFIER ")" Block 
  | "try" Block "catch" "(" IDENTIFIER ")" Block "finally" Block
                                        
;

DebuggerStatement:
    "debugger" ";"                        
  | "debugger" error                      
;

FunctionDeclaration:
    "function" IDENTIFIER "(" ")" "{" FunctionBody "}" 
  | "function" IDENTIFIER "(" FormalParameterList ")" "{" FunctionBody "}"
      
;

FunctionExpr:
    "function" "(" ")" "{" FunctionBody "}" 
    | "function" "(" FormalParameterList ")" "{" FunctionBody "}"
      
  | "function" IDENTIFIER "(" ")" "{" FunctionBody "}" 
  | "function" IDENTIFIER "(" FormalParameterList ")" "{" FunctionBody "}"
      
;

FormalParameterList:
    IDENTIFIER                               
  | FormalParameterList "," IDENTIFIER       
;

FunctionBody	:	.
  			|	SourceElements_NoNode               
			;

Program		:	.
    			|	SourceElements                    
			;

SourceElements:
    Statement                           
  | SourceElements Statement            
;
 


// Start NoNodes

Literal_NoNode	:    "null"
		  	|	"true"
  			|	"false"
			|	NUMBER
  			|	STRING_LITERAL 
			;

Property_NoNode	:    IDENTIFIER ":" AssignmentExpr_NoNode 
  			|	STRING_LITERAL ":" AssignmentExpr_NoNode 
  			|	NUMBER ":" AssignmentExpr_NoNode 
  			|	IDENTIFIER IDENTIFIER "(" ")" "{" FunctionBody_NoNode "}" 
  			|	IDENTIFIER IDENTIFIER "(" FormalParameterList_NoNode ")" "{" FunctionBody_NoNode "}" 
;

PropertyList_NoNode:
    Property_NoNode
  | PropertyList_NoNode "," Property_NoNode
;

PrimaryExpr_NoNode:
    PrimaryExprNoBrace_NoNode
  | "{" "}" 
  | "{" PropertyList_NoNode "}" 
  | "{" PropertyList_NoNode "," "}" 
;

PrimaryExprNoBrace_NoNode:
    "this"
  | Literal_NoNode
  | ArrayLiteral_NoNode
  | IDENTIFIER 
  | "(" Expr_NoNode ")"
;

ArrayLiteral_NoNode:
    "[" ElisionOpt_NoNode "]"
  | "[" ElementList_NoNode "]"
  | "[" ElementList_NoNode "," ElisionOpt_NoNode "]"
;

ElementList_NoNode:
    ElisionOpt_NoNode AssignmentExpr_NoNode
  | ElementList_NoNode "," ElisionOpt_NoNode AssignmentExpr_NoNode
;

ElisionOpt_NoNode	:	.
  				|	Elision_NoNode
				;

Elision_NoNode:
    ","
  | Elision_NoNode ","
;

MemberExpr_NoNode:
    PrimaryExpr_NoNode
  | FunctionExpr_NoNode
  | MemberExpr_NoNode "[" Expr_NoNode "]"
  | MemberExpr_NoNode "." IDENTIFIER
  | "new" MemberExpr_NoNode Arguments_NoNode
;

MemberExprNoBF_NoNode:
    PrimaryExprNoBrace_NoNode
  | MemberExprNoBF_NoNode "[" Expr_NoNode "]"
  | MemberExprNoBF_NoNode "." IDENTIFIER
  | "new" MemberExpr_NoNode Arguments_NoNode
;

NewExpr_NoNode:
    MemberExpr_NoNode
  | "new" NewExpr_NoNode
;

NewExprNoBF_NoNode:
    MemberExprNoBF_NoNode
  | "new" NewExpr_NoNode
;

CallExpr_NoNode:
    MemberExpr_NoNode Arguments_NoNode
  | CallExpr_NoNode Arguments_NoNode
  | CallExpr_NoNode "[" Expr_NoNode "]"
  | CallExpr_NoNode "." IDENTIFIER
;

CallExprNoBF_NoNode:
    MemberExprNoBF_NoNode Arguments_NoNode
  | CallExprNoBF_NoNode Arguments_NoNode
  | CallExprNoBF_NoNode "[" Expr_NoNode "]"
  | CallExprNoBF_NoNode "." IDENTIFIER
;

Arguments_NoNode:
    "(" ")"
  | "(" ArgumentList_NoNode ")"
;

ArgumentList_NoNode:
    AssignmentExpr_NoNode
  | ArgumentList_NoNode "," AssignmentExpr_NoNode
;

LeftHandSideExpr_NoNode:
    NewExpr_NoNode
  | CallExpr_NoNode
;

LeftHandSideExprNoBF_NoNode:
    NewExprNoBF_NoNode
  | CallExprNoBF_NoNode
;

PostfixExpr_NoNode:
    LeftHandSideExpr_NoNode
  | LeftHandSideExpr_NoNode "++"
  | LeftHandSideExpr_NoNode "--"
;

PostfixExprNoBF_NoNode:
    LeftHandSideExprNoBF_NoNode
  | LeftHandSideExprNoBF_NoNode "++"
  | LeftHandSideExprNoBF_NoNode "--"
;

UnaryExprCommon_NoNode:
    "delete" UnaryExpr_NoNode
  | "void" UnaryExpr_NoNode
  | "typeof" UnaryExpr_NoNode
  | "++" UnaryExpr_NoNode
  | "--" UnaryExpr_NoNode
  | "+" UnaryExpr_NoNode
  | "-" UnaryExpr_NoNode
  | "~" UnaryExpr_NoNode
  | "!" UnaryExpr_NoNode
;

UnaryExpr_NoNode:
    PostfixExpr_NoNode
  | UnaryExprCommon_NoNode
;

UnaryExprNoBF_NoNode:
    PostfixExprNoBF_NoNode
  | UnaryExprCommon_NoNode
;

MultiplicativeExpr_NoNode:
    UnaryExpr_NoNode
  | MultiplicativeExpr_NoNode "*" UnaryExpr_NoNode
  | MultiplicativeExpr_NoNode "/" UnaryExpr_NoNode
  | MultiplicativeExpr_NoNode "%" UnaryExpr_NoNode
;

MultiplicativeExprNoBF_NoNode:
    UnaryExprNoBF_NoNode
  | MultiplicativeExprNoBF_NoNode "*" UnaryExpr_NoNode
  | MultiplicativeExprNoBF_NoNode "/" UnaryExpr_NoNode
  | MultiplicativeExprNoBF_NoNode "%" UnaryExpr_NoNode
;

AdditiveExpr_NoNode:
    MultiplicativeExpr_NoNode
  | AdditiveExpr_NoNode "+" MultiplicativeExpr_NoNode
  | AdditiveExpr_NoNode "-" MultiplicativeExpr_NoNode
;

AdditiveExprNoBF_NoNode:
    MultiplicativeExprNoBF_NoNode
  | AdditiveExprNoBF_NoNode "+" MultiplicativeExpr_NoNode
  | AdditiveExprNoBF_NoNode "-" MultiplicativeExpr_NoNode
;

ShiftExpr_NoNode:
    AdditiveExpr_NoNode
  | ShiftExpr_NoNode "<<" AdditiveExpr_NoNode
  | ShiftExpr_NoNode ">>" AdditiveExpr_NoNode
  | ShiftExpr_NoNode ">>>" AdditiveExpr_NoNode
;

ShiftExprNoBF_NoNode:
    AdditiveExprNoBF_NoNode
  | ShiftExprNoBF_NoNode "<<"	AdditiveExpr_NoNode
  | ShiftExprNoBF_NoNode ">>" AdditiveExpr_NoNode
  | ShiftExprNoBF_NoNode ">>>" AdditiveExpr_NoNode
;

RelationalExpr_NoNode:
    ShiftExpr_NoNode
  | RelationalExpr_NoNode "<" ShiftExpr_NoNode
  | RelationalExpr_NoNode ">" ShiftExpr_NoNode
  | RelationalExpr_NoNode "<=" ShiftExpr_NoNode
  | RelationalExpr_NoNode ">=" ShiftExpr_NoNode
  | RelationalExpr_NoNode "instanceof" ShiftExpr_NoNode
  | RelationalExpr_NoNode "in" ShiftExpr_NoNode
;

RelationalExprNoIn_NoNode:
    ShiftExpr_NoNode
  | RelationalExprNoIn_NoNode "<" ShiftExpr_NoNode
  | RelationalExprNoIn_NoNode ">" ShiftExpr_NoNode
  | RelationalExprNoIn_NoNode "<=" ShiftExpr_NoNode
  | RelationalExprNoIn_NoNode ">=" ShiftExpr_NoNode
  | RelationalExprNoIn_NoNode "instanceof" ShiftExpr_NoNode
;

RelationalExprNoBF_NoNode:
    ShiftExprNoBF_NoNode
  | RelationalExprNoBF_NoNode "<" ShiftExpr_NoNode
  | RelationalExprNoBF_NoNode ">" ShiftExpr_NoNode
  | RelationalExprNoBF_NoNode "<=" ShiftExpr_NoNode
  | RelationalExprNoBF_NoNode ">=" ShiftExpr_NoNode
  | RelationalExprNoBF_NoNode "instanceof" ShiftExpr_NoNode
  | RelationalExprNoBF_NoNode "in" ShiftExpr_NoNode
;

EqualityExpr_NoNode:
    RelationalExpr_NoNode
  | EqualityExpr_NoNode "==" RelationalExpr_NoNode
  | EqualityExpr_NoNode "!=" RelationalExpr_NoNode
  | EqualityExpr_NoNode "===" RelationalExpr_NoNode
  | EqualityExpr_NoNode "!==" RelationalExpr_NoNode
;

EqualityExprNoIn_NoNode:
    RelationalExprNoIn_NoNode
  | EqualityExprNoIn_NoNode "==" RelationalExprNoIn_NoNode
  | EqualityExprNoIn_NoNode "!=" RelationalExprNoIn_NoNode
  | EqualityExprNoIn_NoNode "===" RelationalExprNoIn_NoNode
  | EqualityExprNoIn_NoNode "!==" RelationalExprNoIn_NoNode
;

EqualityExprNoBF_NoNode:
    RelationalExprNoBF_NoNode
  | EqualityExprNoBF_NoNode "==" RelationalExpr_NoNode
  | EqualityExprNoBF_NoNode "!=" RelationalExpr_NoNode
  | EqualityExprNoBF_NoNode "===" RelationalExpr_NoNode
  | EqualityExprNoBF_NoNode "!==" RelationalExpr_NoNode
;

BitwiseANDExpr_NoNode:
    EqualityExpr_NoNode
  | BitwiseANDExpr_NoNode "&" EqualityExpr_NoNode
;

BitwiseANDExprNoIn_NoNode:
    EqualityExprNoIn_NoNode
  | BitwiseANDExprNoIn_NoNode "&" EqualityExprNoIn_NoNode
;

BitwiseANDExprNoBF_NoNode:
    EqualityExprNoBF_NoNode
  | BitwiseANDExprNoBF_NoNode "&" EqualityExpr_NoNode
;

BitwiseXORExpr_NoNode:
    BitwiseANDExpr_NoNode
  | BitwiseXORExpr_NoNode "^" BitwiseANDExpr_NoNode
;

BitwiseXORExprNoIn_NoNode:
    BitwiseANDExprNoIn_NoNode
  | BitwiseXORExprNoIn_NoNode "^" BitwiseANDExprNoIn_NoNode
;

BitwiseXORExprNoBF_NoNode:
    BitwiseANDExprNoBF_NoNode
  | BitwiseXORExprNoBF_NoNode "^" BitwiseANDExpr_NoNode
;

BitwiseORExpr_NoNode:
    BitwiseXORExpr_NoNode
  | BitwiseORExpr_NoNode "|" BitwiseXORExpr_NoNode
;

BitwiseORExprNoIn_NoNode:
    BitwiseXORExprNoIn_NoNode
  | BitwiseORExprNoIn_NoNode "|" BitwiseXORExprNoIn_NoNode
;

BitwiseORExprNoBF_NoNode:
    BitwiseXORExprNoBF_NoNode
  | BitwiseORExprNoBF_NoNode "|" BitwiseXORExpr_NoNode
;

LogicalANDExpr_NoNode:
    BitwiseORExpr_NoNode
  | LogicalANDExpr_NoNode "&&" BitwiseORExpr_NoNode
;

LogicalANDExprNoIn_NoNode:
    BitwiseORExprNoIn_NoNode
  | LogicalANDExprNoIn_NoNode "&&" BitwiseORExprNoIn_NoNode
;

LogicalANDExprNoBF_NoNode:
    BitwiseORExprNoBF_NoNode
  | LogicalANDExprNoBF_NoNode "&&" BitwiseORExpr_NoNode
;

LogicalORExpr_NoNode:
    LogicalANDExpr_NoNode
  | LogicalORExpr_NoNode "||" LogicalANDExpr_NoNode
;

LogicalORExprNoIn_NoNode:
    LogicalANDExprNoIn_NoNode
  | LogicalORExprNoIn_NoNode "||" LogicalANDExprNoIn_NoNode
;

LogicalORExprNoBF_NoNode:
    LogicalANDExprNoBF_NoNode
  | LogicalORExprNoBF_NoNode "||" LogicalANDExpr_NoNode
;

ConditionalExpr_NoNode:
    LogicalORExpr_NoNode
  | LogicalORExpr_NoNode "?" AssignmentExpr_NoNode ":" AssignmentExpr_NoNode
;

ConditionalExprNoIn_NoNode:
    LogicalORExprNoIn_NoNode
  | LogicalORExprNoIn_NoNode "?" AssignmentExprNoIn_NoNode ":" AssignmentExprNoIn_NoNode
;

ConditionalExprNoBF_NoNode:
    LogicalORExprNoBF_NoNode
  | LogicalORExprNoBF_NoNode "?" AssignmentExpr_NoNode ":" AssignmentExpr_NoNode
;

AssignmentExpr_NoNode:
    ConditionalExpr_NoNode
  | LeftHandSideExpr_NoNode AssignmentOperator_NoNode AssignmentExpr_NoNode
;

AssignmentExprNoIn_NoNode:
    ConditionalExprNoIn_NoNode
  | LeftHandSideExpr_NoNode AssignmentOperator_NoNode AssignmentExprNoIn_NoNode
;

AssignmentExprNoBF_NoNode:
    ConditionalExprNoBF_NoNode
  | LeftHandSideExprNoBF_NoNode AssignmentOperator_NoNode AssignmentExpr_NoNode
;

AssignmentOperator_NoNode	:	"="                                
  					|	"+="                          
  					|	"-="
  					|	"*="
  					|	"/="
  					|	"<<="
  					|	">>="
  					|	">>>="
  					|	"&="
  					|	"^="
  					|	"|="
  					|	"%="
					;

Expr_NoNode:
    AssignmentExpr_NoNode
  | Expr_NoNode "," AssignmentExpr_NoNode
;

ExprNoIn_NoNode:
    AssignmentExprNoIn_NoNode
  | ExprNoIn_NoNode "," AssignmentExprNoIn_NoNode
;

ExprNoBF_NoNode:
    AssignmentExprNoBF_NoNode
  | ExprNoBF_NoNode "," AssignmentExpr_NoNode
;

Statement_NoNode:
    Block_NoNode
  | VariableStatement_NoNode
  | ConstStatement_NoNode
  | FunctionDeclaration_NoNode
  | EmptyStatement_NoNode
  | ExprStatement_NoNode
  | IfStatement_NoNode
  | IterationStatement_NoNode
  | ContinueStatement_NoNode
  | BreakStatement_NoNode
  | ReturnStatement_NoNode
  | WithStatement_NoNode
  | SwitchStatement_NoNode
  | LabelledStatement_NoNode
  | ThrowStatement_NoNode
  | TryStatement_NoNode
  | DebuggerStatement_NoNode
;

Block_NoNode:
    "{" "}" 
  | "{" SourceElements_NoNode "}" 
;

VariableStatement_NoNode:
    "var" VariableDeclarationList_NoNode ";"
  | "var" VariableDeclarationList_NoNode error 
;

VariableDeclarationList_NoNode:
    IDENTIFIER 
  | IDENTIFIER Initializer_NoNode 
  | VariableDeclarationList_NoNode "," IDENTIFIER
  | VariableDeclarationList_NoNode "," IDENTIFIER Initializer_NoNode
;

VariableDeclarationListNoIn_NoNode:
    IDENTIFIER 
  | IDENTIFIER InitializerNoIn_NoNode 
  | VariableDeclarationListNoIn_NoNode "," IDENTIFIER
  | VariableDeclarationListNoIn_NoNode "," IDENTIFIER InitializerNoIn_NoNode
;

ConstStatement_NoNode:
    "const" ConstDeclarationList_NoNode ";"
  | "const" ConstDeclarationList_NoNode error 
;

ConstDeclarationList_NoNode:
    ConstDeclaration_NoNode
  | ConstDeclarationList_NoNode "," ConstDeclaration_NoNode
;

ConstDeclaration_NoNode:
    IDENTIFIER 
  | IDENTIFIER Initializer_NoNode 
;

Initializer_NoNode:
    "=" AssignmentExpr_NoNode
;

InitializerNoIn_NoNode:
    "=" AssignmentExprNoIn_NoNode
;

EmptyStatement_NoNode:
    ";"
;

ExprStatement_NoNode:
    ExprNoBF_NoNode ";"
  | ExprNoBF_NoNode error 
;

IfStatement_NoNode:
    "if" "(" Expr_NoNode ")" Statement_NoNode %prec IF_WITHOUT_ELSE
  | "if" "(" Expr_NoNode ")" Statement_NoNode "else" Statement_NoNode
;

IterationStatement_NoNode:
    "do" Statement_NoNode "while" "(" Expr_NoNode ")" ";"
  | "do" Statement_NoNode "while" "(" Expr_NoNode ")" error // Always performs automatic semicolon insertion
  | "while" "(" Expr_NoNode ")" Statement_NoNode
  | "for" "(" ExprNoInOpt_NoNode ";" ExprOpt_NoNode ";" ExprOpt_NoNode ")" Statement_NoNode
  | "for" "(" "var" VariableDeclarationListNoIn_NoNode ";" ExprOpt_NoNode ";" ExprOpt_NoNode ")" Statement_NoNode
  | "for" "(" LeftHandSideExpr_NoNode "in" Expr_NoNode ")" Statement_NoNode
  | "for" "(" "var" IDENTIFIER "in" Expr_NoNode ")" Statement_NoNode
  | "for" "(" "var" IDENTIFIER InitializerNoIn_NoNode "in" Expr_NoNode ")" Statement_NoNode
;

ExprOpt_NoNode	:	.
  			|	Expr_NoNode
			;

ExprNoInOpt_NoNode	:	.
  				|	ExprNoIn_NoNode
				;

ContinueStatement_NoNode:
    "continue" ";"
  | "continue" error 
  | "continue" IDENTIFIER ";"
  | "continue" IDENTIFIER error 
;

BreakStatement_NoNode:
    "break" ";"
  | "break" error 
  | "break" IDENTIFIER ";"
  | "break" IDENTIFIER error 
;

ReturnStatement_NoNode:
    "return" ";"
  | "return" error 
  | "return" Expr_NoNode ";"
  | "return" Expr_NoNode error 
;

WithStatement_NoNode:
    "with" "(" Expr_NoNode ")" Statement_NoNode
;

SwitchStatement_NoNode:
    "switch" "(" Expr_NoNode ")" CaseBlock_NoNode
;

CaseBlock_NoNode:
    "{" CaseClausesOpt_NoNode "}" 
  | "{" CaseClausesOpt_NoNode DefaultClause_NoNode CaseClausesOpt_NoNode "}" 
;

CaseClausesOpt_NoNode	:	.
	 				|	CaseClauses_NoNode
					;


CaseClauses_NoNode:
    CaseClause_NoNode
  | CaseClauses_NoNode CaseClause_NoNode
;

CaseClause_NoNode:
    "case" Expr_NoNode ":"
  | "case" Expr_NoNode ":" SourceElements_NoNode
;

DefaultClause_NoNode:
    "default" ":"
  | "default" ":" SourceElements_NoNode
;

LabelledStatement_NoNode:
    IDENTIFIER ":" Statement_NoNode 
;

ThrowStatement_NoNode:
    "throw" Expr_NoNode ";"
  | "throw" Expr_NoNode error 
;

TryStatement_NoNode:
    "try" Block_NoNode "finally" Block_NoNode
  | "try" Block_NoNode "catch" "(" IDENTIFIER ")" Block_NoNode
  | "try" Block_NoNode "catch" "(" IDENTIFIER ")" Block_NoNode "finally" Block_NoNode
;

DebuggerStatement_NoNode:
    "debugger" ";"
  | "debugger" error 
;



FunctionDeclaration_NoNode:
    "function" IDENTIFIER "(" ")" "{" FunctionBody_NoNode "}"
  | "function" IDENTIFIER "(" FormalParameterList_NoNode ")" "{" FunctionBody_NoNode "}"
;

FunctionExpr_NoNode	:    "function" "(" ")" "{" FunctionBody_NoNode "}"
  			|	"function" "(" FormalParameterList_NoNode ")" "{" FunctionBody_NoNode "}"
			|	"function" IDENTIFIER "(" ")" "{" FunctionBody_NoNode "}"
			|	"function" IDENTIFIER "(" FormalParameterList_NoNode ")" "{" FunctionBody_NoNode "}"
			;

FormalParameterList_NoNode:
    IDENTIFIER 
  | FormalParameterList_NoNode "," IDENTIFIER
;

FunctionBody_NoNode	:	.
  				|	SourceElements_NoNode
				;



SourceElements_NoNode	:    	Statement_NoNode
				|	SourceElements_NoNode Statement_NoNode
				;






%code {:
/*
 * The Arsenal Library
 * Copyright (c) 2009 by Solidus
 * 
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.It is provided "as is" without express 
 * or implied warranty.
 *
 */
:}
;



/******************************************PreDefined code********************************************/
%code syntax_node {:

:}
;





%code syntax_tree_handler {:

    static void        AR_STDCALL on_free_node(psrNode_t *node, void *ctx)
    {
		AR_ASSERT(node != NULL && ctx != NULL);
		
        
    }

    static arStatus_t        AR_STDCALL on_error(const psrToken_t *tok, const size_t expected[], size_t count, void *ctx)
    {
/*
            tguParser_t    *parser;
            size_t        i;
            arString_t    *str;
            wchar_t        *tok_str;
            AR_ASSERT(tok != NULL && ctx != NULL);

            parser = (tguParser_t*)ctx;
            str = AR_CreateString();

            if(tok->term_val == 0)
            {
                    tok_str = AR_wcsdup(L"EOI");
            }else
            {
                    tok_str = AR_wcsndup(tok->str, tok->str_cnt);
            }
        
            AR_AppendFormatString(str, L"Invalid token : '%ls', expected ", tok_str);
            
            for(i = 0; i < count; ++i)
            {
                    AR_AppendFormatString(str, L"'%ls'", TGU_TokenValToString(expected[i]));
            }
            
            TGU_ReportError(&parser->report, AR_GetStringCString(str), tok->line);
        
            AR_DestroyString(str);
            str = NULL;
            AR_DEL(tok_str);
            tok_str = NULL;
*/
            return AR_S_YES;
    }
    
    static const psrHandler_t    __g_handler = {on_error, on_free_node};
:}
;






%name    delim             :     "[\x{000A}\x{000B}\x{000C}\x{000D}\x{0085}\x{2028}\x{2029}\x{0020}\f\n\r\t\v\x{0009}\x{0020}\x{00A0}\x{1680}\x{180E}\x{2000}-\x{200A}\x{202F}\x{205F}\x{3000}]"
                        ;

%name    comment        :    "/\*([^\*]|\*+[^\*/])*\*+/"    
                       ;

%name    comment_line        :    "(//[^\x{000A}\x{000B}\x{000C}\x{000D}\x{0085}\x{2028}\x{2029}]*(\x{000A}|\x{000B}|\x{000C}|\x{000D}|\x{0085}|\x{2028}|\x{2029}|$))"
                          ;

%name skip_lexem        :     "{delim}|{comment_line}|{comment}"
                ;


%name    digit                :    "[0-9]"                
                        ;

%name    number                :    "{digit}+"                
                        ;


/*
\x{4E00}-\x{9FA5}     (中文)
\x{3130}-\x{318F}     (韩文)
\x{AC00}-\x{D7A3}    (韩文)
\x{0800}-\x{4E00}    (日文)
*/

//ASCII + 中日韩

%name    letter         :    "[A-Z_a-z\x{0800}-\x{4E00}\x{4E00}-\x{9FA5}\x{3130}-\x{318F}\x{AC00}-\x{D7AF}]"
                        ;



%name hex_digit         :    "[0-9a-fA-F]"
                        ;


%name hex_literal       :    "0(x|X){hex_digit}+"
                        ;

%name oct_literal       :    "0[0-7]+"
                        ;

%name dec_literal       :    "(0|[1-9][0-9]*)"
                        ;




%name    exponet            :    "(e|E)(\+|\-)?[0-9]+"
                            ;

%name float_literal         :    "(((([0-9]\.[0-9]*)){exponet}?)|([0-9]+{exponet}))"
                            ;




/*  '"'  == \x22,  '\'' == \x27 */

%name    escape_seq        :    "(\\(\x22|\x27))"    
                ;

%name    string_dq        :     "(\x22({escape_seq}|[^\x22])*\x22)"        //只能提取"..."或"\""此类串，其它词法规则要到语义例程中处理    
                ;

%name    string_sq        :    "\x27({escape_seq}|[^\x27])*\x27"        //提取'...'或'\''此类串，其它词法规则要到语义例程中处理    
                ;



%name    keyword_lhd           :    "{letter}|[0-9]"                        ;


%name        float_constant    :    "{float_literal}(?!{keyword_lhd})"
                    ;
%name        hex_constant        :    "{hex_literal}(?!{keyword_lhd})"
                    ;
%name        oct_constant        :    "{oct_literal}(?!{keyword_lhd})"
                    ;
%name        dec_constant        :    "{dec_literal}(?!{keyword_lhd})"
                    ;


%token     %skip            :    "{skip_lexem}"                ,1                %value    "TOK_DELIM_ID"             ;            //空白，需要过滤



%code token_operation{:
    
   
:}
;



%token        NAME     :    "{letter}({letter}|{digit})*"                    %value    "TOK_NAME"            %action default_leaf_handler        
	                ;


%token        STRING        :    "{string_dq}|{string_sq}"                        %value    "TOK_STRING"            %action on_string_leaf_handler        
		              ;


%token        FLOAT_NUMBER    :    "{float_constant}"                        ,2    %value    "TOK_FLOAT_NUMBER"        %action default_leaf_handler        ;
%token        INT_NUMBER    :    "{hex_constant}|{oct_constant}|{dec_constant}"        ,2    %value    "TOK_INT_NUMBER"        %action default_leaf_handler        ;




%token    "import"    :    '"import"(?!{keyword_lhd})'   ,1            %value    "TOK_IMPORT"            %action default_leaf_handler            ;
%token    "from"    	  :    '"from"(?!{keyword_lhd})'   ,1            %value    "TOK_FROM"            %action default_leaf_handler            ;

%token    "for"        :    '"for"(?!{keyword_lhd})'        ,1            %value    "TOK_FOR"            %action default_leaf_handler            ;
%token    "do"        :    '"do"(?!{keyword_lhd})'        ,1            %value    "TOK_DO"            %action default_leaf_handler            ;
%token    "while"    :    '"while"(?!{keyword_lhd})'        ,1            %value    "TOK_WHILE"            %action default_leaf_handler            ;
%token    "if"        :    '"if"(?!{keyword_lhd})'        ,1            %value    "TOK_IF"            %action default_leaf_handler            ;
%token    "else"        :    '"else"(?!{keyword_lhd})'        ,1            %value    "TOK_ELSE"            %action default_leaf_handler            ;

%token    "continue"    :    '"continue"(?!{keyword_lhd})'    ,1            %value    "TOK_CONTINUE"        %action default_leaf_handler            ;
%token    "break"    :    '"break"(?!{keyword_lhd})'        ,1            %value    "TOK_BREAK"            %action default_leaf_handler            ;
%token    "return"    :    '"return"(?!{keyword_lhd})'        ,1            %value    "TOK_RETURN"            %action default_leaf_handler            ;

%token    "null"        :    '"null"(?!{keyword_lhd})'        ,1            %value    "TOK_NULL"            %action default_leaf_handler            ;
%token    "true"        :    '"true"(?!{keyword_lhd})'        ,1            %value    "TOK_TRUE"            %action default_leaf_handler            ;
%token    "false"    :    '"false"(?!{keyword_lhd})'        ,1            %value    "TOK_FALSE"            %action default_leaf_handler            ;
%token    "var"        :    '"var"(?!{keyword_lhd})'        ,1            %value    "TOK_VAR"            %action default_leaf_handler            ;

%token    "in"        :    '"in"(?!{keyword_lhd})'        ,1            %value    "TOK_IN"            %action default_leaf_handler            ;

/*
%token    "list"    		:    '"list"(?!{keyword_lhd})'        ,1            %value    "TOK_LIST"            %action default_leaf_handler            ;
%token    "table"  		:    '"table"(?!{keyword_lhd})'        ,1            %value   "TOK_TABLE"            %action default_leaf_handler           ;
*/

%token    "try"    		:    '"try"(?!{keyword_lhd})'   ,1            	%value    	"TOK_TRY"        	%action default_leaf_handler            	;
%token    "catch"  		:    '"catch"(?!{keyword_lhd})'   ,1            %value    	"TOK_CATCH"        	%action default_leaf_handler        	;
%token    "finally"  	:    '"finally"(?!{keyword_lhd})'   ,1          %value    	"TOK_FINALLY"       	%action default_leaf_handler        	;
%token    "throw"  		:    '"throw"(?!{keyword_lhd})'   ,1          	%value    	"TOK_THROW"         	%action default_leaf_handler        	;




%token    "..."        :    '"..."'    ,2                        %value    "TOK_ELLIPSIS"        %action default_leaf_handler            ;    


%token    "++"        :    '"++"'        ,1                        %value    "TOK_INC"            %action default_leaf_handler            ;
%token    "--"        :    '"--"'        ,1                        %value    "TOK_DEC"            %action default_leaf_handler            ;


%token    "&&"        :    '"&&"'        ,1                        %value    "TOK_ANDAND"            %action default_leaf_handler            ;
%token    "||"        :    '"||"'        ,1                        %value    "TOK_OROR"            %action default_leaf_handler            ;






%token    "<="       :    '"<="'        ,1                        %value    "TOK_LE"            %action default_leaf_handler            ;
%token    ">="       :    '">="'        ,1                        %value    "TOK_GE"            %action default_leaf_handler            ;
%token    "=="       :    '"=="'        ,1                        %value    "TOK_EQ"            %action default_leaf_handler            ;
%token    "!="       :    '"!="'        ,1                        %value    "TOK_NE"            %action default_leaf_handler            ;
%token    "<"        :    '"<"'         ,0                    %value    "TOK_LESS"            %action default_leaf_handler           ;
%token    ">"        :    '">"'         ,0                    %value    "TOK_GREATER"            %action default_leaf_handler        ;




%token    "{"        :    '"{"'            ,0                    %value    "TOK_L_BRACES"        %action default_leaf_handler            ;
%token    "}"        :    '"}"'            ,0                    %value    "TOK_R_BRACES"        %action default_leaf_handler            ;
%token    "("        :    '"("'            ,0                    %value    "TOK_L_PAREN"            %action default_leaf_handler            ;
%token    ")"        :    '")"'            ,0                    %value    "TOK_R_PAREN"            %action default_leaf_handler            ;
%token    "["        :    '"["'            ,0                    %value    "TOK_L_SQUARE"        %action default_leaf_handler            ;
%token    "]"        :    '"]"'            ,0                    %value    "TOK_R_SQUARE"        %action default_leaf_handler            ;

%token    ";"        :    '";"'            ,0                    %value    "TOK_SEMICOLON"        %action default_leaf_handler            ;
%token    ","        :    '","'            ,0                    %value    "TOK_COMMA"            %action default_leaf_handler            ;
%token    "="        :    '"="'            ,0                    %value    "TOK_ASSIGN"            %action default_leaf_handler            ;



%token    "+"        :    '"+"'            ,0                    %value    "TOK_ADD"            %action default_leaf_handler            ;
%token    "-"        :    '"-"'            ,0                    %value    "TOK_SUB"            %action default_leaf_handler            ;
%token    "*"        :    '"*"'            ,0                    %value    "TOK_MUL"            %action default_leaf_handler            ;
%token    "/"        :    '"/"'            ,0                    %value    "TOK_DIV"            %action default_leaf_handler            ;
%token    "%"        :    '"%"'            ,0                    %value    "TOK_MOD"            %action default_leaf_handler            ;

%token    "!"        :    '"!"'            ,0                    %value    "TOK_NOT"            %action default_leaf_handler            ;


%token    ":"        :    '":"'            ,0                    %value    "TOK_COLON"            %action default_leaf_handler            ;
%token    "?"        :    '"?"'            ,0                    %value    "TOK_QUEST"            %action default_leaf_handler            ;


%token    "."        :    '"."'            ,0                    %value    "TOK_DOT"            %action default_leaf_handler            ;





/**************************************************优先级*****************************************************/

%right       "?"    ":"                          			;
%left        "||"                                			;
%left        "&&"                                			;
%left        "=="    "!="    "<"    "<="    ">"    ">="            	;
%left        "+"    "-"                          			;
%left        "*"    "/"    "%"                   			;




/*
"if" "(" expression ")" statement "else" statement 
产生式的优先级依赖于其最右终结符或显性指定,这里就是"else"
*/
%nonassoc IF_WITHOUT_ELSE                        ;
%nonassoc "else"                            ;






/**********************************************产生式****************************************/


%start    module	;


module		  :    element_list             %action    on_module
                |    .                        %action    on_module
	         ;



element_list	:	element                	%action    auto_return_null
		|	element_list    element  	%action    auto_return_null
              ;


element	:	declaration            	%action    auto_return_null
		|	function_defination        %action    auto_return_null
		|	statement
		;






/**************************************function_defination***********************************************/


%code    handle_function    {:
    
:}
;


function_signature		:    	"var"        NAME "(" params ")"                        %action    on_function_signature
				;


function_defination        :    function_signature    compound_statement    %action    on_function_defination
                           ;



params          :    namelist    ","    "..."        %action on_namelist_ellipsis
                |    namelist        		     %action    auto_return_0
                |    "..."            		     %action    on_ellipsis
                |    .            			     %action    NULL
                ;



namelist        :    namelist    "," NAME        %action    on_name_list
                |    NAME				 %action    on_name
                ;






/*************************************声明语句***************************************************/


declaration         :    "var"        init_declarator_list     semi       %action    auto_return_null
                    |    "var"        error                ";"            %action    auto_return_null
                    ;



init_declarator_list            :    init_declarator                        	      %action    auto_return_null
                    		     |    init_declarator_list "," init_declarator            %action    auto_return_null
                                ;



%code    handle_init_declarator{:
    
:};




init_declarator	:    	NAME    "="     expression                %action    	on_declarator
			|   	NAME	"=" 	aggregate_constructor	%action	on_declarator
                    	|    	NAME                            		%action    on_declarator
                    ;



aggregate_constructor	:	list_constructor 
				|	table_constructor
				;



list_constructor    		:   "["    list_field_list     optional_dot    "]"		%action on_list_contructor
                    		|   "["    "]"							%action on_list_contructor
                    		|   "["    error "]"							%action on_list_contructor
                    		;




list_field_list            	:    	list_field_list  "," list_field
				|	list_field
                    		;

list_field			:	expression
				|	aggregate_constructor
				;


table_constructor		:     "{"    table_field_list optional_dot    "}"        	%action    on_table_constructor
				|     "{"    "}"                					%action    on_table_constructor
				|     "{" error "}"                				%action    on_table_constructor
                    		;


table_field_list		:    table_field_list ","        table_field
				|    table_field
				;


table_field                	:	expression    ":"    expression
				|	expression	":"	aggregate_constructor
                    	      	;



optional_dot        		:    ","
                    		|    .
                    		;


/*************************************语句***************************************************/


statement		:    	compound_statement            %action    auto_return_0
			|    	expression_statement            %action    auto_return_0
			|    	selection_statement            %action    auto_return_0
			|    	iteration_statement            %action    auto_return_0
			|    	jump_statement            %action    auto_return_0
			|    	empty_statement            %action    auto_return_0
			|	import_statement 		%action auto_return_0
			|	throw_statement		%action auto_return_0
			|	try_statement			%action auto_return_0
                    ;




/**************************************************Exception statement*************************************************/

throw_statement	:	"throw" expression semi
			;

try_statement		:	"try"	compound_statement        "finally"	compound_statement
			|	"try" 	compound_statement        "catch"	"("	NAME ")"	compound_statement
			|	"try" 	compound_statement        "catch"	"("	NAME ")"	compound_statement	"finally" 	compound_statement
			;





/**************************************compound_statement*****************************/


%code {:
    
:};



compound_statement        :    start_block    compound_element_list        "}"        %action    on_compound_statement
	                    |    start_block                        "}"        %action    on_empty_compound_statement
		             |    start_block      error                  "}"        %action    on_compound_error_statement
                           ;



start_block            :    "{"        %action    on_start_block
	                ;








compound_element_list        :    compound_element_list        compound_element   
                    		  |    compound_element                        		
                    ;
















compound_element        :    statement        %action    on_compound_element
		          |    declaration        %action    auto_return_null
                	   ;













/**************************************statement*****************************/

%code {:
          

:};


import_statement	:	"import"	NAME ";"				%action on_import_statement
			|	"import"	NAME "from" STRING	";"		%action on_import_statement
			|	"import"	error ";"				%action on_import_statement
			;







%code {:
          

:};


empty_statement            :    ";"        %action    on_empty_statement
                           ;



expression_statement            :    expression     semi        %action on_expression_statement
		                  |    error    ";"            %action auto_return_null
              		     ;





selection_statement            :    if_statement        %action auto_return_0
		                 |    if_else_statement    %action auto_return_0
		                 ;





%code    {:
:};


if_statement    :    "if" "(" expression ")" statement            %prec IF_WITHOUT_ELSE        %action on_if_statement
                |    "if" "(" error ")" statement            %prec IF_WITHOUT_ELSE        %action on_if_statement
                ;


if_else_statement        :    "if" "(" expression ")" statement "else" statement    %action on_if_else_statement
                	    |    "if" "(" error ")" statement "else" statement        %action on_if_else_statement
		           ;




iteration_statement        :    while_statement            %action    auto_return_0
		             |    do_while_statement            %action    auto_return_0
                	      |    for_statement                %action    auto_return_0
		             ;






%code {:
 
:}
;






while_statement     :    "while" enter_loop  "(" expression ")" statement leave_loop    %action    on_while_statement
                    |    "while" enter_loop  "(" error ")" statement leave_loop        %action    on_while_statement
                    ;





do_while_statement           :    "do" enter_loop statement "while" "(" expression ")" leave_loop     semi            %action    on_do_while_statement
                    		  |    "do" enter_loop statement "while" "(" error ")" leave_loop         semi            %action    on_do_while_statement
		                ;	




for_statement            :    "for"    "("    for_in_expression    ")"     enter_loop  statement leave_loop    %action    on_for_statement
		           |    "for"    "("    error    ")"    enter_loop  statement leave_loop    %action    on_error_for_statement
                         ;

for_in_expression        :    NAME "in" expression    
                	    ;



enter_loop                :    .                    %action on_enter_loop
		            ;






leave_loop                :    .                    %action on_leave_loop
	                   ;






%code{:
    
:}
;


jump_statement       :    "continue"     semi                %action on_continue_statement
                    |    "break"     semi                %action on_break_statement
                    |    "return"     semi                %action on_return_statement
                    |    "return"     expression semi        %action on_return_statement
                    ;




semi                :    ";"                                %action    auto_return_0
                    |    error                                %action    on_semi_error
                    ;


/*****************************************表达式*********************************************/


expression          :    assignment_expression        %action auto_return_0
                    ;



%code {:
:}
;



assignment_expression	:    constant_expression                        %action     auto_return_0
				|    unary_expression    "="    assignment_expression    %action    on_assignment_expression
				;




%code {:

:}
;







constant_expression            :    binary_expression                                    %action     auto_return_0
                   		    |    binary_expression    "?"    expression    ":"        expression        %action    on_condition_expression
		                  ;





%code {:
:}
;

binary_expression   :    unary_expression                        %action     auto_return_0
	             |    binary_expression    "+"    binary_expression        %action    on_binary_expression
                    |    binary_expression    "-"    binary_expression        %action    on_binary_expression
                    |    binary_expression    "*"    binary_expression        %action    on_binary_expression
                    |    binary_expression    "/"    binary_expression        %action    on_binary_expression
                    |    binary_expression    "%"    binary_expression        %action    on_binary_expression
                    |    binary_expression    "<"    binary_expression        %action    on_binary_expression
                    |    binary_expression    "<="    binary_expression        %action    on_binary_expression
                    |    binary_expression    ">"    binary_expression        %action    on_binary_expression
                    |    binary_expression    ">="    binary_expression        %action    on_binary_expression
                    |    binary_expression    "=="    binary_expression        %action    on_binary_expression
                    |    binary_expression    "!="    binary_expression        %action    on_binary_expression
                    |    binary_expression    "&&"    binary_expression        %action    on_binary_expression
                    |    binary_expression    "||"    binary_expression        %action    on_binary_expression
                    ;


%code {:

:}
;


%code handle_constant {:
   
:}
;

%code handle_identifier{:
    


:}
;



unary_expression       :    "+"    unary_expression    %action    on_unary_expression
               	  |    "-"    unary_expression    %action    on_unary_expression
                       |    "!"    unary_expression    %action    on_unary_expression
       	         |    "++"     unary_expression    %action    on_unary_expression
	                |    "--"    unary_expression    %action    on_unary_expression
	                |    postfix_expression        %action     auto_return_0
       	         ;



postfix_expression        	:    postfix_expression    "++"        %action    on_post_add_minus_expression
                		|    postfix_expression    "--"        %action    on_post_add_minus_expression
               		|    postfix_expression "[" expression "]"        %action    on_index_expression
		              |    postfix_expression "[" error "]"            %action    on_index_expression
	                     |    postfix_expression     "."    NAME    %action    on_access_name_expression
	                     |    call_expression                %action auto_return_0
             			|    primary_expression                %action auto_return_0
		              ;    
                




primary_expression        	:    	"(" expression")"                            %action    on_lp_rp_expression
                	     	|    	"(" error ")"                                %action    on_lp_rp_expression
		            	|    	NAME                                        %action    on_identifier_expression
				|	constant            				%action    auto_return_0
		            	;



/**************************************import_expression***********************************************/

constant        :    FLOAT_NUMBER        %action    on_constant
                |    INT_NUMBER          %action    on_constant
                |    STRING              %action    on_constant
                |    "true"              %action    on_constant
                |    "false"            	%action    on_constant
                |    "null"              %action    on_constant
                ;





/*辅助函数*/
%code {:

:}
;



call_expression        :    postfix_expression "(" call_param_list ")"        	%action    on_call_expression
                |    postfix_expression "(" error ")"                		%action    on_call_expression
                |    postfix_expression "("     ")"                			%action    on_call_expression
                ;






/*
expression_list        :    expression                    %action    auto_return_0
                	  |    expression_list "," expression        %action    on_expression_list
                       ;
*/


call_param_list	:	call_param
			|	call_param_list "," call_param
			;


call_param		:	expression
			|	aggregate_constructor
			;











%token	'(' 	:	'"none"'
			;

%token 	')' 	:	'"none"'
			;


%token	'*' 	:	'"none"'
			;
%token	'+' 	:	'"none"'
			;

%token	',' 	:	'"none"'
			;


%token	'-'  	:	'"none"'
		;




%token	'.'  	:	'"none"'
			;
 


%token	'/'   	:	'"none"'
			;
%token	';'  	:	'"none"'
			;
%token	'['  	:	'"none"'
			;
%token	']'  	:	'"none"'
			;
 
%token	NAME  	:	'"none"'
			;
%token	STRING 	:	'"none"'
			; 
%token	WSTRING 	:	'"none"'
			;
%token	INTNUM  	:	'"none"'
			;
%token	APPROXNUM  	:	'"none"'
			;
%token	NUM_ERROR  	:	'"none"'
			;
%token	AMMSC 	:	'"none"'
			;
%token	PARAMETER_L  	:	'"none"'
			;
%token	NAMED_PARAMETER  	:	'"none"'
			;
%token	BEGIN_EQCALL_X  	:	'"none"'
			;
%token	HTMLSTR  	:	'"none"'
			;
%token	SQL_TSI  	:	'"none"'
			;
%token	TIMESTAMP_FUNC  	:	'"none"'
			;
%token	BINARYNUM  	:	'"none"'
			;
%token	MSSQL_XMLCOL_NAME  	:	'"none"'
			;
%token	MSSQL_XMLCOL_NAME1  	:	'"none"'
			;
%token	MSSQL_XMLCOL_NAMEYZ  	:	'"none"'
			;
%token	MSSQL_XMLCOL_NAMEZ  	:	'"none"'
			;
%token	MSSQL_XMLCOL_INTNUM  	:	'"none"'
			;
%token	TYPE  	:	'"none"'
			;
%token	FINAL_L  	:	'"none"'
			;
%token	METHOD  	:	'"none"'
			;
%token	CHECKED  	:	'"none"'
			;
%token	SYSTEM  	:	'"none"'
			;
%token	GENERATED  	:	'"none"'
			;
%token	SOURCE  	:	'"none"'
			;
%token	RESULT  	:	'"none"'
			;
%token	LOCATOR  	:	'"none"'
			;
%token	INSTANCE_L  	:	'"none"'
			;
%token	CONSTRUCTOR  	:	'"none"'
			;
%token	SELF_L   	:	'"none"'
			;
%token	OVERRIDING  	:	'"none"'
			;
%token	STYLE 	:	'"none"'
			; 
%token	SQL_L 	:	'"none"'
			; 
%token	GENERAL  	:	'"none"'
			;
%token	DETERMINISTIC  	:	'"none"'
			;
%token	NO  	:	'"none"'
			;
%token	CONTAINS  	:	'"none"'
			;
%token	READS 	:	'"none"'
			; 
%token	DATA  	:	'"none"'
			;
%token	MODIFIES  	:	'"none"'
			;
%token	INPUT  	:	'"none"'
			;
%token	CALLED  	:	'"none"'
			;
%token	ADA  	:	'"none"'
			;
%token	C  	:	'"none"'
			;
%token	COBOL 	:	'"none"'
			; 
%token	FORTRAN  	:	'"none"'
			;
%token	MUMPS  	:	'"none"'
			;
%token	PASCAL_L  	:	'"none"'
			;
%token	PLI  	:	'"none"'
			;
%token	NAME_L  	:	'"none"'
			;
%token	TEXT_L  	:	'"none"'
			;
%token	JAVA  	:	'"none"'
			;
%token	INOUT_L  	:	'"none"'
			;
%token	REMOTE  	:	'"none"'
			;
%token	KEYSET  	:	'"none"'
			;
%token	VALUE  	:	'"none"'
			;
%token	PARAMETER  :	'"none"'
			;
%token	VARIABLE  	:	'"none"'
			;
%token	ADMIN_L  	:	'"none"'
			;
%token	ROLE_L  	:	'"none"'
			;
%token	TEMPORARY  :	'"none"'
			;
%token	CLR :	'"none"'
			;
%token	ATTRIBUTE :	'"none"'
			;
%token	__SOAP_DOC :	'"none"'
			;
%token	__SOAP_DOCW :	'"none"'
			;
%token	__SOAP_HEADER :	'"none"'
			;
%token	__SOAP_HTTP :	'"none"'
			;
%token	__SOAP_NAME :	'"none"'
			;
%token	__SOAP_TYPE :	'"none"'
			;
%token	__SOAP_XML_TYPE :	'"none"'
			;
%token	__SOAP_FAULT :	'"none"'
			;
%token	__SOAP_DIME_ENC :	'"none"'
			;
%token	__SOAP_ENC_MIME :	'"none"'
			;
%token	__SOAP_OPTIONS :	'"none"'
			;
%token	FOREACH :	'"none"'
			;
%token	ARE :	'"none"'
			;
%token	REF :	'"none"'
			;
%token	STATIC_L :	'"none"'
			;
%token	SPECIFIC :	'"none"'
			;
%token	DYNAMIC :	'"none"'
			;
%token	COLUMN :	'"none"'
			;
%token	START_L :	'"none"'
			;
%token	AS :	'"none"'
			;
    
    
%token	DOUBLE_COLON :	'"none"'
			;
%token	COLON :	'"none"'
			;
%token	OR :	'"none"'
			;
%token	AND :	'"none"'
			;
%token	NOT :	'"none"'
			;
%token	COMPARISON :	'"none"'
			;
%token	EQUALS :	'"none"'
			;
%token	STRING_CONCAT_OPERATOR :	'"none"'
			;
%token	UMINUS :	'"none"'
			;
%token	ALL :	'"none"'
			;
%token	ANY :	'"none"'
			;
%token	ATTACH :	'"none"'
			;
%token	ASC :	'"none"'
			;
%token	AUTHORIZATION :	'"none"'
			;
%token	BETWEEN :	'"none"'
			;
%token	BY :	'"none"'
			;
%token	CASCADE :	'"none"'
			;
%token	CHARACTER :	'"none"'
			;
%token	CHECK :	'"none"'
			;
%token	CLOSE:	'"none"'
			; 
%token	COMMIT :	'"none"'
			;
%token	CONSTRAINT :	'"none"'
			;
%token	CONTINUE :	'"none"'
			;
%token	CREATE :	'"none"'
			;
%token	CUBE :	'"none"'
			;
%token	CURRENT :	'"none"'
			;
%token	CURSOR :	'"none"'
			;
%token	DECIMAL :	'"none"'
			;
%token	DECLARE :	'"none"'
			;
%token	DEFAULT :	'"none"'
			;
%token	DELETE_L :	'"none"'
			;
%token	DESC :	'"none"'
			;
%token	DISTINCT :	'"none"'
			;
%token	DOUBLE :	'"none"'
			;
%token	DROP :	'"none"'
			;
    
%token	ESCAPE :	'"none"'
			;
%token	EXISTS :	'"none"'
			;
%token	FETCH :	'"none"'
			;
%token	FLOAT :	'"none"'
			;
%token	FOR :	'"none"'
			;
%token	FOREIGN :	'"none"'
			;
%token	FOUND :	'"none"'
			;
%token	FROM :	'"none"'
			;
    
%token	GOTO :	'"none"'
			;
%token	GO :	'"none"'
			;
%token	GRANT :	'"none"'
			;
%token	GROUP :	'"none"'
			;
%token	GROUPING :	'"none"'
			;
%token	HAVING :	'"none"'
			;
%token	IN_L :	'"none"'
			;
%token	INDEX :	'"none"'
			;
%token	INDICATOR :	'"none"'
			;
%token	INSERT :	'"none"'
			;
%token	INTEGER :	'"none"'
			;
%token	INTO :	'"none"'
			;
%token	IS :	'"none"'
			;
%token	KEY :	'"none"'
			;
%token	LANGUAGE :	'"none"'
			;
%token	ENCODING :	'"none"'
			;
%token	LIKE :	'"none"'
			;
%token	NULLX :	'"none"'
			;
%token	NUMERIC :	'"none"'
			;
%token	OF :	'"none"'
			;
%token	ON :	'"none"'
			;
%token	OPEN :	'"none"'
			;
%token	OPTION :	'"none"'
			;
%token	ORDER :	'"none"'
			;
%token	PRECISION :	'"none"'
			;
%token	PRIMARY :	'"none"'
			;
%token	PRIVILEGES :	'"none"'
			;
%token	PROCEDURE :	'"none"'
			;
%token	PUBLIC :	'"none"'
			;
%token	REAL :	'"none"'
			;
%token	REFERENCES :	'"none"'
			;
%token	RESTRICT :	'"none"'
			;
%token	ROLLBACK :	'"none"'
			;
%token	ROLLUP :	'"none"'
			;
%token	SCHEMA :	'"none"'
			;
%token	SELECT :	'"none"'
			;
%token	SET :	'"none"'
			;
%token	SMALLINT :	'"none"'
			;
%token	SOME :	'"none"'
			;
%token	SQLCODE :	'"none"'
			;
%token	SQLERROR :	'"none"'
			;
%token	TABLE :	'"none"'
			;
%token	TO :	'"none"'
			;
%token	UNION :	'"none"'
			;
%token	UNIQUE :	'"none"'
			;
%token	UPDATE :	'"none"'
			;
%token	USER :	'"none"'
			;
%token	VALUES :	'"none"'
			;
%token	VIEW :	'"none"'
			;
%token	WHENEVER :	'"none"'
			;
%token	WHERE :	'"none"'
			;
%token	WITH :	'"none"'
			;
    
%token	WORK :	'"none"'
			;
%token	ARRAY :	'"none"'
			;
%token	CONTIGUOUS :	'"none"'
			;
%token	OBJECT_ID :	'"none"'
			;
%token	UNDER :	'"none"'
			;
%token	CLUSTERED :	'"none"'
			;
%token	VARCHAR :	'"none"'
			;
%token	VARBINARY :	'"none"'
			;
%token	BINARY :	'"none"'
			;
%token	LONG :	'"none"'
			;
%token	REPLACING :	'"none"'
			;
%token	SOFT :	'"none"'
			;
%token	HASH :	'"none"'
			;
%token	LOOP :	'"none"'
			;
%token	SHUTDOWN :	'"none"'
			;
%token	CHECKPOINT :	'"none"'
			;
%token	BACKUP :	'"none"'
			;
%token	REPLICATION :	'"none"'
			;
%token	SYNC :	'"none"'
			;
%token	ALTER:	'"none"'
			; 
%token	ADD :	'"none"'
			;
%token	RENAME :	'"none"'
			;
%token	DISCONNECT :	'"none"'
			;
%token	MODIFY :	'"none"'
			;
%token	BEFORE :	'"none"'
			;
%token	AFTER :	'"none"'
			;
%token	INSTEAD :	'"none"'
			;
%token	TRIGGER :	'"none"'
			;
%token	REFERENCING :	'"none"'
			;
%token	OLD :	'"none"'
			;
%token	AGGREGATE :	'"none"'
			;
%token	FUNCTION :	'"none"'
			;
%token	OUT_L:	'"none"'
			; 
%token	HANDLER :	'"none"'
			;
%token	IF :	'"none"'
			;
%token	THEN :	'"none"'
			;
%token	ELSE :	'"none"'
			;
%token	ELSEIF :	'"none"'
			;
%token	WHILE :	'"none"'
			;
%token	BEGINX :	'"none"'
			;
%token	ENDX :	'"none"'
			;
    
%token	RETURN :	'"none"'
			;
%token	CALL :	'"none"'
			;
%token	RETURNS :	'"none"'
			;
%token	DO :	'"none"'
			;
%token	EXCLUSIVE :	'"none"'
			;
%token	PREFETCH :	'"none"'
			;
%token	SQLSTATE :	'"none"'
			;
%token	SQLWARNING :	'"none"'
			;
%token	SQLEXCEPTION :	'"none"'
			;
%token	EXIT :	'"none"'
			;
%token	RESIGNAL :	'"none"'
			;
%token	REVOKE :	'"none"'
			;
%token	PASSWORD :	'"none"'
			;
%token	OFF :	'"none"'
			;
%token	LOGX :	'"none"'
			;
%token	TIMESTAMP :	'"none"'
			;
%token	DATE :	'"none"'
			;
%token	DATETIME :	'"none"'
			;
%token	TIME :	'"none"'
			;
%token	EXECUTE :	'"none"'
			;
%token	REXECUTE :	'"none"'
			;
%token	MODULE :	'"none"'
			;
%token	BEGIN_FN_X :	'"none"'
			;
%token	BEGIN_CALL_X :	'"none"'
			;
%token	BEGIN_OJ_X :	'"none"'
			;
%token	BEGIN_U_X :	'"none"'
			;
%token	CONVERT :	'"none"'
			;
%token	CASE :	'"none"'
			;
%token	WHEN :	'"none"'
			;
%token	IDENTITY :	'"none"'
			;
%token	LEFT :	'"none"'
			;
%token	RIGHT:	'"none"'
			; 
%token	FULL :	'"none"'
			;
%token	OUTER:	'"none"'
			; 
%token	INNER:	'"none"'
			; 
%token	CROSS:	'"none"'
			; 
%token	NATURAL :	'"none"'
			;
%token	USING :	'"none"'
			;
%token	JOIN :	'"none"'
			;
%token	USE :	'"none"'
			;
%token	COALESCE :	'"none"'
			;
%token	CAST :	'"none"'
			;
%token	NULLIF :	'"none"'
			;
%token	NEW :	'"none"'
			;
%token	CORRESPONDING :	'"none"'
			;
%token	EXCEPT :	'"none"'
			;
%token	INTERSECT :	'"none"'
			;
%token	BEST :	'"none"'
			;
%token	TOP :	'"none"'
			;
%token	PERCENT :	'"none"'
			;
%token	TIES :	'"none"'
			;
%token	XML :	'"none"'
			;
%token	XPATH:	'"none"'
			; 
%token	PERSISTENT :	'"none"'
			;
%token	INTERVAL :	'"none"'
			;
%token	INCREMENT_L :	'"none"'
			;
%token	DTD :	'"none"'
			;
%token	INTERNAL :	'"none"'
			;
%token	EXTERNAL :	'"none"'
			;
%token	COLLATE :	'"none"'
			;
%token	NCHAR :	'"none"'
			;
%token	NVARCHAR :	'"none"'
			;
%token	INCREMENTAL :	'"none"'
			;
%token	NONINCREMENTAL :	'"none"'
			;
%token	PURGE :	'"none"'
			;
%token	SNAPSHOT :	'"none"'
			;
%token	IDENTIFIED :	'"none"'
			;
%token	EXTRACT :	'"none"'
			;
%token	KWD_TAG :	'"none"'
			;
%token	LEXICAL_ERROR :	'"none"'
			;
%token	CURRENT_DATE :	'"none"'
			;
%token	CURRENT_TIME :	'"none"'
			;
%token	CURRENT_TIMESTAMP :	'"none"'
			;
%token	PERMISSION_SET :	'"none"'
			;
%token	AUTOREGISTER_L :	'"none"'
			;
%token	LIBRARY_L :	'"none"'
			;
%token	ASSEMBLY_L :	'"none"'
			;
%token	SAFE_L :	'"none"'
			;
%token	UNRESTRICTED :	'"none"'
			;




sql_list		: sql_list1 ';'
             	| sql_list1
			;

sql_list1		: sql
			;

     sql: schema_element_list
        | view_def
        | xml_view
        | create_xml_schema
        | alter_constraint
        | create_library
       | create_assembly
       | drop_library
       | drop_assembly
		;

    schema_element_list: schema_element
                       | add_column
                       | schema_element_list schema_element
                       | schema_element_list add_column
					;

 	schema_element: base_table_def
                  | create_index_def
                  | drop_table
                  | drop_index
                  | table_rename
                  | privilege_def
                  | privilege_revoke
                  | create_user_statement
                  | delete_user_statement
                  | set_pass
                  | set_group_stmt
                  | add_group_stmt
                  | delete_group_stmt
                  | user_defined_type
                  | user_defined_type_drop
                  | user_defined_type_alter
			;

	    identifier: NAME
              | TYPE
              | FINAL_L
              | METHOD
              | CHECKED
              | SYSTEM
              | GENERATED
              | SOURCE
              | RESULT
              | LOCATOR
              | INSTANCE_L
              | CONSTRUCTOR
              | SELF_L
              | OVERRIDING
              | STYLE
              | SQL_L
              | GENERAL
              | DETERMINISTIC
              | NO
              | CONTAINS
              | READS
              | DATA
              | MODIFIES
              | INPUT
              | CALLED
              | ADA
              | C
              | COBOL
              | FORTRAN
              | MUMPS
              | PASCAL_L
              | PLI
              | NAME_L
              | TEXT_L
              | JAVA
              | INOUT_L
              | REMOTE
              | KEYSET
              | VALUE
              | PARAMETER
              | VARIABLE
              | CLR
              | TEMPORARY
              | ADMIN_L
              | __SOAP_DOC
              | __SOAP_DOCW
              | __SOAP_HEADER
              | __SOAP_HTTP
              | __SOAP_NAME
              | __SOAP_TYPE
              | __SOAP_XML_TYPE
              | __SOAP_FAULT
              | __SOAP_DIME_ENC
              | __SOAP_ENC_MIME
              | __SOAP_OPTIONS
              | START_L
              | ATTRIBUTE
              | REXECUTE
              | PERMISSION_SET
              | AUTOREGISTER_L
              | LIBRARY_L
              | ASSEMBLY_L
              | SAFE_L
              | UNRESTRICTED
              | INCREMENT_L
              | FOREACH
		
			;


    base_table_def: CREATE TABLE new_table_name '(' base_table_element_commalist ')'
			;

   base_table_element_commalist: base_table_element
                               | base_table_element_commalist ',' base_table_element
						;

   base_table_element: column_def
                     | table_constraint_def
				;

   column_def: column column_data_type column_def_opt_list
		;
   opt_referential_triggered_action: .
                                   | referential_rule
                                   | referential_rule referential_rule
						;

   referential_rule: ON UPDATE referential_action
                   | delete_referential_rule
				;

   delete_referential_rule: ON DELETE_L referential_action
					;
   opt_on_delete_referential_rule: .
                                 | delete_referential_rule
						;
   referential_action: CASCADE
                     | SET NULLX
                     | SET DEFAULT
				;

   references: REFERENCES q_table_name opt_column_commalist opt_referential_triggered_action
		;

   column_def_opt_list: .
                      | column_def_opt_list column_def_opt
				;
   identity_opt: START_L WITH signed_literal
               | INCREMENT_L BY INTNUM
			;
   
	identity_opt_list: identity_opt
                    | identity_opt_list ',' identity_opt
				;
   column_def_opt: NOT NULLX
                 | NULLX
                 | IDENTITY
                 | IDENTITY '(' identity_opt_list ')'
                 | PRIMARY KEY
                 | DEFAULT signed_literal
                 | COLLATE q_table_name
                 | references
                 | IDENTIFIED BY column
                 | CHECK '(' search_condition ')'
                 | WITH SCHEMA column_xml_schema_def
                 | UNIQUE
			;

   column_xml_schema_def: '(' STRING ',' STRING ')'
                        | '(' STRING ',' STRING ',' STRING ')'
					;

   table_constraint_def: UNDER q_table_name
                       | opt_constraint_name PRIMARY KEY '(' index_column_commalist ')' opt_index_option_list
                       | opt_constraint_name FOREIGN KEY '(' column_commalist ')' references
                       | opt_constraint_name CHECK '(' search_condition ')'
                       | opt_constraint_name UNIQUE '(' column_commalist ')'
				;

   opt_constraint_name: .
                      | CONSTRAINT identifier
				;
   column_commalist: column
                   | column_commalist ',' column
				;

   index_column_commalist: column opt_asc_desc
                         | index_column_commalist ',' column opt_asc_desc
					;

   index_option: CLUSTERED
               | UNIQUE
               | OBJECT_ID
			;

   index_option_list: index_option
                    | index_option_list index_option
				;

   opt_index_option_list: .
                        | index_option_list
					;

   create_index_def: CREATE opt_index_option_list INDEX index ON new_table_name '(' index_column_commalist ')'
				;

   drop_index: DROP INDEX identifier opt_table
			;

   opt_table: .
            | q_table_name
			;

   drop_table: DROP TABLE q_table_name
             | DROP VIEW q_table_name
			;
   opt_col_add_column: .
                     | COLUMN
				;

   add_col_column_def_list: column_def
                          | add_col_column_def_list ',' column_def
					;

   add_col_column_list: column
                      | add_col_column_list ',' column
				;

   add_column: ALTER TABLE q_table_name ADD opt_col_add_column add_col_column_def_list
             | ALTER TABLE q_table_name DROP opt_col_add_column add_col_column_list
             | ALTER TABLE q_table_name MODIFY opt_col_add_column column_def
			;

   table_rename: ALTER TABLE q_table_name RENAME new_table_name
			;

   constraint_op: ADD
                | DROP
                | MODIFY
			;


   opt_drop_behavior: .
                    | CASCADE
                    | RESTRICT
				;

   opt_table_constraint_def: CONSTRAINT identifier opt_drop_behavior
                           | table_constraint_def
					;


   alter_constraint: ALTER TABLE q_table_name constraint_op opt_table_constraint_def
				;

   create_xml_schema: CREATE XML SCHEMA STRING
				;

   view_query_spec: query_exp
                  | query_no_from_spec
			;

   empty_1: .
	;

   view_def: CREATE VIEW new_table_name empty_1 opt_column_commalist AS view_query_spec opt_with_check_option
         | CREATE PROCEDURE VIEW new_table_name AS q_table_name '(' column_commalist_or_empty ')' '(' proc_col_list ')'
		;

 opt_with_check_option: .
                      | WITH CHECK OPTION
				;

 opt_column_commalist: .
                     | '(' column_commalist ')'
				;

 priv_opt_column_commalist: .
                          | '(' column_commalist ')'
					;

 privilege_def: GRANT ALL PRIVILEGES TO grantee
              | GRANT privileges ON table TO grantee_commalist opt_with_grant_option
              | GRANT EXECUTE ON function_name TO grantee_commalist opt_with_grant_option
              | GRANT REXECUTE ON STRING TO grantee_commalist
              | GRANT UNDER ON q_old_type_name TO grantee_commalist opt_with_grant_option
              | GRANT grantee_commalist TO grantee_commalist opt_with_admin_option
			;


 opt_with_admin_option: .
                      | WITH ADMIN_L OPTION
				;

 privilege_revoke: REVOKE privileges ON table FROM grantee_commalist
                 | REVOKE EXECUTE ON function_name FROM grantee_commalist
                 | REVOKE UNDER ON q_old_type_name FROM grantee_commalist
                 | REVOKE REXECUTE ON STRING FROM grantee_commalist
                 | REVOKE grantee_commalist FROM grantee_commalist
			;

 opt_with_grant_option: .
                      | WITH GRANT OPTION
				;

 privileges: ALL PRIVILEGES
           | ALL
           | operation_commalist
		;

 operation_commalist: operation
                    | operation_commalist ',' operation
				;

 operation: SELECT priv_opt_column_commalist
          | INSERT
          | DELETE_L
          | UPDATE priv_opt_column_commalist
          | REFERENCES priv_opt_column_commalist
		;

 grantee_commalist: grantee
                  | grantee_commalist ',' grantee
				;


 grantee: PUBLIC
        | user
		;

 set_pass: SET PASSWORD identifier identifier
		;

 create_user_statement: CREATE USER user
                      | CREATE ROLE_L user
				;

 delete_user_statement: DELETE_L USER user
                      | DELETE_L USER user CASCADE
                      | DROP USER user
                      | DROP USER user CASCADE
                      | DROP ROLE_L user
				;

 set_group_stmt: SET USER GROUP user user
			;

 add_group_stmt: ADD USER GROUP user user
			;

 delete_group_stmt: DELETE_L USER GROUP user user
				;

 opt_attach_primary_key: .
                       | PRIMARY KEY '(' column_commalist ')'
					;

 attach_table: ATTACH TABLE attach_q_table_name opt_attach_primary_key opt_as FROM literal opt_login opt_not_select opt_remote_name
			;


 opt_as: .
       | AS new_table_name
		;

 opt_login:	. 
          | USER scalar_exp PASSWORD scalar_exp
		;

 opt_not_select: .
               | NOT SELECT
			;


 opt_remote_name: .
                | REMOTE AS scalar_exp
			;

 cursor_type: STATIC_L
            | DYNAMIC
            | KEYSET
		;

 cursor_def: DECLARE identifier CURSOR FOR query_exp
           | DECLARE identifier cursor_type CURSOR FOR query_exp
		;

 opt_order_by_clause: .
                    | ORDER BY ordering_spec_commalist
				;

 ordering_spec_commalist: ordering_spec
                        | ordering_spec_commalist ',' ordering_spec
					;

 ordering_spec: scalar_exp opt_asc_desc
              | mssql_xml_col opt_asc_desc
			;

 opt_asc_desc: .
             | ASC
             | DESC
		;
 create_snapshot_log: CREATE SNAPSHOT LOGX FOR q_table_name
				;

 drop_snapshot_log: DROP SNAPSHOT LOGX FOR q_table_name
				;

 purge_snapshot_log: PURGE SNAPSHOT LOGX FOR q_table_name
				;

 opt_snapshot_string_literal: .
                            | STRING
						;


 opt_snapshot_where_clause: .
                          | WHERE STRING
					;

 create_snapshot: CREATE SNAPSHOT q_table_name FROM q_table_name opt_snapshot_string_literal opt_snapshot_where_clause
                | CREATE NONINCREMENTAL SNAPSHOT q_table_name AS STRING
			;

 opt_with_delete: .
                | WITH DELETE_L
			;

 drop_snapshot: DROP SNAPSHOT q_table_name opt_with_delete
			;

 opt_nonincremental: .
                   | AS NONINCREMENTAL
			;

 refresh_snapshot: UPDATE SNAPSHOT q_table_name opt_nonincremental
			;

 create_freetext_index: CREATE TEXT_L opt_xml INDEX ON q_table_name '(' column ')' opt_with_key opt_deffer_generation opt_with opt_data_modification_action opt_lang opt_enc
				;

 opt_data_modification_action: .
                             | USING FUNCTION
					;

 opt_column:	.
           | '(' column ')'
		;

 create_freetext_trigger: CREATE TEXT_L TRIGGER ON q_table_name opt_column
					;

 drop_freetext_trigger: DROP TEXT_L TRIGGER ON q_table_name opt_column
				;

 opt_xml: .
        | XML
	;

 opt_with_key: .
             | WITH KEY column
		;

 opt_with: .
         | CLUSTERED WITH '(' column_commalist ')'
		;

 opt_lang: .
         | LANGUAGE STRING
		;

 opt_enc: .
        | ENCODING STRING
		;

 opt_deffer_generation: .
                      | NOT INSERT
				;


 manipulative_statement: query_exp
                       | query_no_from_spec
                       | update_statement_positioned
                       | update_statement_searched
                       | insert_statement
                       | delete_statement_positioned
                       | delete_statement_searched
                       | call_statement
                       | static_method_invocation
                       | METHOD CALL static_method_invocation
                       | top_level_method_invocation
                       | set_statement
                       | drop_xml_view
                       | commit_statement
                       | rollback_statement
                       | admin_statement
                       | use_statement
                       | attach_table
                       | create_snapshot_log
                       | drop_snapshot_log
                       | purge_snapshot_log
                       | create_snapshot
                       | drop_snapshot
                       | refresh_snapshot
                       | create_freetext_index
                       | create_freetext_trigger
                       | drop_freetext_trigger
				;

 use_statement: USE identifier
			;

 close_statement: CLOSE cursor
			;
	
 commit_statement: COMMIT WORK
			;

 delete_statement_positioned: DELETE_L FROM table WHERE CURRENT OF cursor
					;

 delete_statement_searched: DELETE_L FROM table opt_where_clause
					;

 fetch_statement: FETCH cursor INTO target_commalist
                | FETCH cursor NAME INTO target_commalist
                | FETCH cursor NAME scalar_exp INTO target_commalist
			;

 insert_mode: INTO
            | REPLACING
            | SOFT
		;

 insert_statement: INSERT insert_mode table priv_opt_column_commalist values_or_query_spec
			;

 values_or_query_spec: VALUES '(' insert_atom_commalist ')'
                     | query_spec
				;

 insert_atom_commalist: insert_atom
                      | insert_atom_commalist ',' insert_atom
				;

 insert_atom: scalar_exp
			;

 sql_option: ORDER
           | HASH
           | LOOP
           | INDEX identifier
           | INDEX PRIMARY KEY
           | INDEX TEXT_L KEY
           | NAME INTNUM
		;

 sql_opt_commalist: sql_option
                  | sql_opt_commalist ',' sql_option
			;
 opt_sql_opt: .
            | OPTION '(' sql_opt_commalist ')'
		;

 opt_table_opt: .
              | TABLE OPTION '(' sql_opt_commalist ')'
			;

 cursor_option: EXCLUSIVE
              | PREFETCH INTNUM
			;

 cursor_options_commalist: cursor_option
                         | cursor_options_commalist ',' cursor_option
					;

 opt_cursor_options_list: .
                        | '(' cursor_options_commalist ')'
					;

 open_statement: OPEN cursor opt_cursor_options_list
			;

 rollback_statement: ROLLBACK WORK
				;

 with_opt_cursor_options_list: .
                             | WITH opt_cursor_options_list
					;

 select_statement: SELECT opt_top selection INTO target_commalist table_exp with_opt_cursor_options_list
			;

 opt_all_distinct: .
                 | ALL
                 | DISTINCT
			;

 opt_ties: .
         | WITH TIES
		;

 opt_top: opt_all_distinct
        | opt_all_distinct TOP INTNUM opt_ties
        | opt_all_distinct TOP '(' scalar_exp ')' opt_ties
        | opt_all_distinct TOP INTNUM ',' INTNUM opt_ties
        | opt_all_distinct TOP '(' scalar_exp ',' scalar_exp ')' opt_ties
		;

 update_statement_positioned: UPDATE table SET assignment_commalist WHERE CURRENT OF cursor
					;

 assignment_commalist: .
                     | assignment
                     | assignment_commalist ',' assignment
				;

 assignment: column COMPARISON scalar_exp
		;

 update_statement_searched: UPDATE table SET assignment_commalist opt_where_clause
					;

 target_commalist: target
                 | target_commalist ',' target
			;

 target: column_ref
       | member_observer
       | lvalue_array_ref
		;

 opt_where_clause: .
                 | where_clause
			;

 opt_best: .
         | BEST
		;

 query_exp: query_term
          | non_final_union_exp opt_best UNION opt_corresponding query_term
          | non_final_union_exp opt_best UNION ALL opt_corresponding query_term
          | non_final_union_exp INTERSECT opt_corresponding query_term
          | non_final_union_exp INTERSECT ALL opt_corresponding query_term
          | non_final_union_exp EXCEPT opt_corresponding query_term
          | non_final_union_exp EXCEPT ALL opt_corresponding query_term
		;

 non_final_union_exp: non_final_query_term
                    | non_final_union_exp opt_best UNION opt_corresponding non_final_query_term
                    | non_final_union_exp opt_best UNION ALL opt_corresponding non_final_query_term
                    | non_final_union_exp INTERSECT opt_corresponding non_final_query_term
                    | non_final_union_exp INTERSECT ALL opt_corresponding non_final_query_term
                    | non_final_union_exp EXCEPT opt_corresponding non_final_query_term
                    | non_final_union_exp EXCEPT ALL opt_corresponding non_final_query_term
				;

 non_final_query_term: non_final_query_spec
                     | XPATH STRING
				;

 query_term: query_spec
           | '(' query_exp ')' opt_order_by_clause
           | XPATH STRING
		;

 opt_corresponding: .
                  | CORRESPONDING BY '(' column_commalist ')'
			;

 non_final_query_spec: SELECT opt_top selection non_final_table_exp
				;

 query_spec: SELECT opt_top selection table_exp
			;

 query_no_from_spec: SELECT opt_top selection
				;

 selection: select_scalar_exp_commalist
		;

 non_final_table_exp: from_clause opt_where_clause opt_group_by_clause opt_having_clause
				;

 table_exp: from_clause opt_where_clause opt_group_by_clause opt_having_clause opt_order_by_clause opt_lock_mode opt_sql_opt
		;

 from_clause: FROM table_ref_commalist
			;

 table_ref_commalist: table_ref
                    | table_ref_commalist ',' table_ref
				;


 proc_col_list: column_def
              | proc_col_list ',' column_def
			;

 opt_proc_col_list: '(' proc_col_list ')'
				;

 column_commalist_or_empty: .
                          | column_commalist
					;

 table_ref: table	
          | '(' query_exp ')' identifier
          | '(' query_exp ')' AS identifier
          | joined_table
          | q_table_name '(' column_commalist_or_empty ')' opt_proc_col_list identifier
		;

 table_ref_nj: table
             | subquery identifier
             | subquery AS identifier
             | '(' joined_table ')'
			;

 jtype: .
      | LEFT opt_outer
      | RIGHT opt_outer
      | FULL opt_outer
      | INNER
      | CROSS
	;



 opt_outer: .
          | OUTER
		;

 join: NATURAL jtype
     | jtype
	;

 joined_table: joined_table_1
             | BEGIN_OJ_X joined_table_1 ENDX
             | '(' joined_table_1 ')'
			;

 joined_table_1: table_ref join JOIN table_ref_nj join_condition
			;

 join_condition: .
               | ON search_condition
               | USING '(' column_commalist ')'
			;


 where_clause: WHERE search_condition
			;

 opt_group_by_clause: .
                    | GROUP BY ordering_spec_commalist
                    | GROUP BY ROLLUP '(' ordering_spec_commalist ')'
                    | GROUP BY CUBE '(' ordering_spec_commalist ')'
				;


 opt_having_clause: .
                  | HAVING search_condition
			;

 opt_lock_mode: .
              | FOR UPDATE
              | FOR XML NAME
              | FOR XML NAME NAME
			;

 search_condition: search_condition OR search_condition
                 | search_condition AND search_condition
                 | NOT search_condition
                 | '(' search_condition ')'
                 | predicate
			;

 predicate: comparison_predicate
          | between_predicate
          | like_predicate
          | test_for_null
          | in_predicate
          | all_or_any_predicate
          | existence_test
          | scalar_exp_predicate
		;

 scalar_exp_predicate: scalar_exp
				;

 comparison_predicate: scalar_exp COMPARISON scalar_exp
				;

 between_predicate: scalar_exp NOT BETWEEN scalar_exp AND scalar_exp
                  | scalar_exp BETWEEN scalar_exp AND scalar_exp
				;

 like_predicate: scalar_exp NOT LIKE scalar_exp opt_escape
               | scalar_exp LIKE scalar_exp opt_escape
			;

 opt_escape: .
           | ESCAPE atom
           | BEGINX ESCAPE atom ENDX
		;

 test_for_null: scalar_exp IS NOT NULLX
              | scalar_exp IS NULLX
			;

 in_predicate: scalar_exp NOT IN_L subquery
             | scalar_exp IN_L subquery
             | scalar_exp NOT IN_L '(' scalar_exp_commalist ')'
             | scalar_exp IN_L '(' scalar_exp_commalist ')'
			;


 all_or_any_predicate: scalar_exp COMPARISON any_all_some subquery
				;

 any_all_some: ANY
             | ALL
             | SOME
			;


 existence_test: EXISTS subquery
			;

 scalar_subquery: subquery
			;

 subquery: '(' SELECT opt_top selection table_exp ')'
		;

 scalar_exp: scalar_exp '-' scalar_exp
           | scalar_exp '+' scalar_exp
           | scalar_exp '*' scalar_exp
           | scalar_exp '/' scalar_exp
           | '+' scalar_exp
           | '-' scalar_exp
           | assignment_statement
           | string_concatenation_operator
           | column_ref
           | scalar_exp_no_col_ref
           | obe_literal
		;


 scalar_exp_no_col_ref: atom_no_obe
                      | aggregate_ref
                      | scalar_subquery
                      | '(' scalar_exp ')'
                      | '(' scalar_exp ',' scalar_exp_commalist ')'
                      | function_call
                      | new_invocation
                      | cvt_exp
                      | cast_exp
                      | simple_case
                      | searched_case
                      | coalesce_exp
                      | nullif_exp
                      | array_ref
                      | static_method_invocation
                      | method_invocation
                      | member_observer
				;

 scalar_exp_no_col_ref_no_mem_obs_chain: atom_no_obe
                                       | aggregate_ref
                                       | scalar_subquery
                                       | '(' scalar_exp ')'
                                       | '(' scalar_exp ',' scalar_exp_commalist ')'
                                       | function_call
                                       | new_invocation
                                       | cvt_exp
                                       | cast_exp
                                       | simple_case
                                       | searched_case
                                       | coalesce_exp
                                       | nullif_exp
                                       | array_ref
                                       | static_method_invocation
                                       | method_invocation
                                       | member_observer_no_id_chain
							;

 cvt_exp: CONVERT '(' data_type ',' scalar_exp ')'
		;

 opt_collate_exp: .
                | COLLATE q_table_name
			;

 cast_exp: CAST '(' scalar_exp AS data_type opt_collate_exp ')'
		;

 mssql_xml_col: MSSQL_XMLCOL_NAME1 MSSQL_XMLCOL_INTNUM MSSQL_XMLCOL_NAMEZ
              | MSSQL_XMLCOL_NAME1 MSSQL_XMLCOL_INTNUM MSSQL_XMLCOL_NAMEYZ
              | MSSQL_XMLCOL_NAME1 MSSQL_XMLCOL_INTNUM MSSQL_XMLCOL_NAME MSSQL_XMLCOL_NAMEZ
			;

 as_expression: scalar_exp AS identifier data_type
              | scalar_exp AS identifier
              | scalar_exp identifier
              | scalar_exp AS mssql_xml_col
			;


 array_ref: scalar_exp_no_col_ref '[' scalar_exp ']'
          | lvalue_array_ref
		;

 lvalue_array_ref: column_ref '[' scalar_exp ']'
			;

 opt_scalar_exp_commalist: .
                         | scalar_exp_commalist
					;


 function_name: identifier
              | identifier '.' method_identifier
              | identifier '.' identifier '.' method_identifier
              | identifier '.' identifier '.' identifier '.' method_identifier
              | identifier '.' '.' method_identifier
              | identifier '.' '.' identifier '.' method_identifier
              | LEFT
              | RIGHT
              | LOGX
			;


 kwd_commalist: identifier KWD_TAG scalar_exp
              | kwd_commalist ',' identifier KWD_TAG scalar_exp
			;


 as_commalist: as_expression
             | as_commalist ',' as_expression
             | as_commalist ',' scalar_exp
			;


 opt_arg_commalist: .
                  | kwd_commalist
                  | scalar_exp_commalist
                  | scalar_exp_commalist ',' kwd_commalist
                  | scalar_exp_commalist ',' as_commalist
                  | as_commalist
				;

 function_call: function_name '(' opt_arg_commalist ')'
              | TIMESTAMP_FUNC '(' SQL_TSI ',' scalar_exp ',' scalar_exp ')'
              | EXTRACT '(' NAME FROM scalar_exp ')'
              | BEGIN_FN_X identifier '(' opt_scalar_exp_commalist ')' ENDX
              | BEGIN_FN_X LEFT '(' opt_scalar_exp_commalist ')' ENDX
              | BEGIN_FN_X RIGHT '(' opt_scalar_exp_commalist ')' ENDX
              | BEGIN_FN_X LOGX '(' opt_scalar_exp_commalist ')' ENDX
              | BEGIN_FN_X identifier '(' scalar_exp IN_L scalar_exp ')' ENDX
              | BEGIN_CALL_X function_name '(' opt_scalar_exp_commalist ')' ENDX
              | BEGIN_CALL_X function_name ENDX
              | BEGIN_FN_X USER '(' opt_scalar_exp_commalist ')' ENDX
              | BEGIN_FN_X CHARACTER '(' opt_scalar_exp_commalist ')' ENDX
              | BEGIN_FN_X TIMESTAMP_FUNC '(' SQL_TSI ',' scalar_exp ',' scalar_exp ')' ENDX
              | BEGIN_FN_X CONVERT '(' scalar_exp ',' NAME ')' ENDX
              | BEGIN_FN_X EXTRACT '(' NAME FROM scalar_exp ')' ENDX
              | CALL '(' scalar_exp ')' '(' opt_arg_commalist ')'
              | CURRENT_DATE
              | CURRENT_TIME
              | CURRENT_TIME '(' scalar_exp ')'
              | CURRENT_TIMESTAMP
              | CURRENT_TIMESTAMP '(' scalar_exp ')'
              | GROUPING '(' column_ref ')'
			;


 
 obe_literal: BEGINX identifier atom ENDX
            | BEGIN_U_X STRING ENDX
		;


 scalar_exp_commalist: scalar_exp
                     | scalar_exp_commalist ',' scalar_exp
				;

 select_scalar_exp_commalist: scalar_exp
                            | as_expression
                            | select_scalar_exp_commalist ',' scalar_exp
                            | select_scalar_exp_commalist ',' as_expression
					;

 atom_no_obe: parameter_ref
            | literal
            | USER
			;


 atom: atom_no_obe
     | obe_literal
	;

 simple_case: CASE scalar_exp simple_when_list ENDX
			;

 searched_case: CASE searched_when_list ENDX
			;

 searched_when_list: searched_when
                   | searched_when_list searched_when
				;

 simple_when_list: simple_when
                 | simple_when_list simple_when
			;

 simple_when: WHEN scalar_exp THEN scalar_exp
            | ELSE scalar_exp
			;

 searched_when: WHEN search_condition THEN scalar_exp
              | ELSE scalar_exp
			;

 coalesce_exp: COALESCE '(' scalar_exp_commalist ')'
			;

 nullif_exp: NULLIF '(' scalar_exp ',' scalar_exp ')'
		;

 parameter_ref: parameter
              | parameter parameter
              | parameter INDICATOR parameter
			;

 aggregate_ref: AGGREGATE function_name '(' opt_arg_commalist ')'
              | AMMSC '(' DISTINCT scalar_exp ')'
              | AMMSC '(' ALL scalar_exp ')'
              | AMMSC '(' scalar_exp ')'
			;

 literal: STRING
        | WSTRING
        | INTNUM
        | APPROXNUM
        | BINARYNUM
        | NULLX
		;

 signed_literal: STRING
               | WSTRING
               | INTNUM
               | '-' INTNUM
               | '+' INTNUM
               | APPROXNUM
               | '-' APPROXNUM
               | '+' APPROXNUM
               | BINARYNUM
               | NULLX
			;

 q_table_name: identifier
             | identifier '.' identifier
             | identifier '.' identifier '.' identifier
             | identifier '.' '.' identifier
			;

 attach_q_table_name: identifier
                    | identifier '.' identifier
                    | identifier '.' identifier '.' identifier
                    | identifier '.' '.' identifier
				;


 new_proc_or_bif_name: identifier
                     | identifier '.' identifier
                     | identifier '.' identifier '.' identifier
                     | identifier '.' '.' identifier
				;

 new_table_name: identifier
               | identifier '.' identifier
               | identifier '.' identifier '.' identifier
               | identifier '.' '.' identifier
			;

 table: q_table_name opt_table_opt
      | q_table_name AS identifier opt_table_opt
      | q_table_name identifier opt_table_opt
		;

 column_ref: identifier
           | identifier '.' identifier
           | identifier '.' identifier '.' identifier
           | identifier '.' identifier '.' identifier '.' identifier
           | identifier '.' '.' identifier '.' identifier
           | '*'
           | identifier '.' '*'
           | identifier '.' identifier '.' '*'
           | identifier '.' identifier '.' identifier '.' '*'
           | identifier '.' '.' identifier '.' '*'
		;

 base_data_type: NUMERIC
               | NUMERIC '(' INTNUM ')'
               | NUMERIC '(' INTNUM ',' INTNUM ')'
               | DECIMAL
               | DECIMAL '(' INTNUM ')'
               | DECIMAL '(' INTNUM ',' INTNUM ')'
               | INTEGER
               | SMALLINT
               | FLOAT
               | FLOAT '(' INTNUM ')'
               | REAL
               | DOUBLE PRECISION
               | LONG VARCHAR
               | LONG VARBINARY
               | VARBINARY
               | VARBINARY '(' INTNUM ')'
               | BINARY '(' INTNUM ')'
               | TIMESTAMP
               | DATETIME
               | TIME
               | DATE
               | NCHAR
               | NCHAR '(' INTNUM ')'
               | NVARCHAR
               | NVARCHAR '(' INTNUM ')'
               | LONG NVARCHAR
               | ANY
               | ANY '(' INTNUM ')'
			;

 data_type: base_data_type
          | CHARACTER
          | VARCHAR
          | VARCHAR '(' INTNUM ')'
          | CHARACTER '(' INTNUM ')'
		;

 array_modifier: ARRAY
               | ARRAY '[' INTNUM ']'
			;

 data_type_ref: data_type_ref array_modifier
              | data_type
              | q_type_name
			;

 column_data_type: base_data_type
                 | CHARACTER
                 | VARCHAR
                 | VARCHAR '(' INTNUM ')'
                 | CHARACTER '(' INTNUM ')'
                 | q_type_name
                 | LONG q_type_name
                 | LONG XML
			;

 column: identifier
       | identifier '.' identifier '.' identifier '.' identifier
		;

 index: identifier
	;

 cursor: identifier
	;


 parameter: PARAMETER_L
          | NAMED_PARAMETER
		;

 user: identifier
	;

 opt_log: .
        | STRING
		;

 comma_opt_log: .
              | ',' STRING
			;

 admin_statement: SHUTDOWN opt_log
                | CHECKPOINT opt_log
                | CHECKPOINT STRING STRING
                | BACKUP STRING
                | CHECK
                | SYNC REPLICATION opt_log comma_opt_log
                | DISCONNECT REPLICATION opt_log
                | LOGX ON
                | LOGX OFF
			;

 sql: user_aggregate_declaration
    | routine_declaration
    | module_declaration
    | method_declaration
    | trigger_def
    | drop_trigger
    | drop_proc
    |manipulative_statement
    | BEGIN_EQCALL_X q_table_name ENDX
    | BEGIN_EQCALL_X q_table_name '(' opt_scalar_exp_commalist ')' ENDX
	;




 user_aggregate_declaration: CREATE AGGREGATE new_table_name rout_parameter_list opt_return FROM new_proc_or_bif_name ',' new_proc_or_bif_name ',' new_proc_or_bif_name user_aggregate_merge_opt
					;

 user_aggregate_merge_opt: .
                         | ',' new_proc_or_bif_name
					;

 routine_declaration: CREATE routine_head new_table_name rout_parameter_list opt_return rout_alt_type compound_statement
                    | ATTACH routine_head attach_q_table_name rout_parameter_list opt_return rout_alt_type opt_as FROM literal
                    | CREATE routine_head new_table_name rout_parameter_list opt_return rout_alt_type LANGUAGE external_language_name EXTERNAL NAME_L STRING opt_type_option_list
				;

 module_body_part: routine_head identifier rout_parameter_list opt_return rout_alt_type compound_statement
			;

 module_body: module_body_part ';'
            | module_body module_body_part ';'
		;

 module_declaration: CREATE MODULE new_table_name BEGINX module_body ENDX
				;

 routine_head: FUNCTION
             | PROCEDURE
			;

 opt_return: .
           | RETURNS data_type_ref
		;

 rout_parameter_list: '(' ')'
                    | '(' parameter_commalist ')'
				;

 parameter_commalist: rout_parameter
                    | parameter_commalist ',' rout_parameter
				;

 rout_parameter: parameter_mode column_ref data_type_ref rout_alt_type
               | parameter_mode column_ref data_type_ref DEFAULT signed_literal rout_alt_type
               | parameter_mode column_ref data_type_ref EQUALS signed_literal rout_alt_type
			;

 parameter_mode: IN_L
               | OUT_L
               | INOUT_L
			;

 opt_parameter_mode: .
                   | parameter_mode
				;

 opt_soap_enc_mode: .
                  | __SOAP_DIME_ENC IN_L
                  | __SOAP_DIME_ENC OUT_L
                  | __SOAP_DIME_ENC INOUT_L
                  | __SOAP_ENC_MIME IN_L
                  | __SOAP_ENC_MIME OUT_L
                  | __SOAP_ENC_MIME INOUT_L
				;

 soap_proc_opt_list: soap_proc_opt
                   | soap_proc_opt_list ',' soap_proc_opt
				;

 soap_proc_opt: NAME EQUALS signed_literal
			;

 soap_kwd: __SOAP_TYPE
         | __SOAP_HEADER
         | __SOAP_FAULT
         | __SOAP_DOC
         | __SOAP_XML_TYPE
         | __SOAP_DOCW
         | __SOAP_HTTP
		;

 rout_alt_type: .
              | __SOAP_OPTIONS '(' soap_kwd EQUALS STRING opt_soap_enc_mode ',' soap_proc_opt_list ')'
              | soap_kwd STRING opt_soap_enc_mode
			;

 routine_statement: select_statement
                  | update_statement_positioned
                  | update_statement_searched
                  | insert_statement
                  | delete_statement_positioned
                  | delete_statement_searched
                  | close_statement
                  | fetch_statement
                  | open_statement
                  | rollback_statement
                  | commit_statement
                  | .
			;

 empty2: .
	;

 compound_statement: BEGINX empty2 statement_list ENDX
				;

 statement_list: statement_in_cs
               | statement_list statement_in_cs
			;

 statement_in_cs: local_declaration ';'
                | compound_statement
			;

empty3: .
	;

 statement_in_cs: empty3 statement_in_cs_oper
			;

 statement_in_cs_oper: routine_statement ';'
                     | control_statement
                     | identifier COLON statement_in_cs
                     | HTMLSTR
                     | COMPARISON scalar_exp HTMLSTR
                     | '/' scalar_exp HTMLSTR
				;

 statement: compound_statement
		;


 empty4: .
	;

 statement: empty4 routine_statement ';'
		;


 empty5: .
	;

 statement: empty5 control_statement
		;

 local_declaration: cursor_def
                  | variable_declaration
                  | handler_declaration
			;

 variable_declaration: DECLARE variable_list data_type_ref
				;

 variable_list: identifier
              | variable_list ',' identifier
			;

 condition: NOT FOUND
          | SQLSTATE STRING
          | SQLSTATE VALUE STRING
          | SQLEXCEPTION
          | SQLWARNING
		;

 handler_statement: compound_statement
                  | routine_statement
                  | call_statement
                  | method_invocation
                  | static_method_invocation
                  | set_statement
                  | RESIGNAL
                  | RESIGNAL scalar_exp
                  | return_statement
                  | assignment_statement
                  | if_statement
                  | goto_statement
                  | for_statement
                  | while_statement
				;


 handler_declaration: WHENEVER condition GOTO identifier
                    | WHENEVER condition GO TO identifier
                    | WHENEVER condition DEFAULT
                    | DECLARE handler_type HANDLER FOR cond_value_list handler_statement
				;

 handler_type: CONTINUE
             | EXIT
			;

 cond_value_list: condition
                | cond_value_list ',' condition
			;

 control_statement: call_statement ';'
                  | method_invocation ';'
                  | static_method_invocation ';'
                  | set_statement ';'
                  | RESIGNAL ';'
                  | RESIGNAL scalar_exp ';'
                  | return_statement ';'
                  | assignment_statement ';'
                  | if_statement
                  | goto_statement ';'
                  | for_statement
                  | while_statement
				;


 assignment_statement: lvalue EQUALS scalar_exp
                     | column_ref '[' scalar_exp ']' EQUALS scalar_exp
				;

 lvalue: column_ref
       | member_observer
		;

 if_statement: IF '(' search_condition ')' statement opt_else
		;

 opt_else: .
         | ELSE statement
		;


 call_statement: CALL function_name '(' opt_arg_commalist ')'
               | function_call
			;

 set_statement: SET identifier COMPARISON scalar_exp
              | SET identifier ON
              | SET identifier OFF
			;

 goto_statement: GOTO identifier
               | GO TO identifier
			;


 return_statement: RETURN scalar_exp
                 | RETURN
			;

 while_statement: WHILE '(' search_condition ')' statement
		;

 for_init_statement: assignment_statement
                   | variable_declaration
                   | call_statement
                   | static_method_invocation
				;

 for_init_statement_list: .
                        | for_init_statement
                        | for_init_statement_list ',' for_init_statement
					;

 for_inc_statement: assignment_statement
                  | call_statement
                  | static_method_invocation
			;

 for_inc_statement_list: .
                       | for_inc_statement
                       | for_inc_statement_list ',' for_inc_statement
				;

 for_opt_search_cond: .
                    | search_condition
				;

 for_statement: FOR query_exp DO statement
              | FOR '(' for_init_statement_list ';' for_opt_search_cond ';' for_inc_statement_list ')' statement
              | FOREACH '(' data_type_ref identifier IN_L scalar_exp ')' DO statement
			;

 trigger_def: CREATE TRIGGER identifier action_time event ON q_table_name opt_order opt_old_ref trig_action
			;

 opt_order: .
          | ORDER INTNUM
		;

 trig_action: compound_statement
		;

 action_time: BEFORE
            | AFTER
            | INSTEAD OF
			;

 event: INSERT
      | UPDATE opt_column_commalist
      | DELETE_L
		;

 opt_old_ref: .
            | REFERENCING old_commalist
		;

 old_commalist: old_alias
              | old_commalist ',' old_alias
			;

 old_alias: OLD AS identifier
          | NEW AS identifier
		;

 drop_trigger: DROP TRIGGER q_table_name
		;

 drop_proc: DROP AGGREGATE q_table_name
          | DROP routine_head q_table_name
          | DROP MODULE q_table_name
		;

 opt_element: .
            | AS identifier
			;

 xml_col: column_ref
        | scalar_exp AS identifier
        | scalar_exp IN_L identifier
		;

 xml_col_list: xml_col
             | xml_col_list ',' xml_col
			;

 opt_xml_col_list: '(' xml_col_list ')'
			;

 opt_pk: .
       | PRIMARY KEY '(' column_commalist ')'
		;


 opt_join: .
         | ON '(' search_condition ')'
		;

 opt_elt: .
        | NAME
		;


 xml_join_elt: q_table_name identifier opt_element opt_xml_col_list opt_join opt_pk opt_elt opt_xml_child
		;

 opt_xml_child: .
              | BEGINX xml_join_list ENDX
			;


 top_xml_child: query_spec
              | BEGINX xml_join_list ENDX
			;


 xml_join_list: xml_join_elt
              | xml_join_list ',' xml_join_elt
			;

 opt_persist: .
            | PERSISTENT
			;

 opt_interval: .
             | INTERVAL INTNUM
			;


 opt_metas: .
          | DTD INTERNAL
          | DTD EXTERNAL
          | DTD STRING
          | SCHEMA EXTERNAL
          | SCHEMA STRING
		;

 opt_publish: .
            | PUBLIC STRING identifier STRING opt_persist opt_interval opt_metas
		;

 xmlview_param_value: NAME
                    | STRING
				;

 xmlview_param: NAME COMPARISON xmlview_param_value
			;


 xmlview_params: xmlview_param
               | xmlview_params xmlview_param
			;

 opt_xmlview_params: .
                   | '[' xmlview_params ']'
				;

 xml_view: CREATE XML VIEW new_table_name AS opt_xmlview_params top_xml_child opt_elt opt_publish
		;

 drop_xml_view: DROP XML VIEW q_table_name
			;

 string_concatenation_operator: scalar_exp STRING_CONCAT_OPERATOR scalar_exp
						;

 q_type_name: identifier
            | identifier '.' identifier
            | identifier '.' identifier '.' identifier
            | identifier '.' '.' identifier
		;

 q_old_type_name: identifier
                | identifier '.' identifier
                | identifier '.' identifier '.' identifier
                | identifier '.' '.' identifier
			;

 new_type_name: identifier
              | identifier '.' identifier
              | identifier '.' identifier '.' identifier
              | identifier '.' '.' identifier
			;

empty6: .
		;

 user_defined_type: CREATE TYPE new_type_name opt_subtype_clause opt_external_and_language_clause empty6 opt_as_type_representation opt_type_option_list opt_method_specification_list
			;

 user_defined_type_drop: DROP TYPE q_old_type_name opt_drop_behavior
				;

 opt_external_and_language_clause: .
                                 | LANGUAGE language_name EXTERNAL NAME_L STRING
                                 | EXTERNAL NAME_L STRING LANGUAGE language_name
                                 | LANGUAGE language_name
						;

 opt_subtype_clause: .
                   | UNDER q_type_name
				;

 opt_as_type_representation: .
                           | AS type_representation
					;

 type_representation: '(' type_member_list ')'
				;

 type_member_list: type_member
                 | type_member_list ',' type_member
			;

 opt_external_clause: .
                    | EXTERNAL NAME_L STRING
                    | EXTERNAL NAME_L STRING EXTERNAL TYPE STRING
                    | EXTERNAL TYPE STRING
				;

 opt_soap_clause: .
                | __SOAP_NAME STRING
                | __SOAP_TYPE STRING
                | __SOAP_TYPE STRING __SOAP_NAME STRING
                | __SOAP_NAME STRING __SOAP_TYPE STRING
			;

 opt_external_type: .
                  | EXTERNAL TYPE STRING
				;

 type_member: identifier data_type_ref opt_reference_scope_check opt_default_clause opt_collate_exp opt_external_clause opt_soap_clause
		;

 opt_reference_scope_check: .
                          | REFERENCES ARE CHECKED opt_on_delete_referential_rule
                          | REFERENCES ARE NOT CHECKED
					;

 opt_default_clause: .
                   | DEFAULT signed_literal
				;

 opt_type_option_list: .
                     | type_option_list
				;

 type_option_list: type_option
                 | type_option_list type_option
				;

 type_option: FINAL_L
            | NOT FINAL_L
            | REF USING data_type_ref
            | REF FROM '(' column_commalist ')'
            | REF IS SYSTEM GENERATED
            | CAST '(' SOURCE AS REF ')' WITH identifier
            | CAST '(' REF AS SOURCE ')' WITH identifier
            | SELF_L AS REF
            | TEMPORARY
            | UNRESTRICTED
            | __SOAP_TYPE STRING
			;

 opt_method_specification_list: .
                              | method_specification_list
						;

 method_specification_list: method_specification
                          | method_specification_list ',' method_specification
					;

 method_type: .
            | STATIC_L
            | INSTANCE_L	
			;

 decl_parameter_list: '(' ')'
                    | '(' decl_parameter_commalist ')'
				;

 decl_parameter_commalist: decl_parameter
                         | decl_parameter_commalist ',' decl_parameter
					;

 decl_parameter: opt_parameter_mode column_ref data_type_ref opt_external_type
			;

 partial_method_specification: method_type METHOD method_identifier decl_parameter_list RETURNS data_type_ref opt_specific_method_name
                             | CONSTRUCTOR METHOD method_identifier decl_parameter_list opt_specific_method_name
					;

 method_specification: partial_method_specification opt_self_result opt_method_characteristics
                     | OVERRIDING partial_method_specification
				;

 opt_self_result: .
                | SELF_L AS RESULT
                | SELF_L AS LOCATOR
                | SELF_L AS RESULT SELF_L AS LOCATOR
			;

 opt_specific_method_name: .
                         | SPECIFIC new_table_name
					;

 opt_method_characteristics: .
                           | method_characteristics
					;

 method_characteristics: method_characteristic
                       | method_characteristics method_characteristic
					;

 method_characteristic: LANGUAGE language_name
                      | PARAMETER STYLE SQL_L
                      | PARAMETER STYLE GENERAL
                      | DETERMINISTIC
                      | NOT DETERMINISTIC
                      | NO SQL_L
                      | CONTAINS SQL_L
                      | READS SQL_L DATA
                      | MODIFIES SQL_L DATA
                      | RETURNS NULLX ON NULLX INPUT
                      | CALLED ON NULLX INPUT
                      | EXTERNAL NAME_L STRING
                      | EXTERNAL VARIABLE NAME_L STRING
                      | EXTERNAL TYPE STRING
				;

 external_language_name: ADA
                       | C
                       | COBOL
                       | FORTRAN
                       | MUMPS
                       | PASCAL_L
                       | PLI
                       | JAVA
                       | CLR
				;

 language_name: external_language_name
              | SQL_L
			;

 opt_constructor_return: .
                       | RETURNS new_type_name
				;

 method_declaration: CREATE method_type METHOD method_identifier rout_parameter_list opt_return rout_alt_type FOR q_type_name compound_statement
                   | CREATE CONSTRUCTOR METHOD q_table_name rout_parameter_list opt_constructor_return FOR q_type_name compound_statement
				;

 static_method_invocation: q_type_name DOUBLE_COLON method_identifier '(' opt_arg_commalist ')'
					;

 identifier_chain: identifier '.' identifier '.' identifier '.' method_identifier
                 | identifier '.' '.' identifier '.' method_identifier
                 | identifier '.' identifier_chain
			;

 identifier_chain_method: identifier '.' identifier '.' identifier '.' identifier '.' method_identifier
                        | identifier '.' '.' identifier '.' identifier '.' method_identifier
                        | identifier '.' identifier_chain_method
					;

 method_invocation: scalar_exp_no_col_ref_no_mem_obs_chain '.' method_identifier '(' opt_arg_commalist ')'
                  | identifier_chain_method '(' opt_arg_commalist ')'
                  | '(' scalar_exp_no_col_ref AS q_type_name ')' '.' method_identifier '(' opt_arg_commalist ')'
                  | '(' column_ref AS q_type_name ')' '.' method_identifier '(' opt_arg_commalist ')'
			;

 top_level_method_invocation: METHOD CALL scalar_exp_no_col_ref_no_mem_obs_chain '.' method_identifier '(' opt_arg_commalist ')'
                            | METHOD CALL identifier_chain_method '(' opt_arg_commalist ')'
                            | METHOD CALL '(' scalar_exp_no_col_ref AS q_type_name ')' '.' method_identifier '(' opt_arg_commalist ')'
                            | METHOD CALL '(' column_ref AS q_type_name ')' '.' method_identifier '(' opt_arg_commalist ')'
					;

 member_observer: member_observer_no_id_chain
                | identifier '.' identifier_chain
			;

 member_observer_no_id_chain: scalar_exp_no_col_ref_no_mem_obs_chain '.' method_identifier
                            | '(' scalar_exp_no_col_ref AS q_type_name ')' '.' method_identifier
                            | '(' column_ref AS q_type_name ')' '.' method_identifier
					;

 method_identifier: identifier
                  | EXTRACT
				;

 new_invocation: NEW q_type_name '(' opt_arg_commalist ')'
			;

 user_defined_type_alter: ALTER TYPE q_type_name alter_type_action
					;

 alter_type_action: ADD ATTRIBUTE type_member
                  | DROP ATTRIBUTE identifier opt_drop_behavior
                  | ADD method_specification
                  | DROP partial_method_specification opt_drop_behavior
				;

 opt_with_permission_set: .
                        | WITH PERMISSION_SET COMPARISON SAFE_L
                        | WITH PERMISSION_SET COMPARISON UNRESTRICTED
					;

 opt_with_autoregister: .
                      | WITH AUTOREGISTER_L
				;

 create_library: CREATE LIBRARY_L q_table_name AS scalar_exp opt_with_permission_set opt_with_autoregister
			;

 create_assembly: CREATE ASSEMBLY_L q_table_name FROM scalar_exp opt_with_permission_set opt_with_autoregister
			;

 drop_library: DROP LIBRARY_L q_table_name
		;

 drop_assembly: DROP ASSEMBLY_L q_table_name
			;











%nonassoc IF			;
%nonassoc ELSE			;

/* Define the operator tokens and their precedences.
   The value is an integer because, if used, it is the tree code
   to use in the expression made from the operator.  */


%right	ASSIGN '='						;
%right	'?' ':'						;
%left		OROR							;
%left		ANDAND						;
%left  	'|'							;
%left  	'^'							;
%left  	'&'							;
%left  	EQCOMPARE						;
%left  	ARITHCOMPARE					;
%left  	LSHIFT RSHIFT					;
%left  	'+' '-'						;
%left  	'*' '/' '%'					;
%right  	UNARY		PLUSPLUS	MINUSMINUS		;
%left 	HYPERUNARY						;
%left  	POINTSAT	'.'	'('	'['			;



program	:	.
		|	extdefs
		;

extdefs: extdef
	| extdefs extdef
	;

extdef: extdef_1
	;

extdef_1:
	fndef
	| datadef
	| objcdef
	| ASM_KEYWORD '(' expr ')' ';'
	| extension extdef
	;

datadef:
	  setspecs notype_initdecls ';'
	| declspecs_nots setspecs notype_initdecls ';'
	| declspecs_ts setspecs initdecls ';'
	| declspecs ';'
	| error ';'
	| error '}'
	| ';'

;

fndef		:	declspecs_ts setspecs declarator
	  		old_style_parm_decls
	  		save_filename save_lineno compstmt_or_error
	| declspecs_ts setspecs declarator error
	| declspecs_nots setspecs notype_declarator
	  old_style_parm_decls
	  save_filename save_lineno compstmt_or_error
	| declspecs_nots setspecs notype_declarator error
	| setspecs notype_declarator
	  old_style_parm_decls
	  save_filename save_lineno compstmt_or_error
	| setspecs notype_declarator error
	;

identifier:
	IDENTIFIER
	| TYPENAME
	| OBJECTNAME
	| CLASSNAME
	;

unop: '&'
	| '-'
	| '+'
	| PLUSPLUS
	| MINUSMINUS
	| '~'
	| '!'
	;

expr:	nonnull_exprlist
	;

exprlist	:	.
		|	nonnull_exprlist
		;

nonnull_exprlist	:	expr_no_commas
				|	nonnull_exprlist ',' expr_no_commas
				;

unary_expr			:	primary
	| '*' cast_expr   %prec UNARY
	| extension cast_expr	  %prec UNARY
	| unop cast_expr  %prec UNARY
	| ANDAND identifier
	| sizeof unary_expr  %prec UNARY
	| sizeof '(' typename ')'  %prec HYPERUNARY
	| alignof unary_expr  %prec UNARY
	| alignof '(' typename ')'  %prec HYPERUNARY
	| REALPART cast_expr %prec UNARY
	| IMAGPART cast_expr %prec UNARY
	;

sizeof:
	SIZEOF
	;

alignof:
	ALIGNOF
	;

typeof:
	TYPEOF 
	;

cast_expr:
	unary_expr
	| '(' typename ')' cast_expr  %prec UNARY
	;

expr_no_commas:
	  cast_expr
	| expr_no_commas '+' expr_no_commas
	| expr_no_commas '-' expr_no_commas
	| expr_no_commas '*' expr_no_commas
	| expr_no_commas '/' expr_no_commas
	| expr_no_commas '%' expr_no_commas
	| expr_no_commas LSHIFT expr_no_commas
	| expr_no_commas RSHIFT expr_no_commas
	| expr_no_commas ARITHCOMPARE expr_no_commas
	| expr_no_commas EQCOMPARE expr_no_commas
	| expr_no_commas '&' expr_no_commas
	| expr_no_commas '|' expr_no_commas
	| expr_no_commas '^' expr_no_commas
	| expr_no_commas ANDAND expr_no_commas
	| expr_no_commas OROR  expr_no_commas
	| expr_no_commas '?'     expr ':'  expr_no_commas
	| expr_no_commas '?'  ':' expr_no_commas
	| expr_no_commas '=' expr_no_commas
	| expr_no_commas ASSIGN expr_no_commas
	;

primary:
	IDENTIFIER
	| CONSTANT
	| STRING
	| VAR_FUNC_NAME
	| '(' typename ')' '{'
	  initlist_maybe_comma '}'  %prec UNARY
	| '(' expr ')'
	| '(' error ')'
	| compstmt_primary_start compstmt_nostart ')'
	| compstmt_primary_start error ')'
	| primary '(' exprlist ')'   %prec '.'
	| VA_ARG '(' expr_no_commas ',' typename ')'
      | CHOOSE_EXPR '(' expr_no_commas ',' expr_no_commas ',' expr_no_commas ')'
      | TYPES_COMPATIBLE_P '(' typename ',' typename ')'
	| primary '[' expr ']'   %prec '.'
	| primary '.' identifier
	| primary POINTSAT identifier
	| primary PLUSPLUS
	| primary MINUSMINUS
	| objcmessageexpr
	| objcselectorexpr
	| objcprotocolexpr
	| objcencodeexpr
	| objc_string
	;

/* Produces an STRING_CST with perhaps more STRING_CSTs chained
   onto it, which is to be read as an ObjC string object. 
 */
objc_string	:	'@' STRING
			|	objc_string '@' STRING
			;

old_style_parm_decls	:	old_style_parm_decls_1
				;

old_style_parm_decls_1	:	.
					|	datadecls
					;

/* The following are analogous to lineno_decl, decls and decl
   except that they do not allow nested functions.
   They are used for old-style parm decls.  */
lineno_datadecl:
	  save_filename save_lineno datadecl
	;

datadecls:
	lineno_datadecl
	| errstmt
	| datadecls lineno_datadecl
	| lineno_datadecl errstmt
	;

/* We don't allow prefix attributes here because they cause reduce/reduce
   conflicts: we can't know whether we're parsing a function decl with
   attribute suffix, or function defn with attribute prefix on first old
   style parm.  */
datadecl:
	declspecs_ts_nosa setspecs initdecls ';'
	| declspecs_nots_nosa setspecs notype_initdecls ';'
	| declspecs_ts_nosa ';'
	| declspecs_nots_nosa ';'
	;

/* This combination which saves a lineno before a decl
   is the normal thing to use, rather than decl itself.
   This is to avoid shift/reduce conflicts in contexts
   where statement labels are allowed.  */
lineno_decl:
	  save_filename save_lineno decl
	;

/* records the type and storage class specs to use for processing
   the declarators that follow.
   Maintains a stack of outer-level values of current_declspecs,
   for the sake of parm declarations nested in function declarators.  */
setspecs	: .
		;

/* Possibly attributes after a comma, which should reset all_prefix_attributes
   to prefix_attributes with these ones chained on the front.  */
maybe_resetattrs:
	  maybe_attribute
	;

decl:
	declspecs_ts setspecs initdecls ';'
	| declspecs_nots setspecs notype_initdecls ';'
	| declspecs_ts setspecs nested_function
	| declspecs_nots setspecs notype_nested_function
	| declspecs ';'
	| extension decl
	;

/* A list of declaration specifiers.  These are:

   - Storage class specifiers (scspec), which for GCC currently includes
   function specifiers ("inline").

   - Type specifiers (typespec_*).

   - Type qualifiers (TYPE_QUAL).

   - Attribute specifier lists (attributes).

   These are stored as a TREE_LIST; the head of the list is the last
   item in the specifier list.  Each entry in the list has either a
   TREE_PURPOSE that is an attribute specifier list, or a TREE_VALUE that
   is a single other specifier or qualifier; and a TREE_CHAIN that is the
   rest of the list.  TREE_STATIC is set on the list if something other
   than a storage class specifier or attribute has been seen; this is used
   to warn for the obsolescent usage of storage class specifiers other than
   at the start of the list.  (Doing this properly would require function
   specifiers to be handled separately from storage class specifiers.)

   The various cases below are classified according to:

   (a) Whether a storage class specifier is included or not; some
   places in the grammar disallow storage class specifiers (_sc or _nosc).

   (b) Whether a type specifier has been seen; after a type specifier,
   a typedef name is an identifier to redeclare (_ts or _nots).

   (c) Whether the list starts with an attribute; in certain places,
   the grammar requires specifiers that don't start with an attribute
   (_sa or _nosa).

   (d) Whether the list ends with an attribute (or a specifier such that
   any following attribute would have been parsed as part of that specifier);
   this avoids shift-reduce conflicts in the parsing of attributes
   (_ea or _noea).

   TODO:

   (i) Distinguish between function specifiers and storage class specifiers,
   at least for the purpose of warnings about obsolescent usage.

   (ii) Halve the number of productions here by eliminating the _sc/_nosc
   distinction and instead checking where required that storage class
   specifiers aren't present.  */

/* Declspecs which contain at least one type specifier or typedef name.
   (Just `const' or `volatile' is not enough.)
   A typedef'd name following these is taken as a name to be declared.
   Declspecs have a non-NULL TREE_VALUE, attributes do not.  */

declspecs_nosc_nots_nosa_noea:
	  TYPE_QUAL
	| declspecs_nosc_nots_nosa_noea TYPE_QUAL
	| declspecs_nosc_nots_nosa_ea TYPE_QUAL
	;

declspecs_nosc_nots_nosa_ea:
	  declspecs_nosc_nots_nosa_noea attributes
	;

declspecs_nosc_nots_sa_noea:
	  declspecs_nosc_nots_sa_noea TYPE_QUAL
	| declspecs_nosc_nots_sa_ea TYPE_QUAL
	;

declspecs_nosc_nots_sa_ea:
	  attributes
	| declspecs_nosc_nots_sa_noea attributes
	;

declspecs_nosc_ts_nosa_noea:
	  typespec_nonattr
	| declspecs_nosc_ts_nosa_noea TYPE_QUAL
	| declspecs_nosc_ts_nosa_ea TYPE_QUAL
	| declspecs_nosc_ts_nosa_noea typespec_reserved_nonattr
	| declspecs_nosc_ts_nosa_ea typespec_reserved_nonattr
	| declspecs_nosc_nots_nosa_noea typespec_nonattr
	| declspecs_nosc_nots_nosa_ea typespec_nonattr
	;

declspecs_nosc_ts_nosa_ea:
	  typespec_attr
	| declspecs_nosc_ts_nosa_noea attributes
	| declspecs_nosc_ts_nosa_noea typespec_reserved_attr
	| declspecs_nosc_ts_nosa_ea typespec_reserved_attr
	| declspecs_nosc_nots_nosa_noea typespec_attr
	| declspecs_nosc_nots_nosa_ea typespec_attr
	;

declspecs_nosc_ts_sa_noea:
	  declspecs_nosc_ts_sa_noea TYPE_QUAL
	| declspecs_nosc_ts_sa_ea TYPE_QUAL
	| declspecs_nosc_ts_sa_noea typespec_reserved_nonattr
	| declspecs_nosc_ts_sa_ea typespec_reserved_nonattr
	| declspecs_nosc_nots_sa_noea typespec_nonattr
	| declspecs_nosc_nots_sa_ea typespec_nonattr
	;

declspecs_nosc_ts_sa_ea:
	  declspecs_nosc_ts_sa_noea attributes
	| declspecs_nosc_ts_sa_noea typespec_reserved_attr
	| declspecs_nosc_ts_sa_ea typespec_reserved_attr
	| declspecs_nosc_nots_sa_noea typespec_attr
	| declspecs_nosc_nots_sa_ea typespec_attr
	;

declspecs_sc_nots_nosa_noea:
	  scspec
	| declspecs_sc_nots_nosa_noea TYPE_QUAL
	| declspecs_sc_nots_nosa_ea TYPE_QUAL
	| declspecs_nosc_nots_nosa_noea scspec
	| declspecs_nosc_nots_nosa_ea scspec
	| declspecs_sc_nots_nosa_noea scspec
	| declspecs_sc_nots_nosa_ea scspec
	;

declspecs_sc_nots_nosa_ea:
	  declspecs_sc_nots_nosa_noea attributes
	;

declspecs_sc_nots_sa_noea:
	  declspecs_sc_nots_sa_noea TYPE_QUAL
	| declspecs_sc_nots_sa_ea TYPE_QUAL
	| declspecs_nosc_nots_sa_noea scspec
	| declspecs_nosc_nots_sa_ea scspec
	| declspecs_sc_nots_sa_noea scspec
	| declspecs_sc_nots_sa_ea scspec
	;

declspecs_sc_nots_sa_ea:
	  declspecs_sc_nots_sa_noea attributes
	;

declspecs_sc_ts_nosa_noea:
	  declspecs_sc_ts_nosa_noea TYPE_QUAL
	| declspecs_sc_ts_nosa_ea TYPE_QUAL
	| declspecs_sc_ts_nosa_noea typespec_reserved_nonattr
	| declspecs_sc_ts_nosa_ea typespec_reserved_nonattr
	| declspecs_sc_nots_nosa_noea typespec_nonattr
	| declspecs_sc_nots_nosa_ea typespec_nonattr
	| declspecs_nosc_ts_nosa_noea scspec
	| declspecs_nosc_ts_nosa_ea scspec
	| declspecs_sc_ts_nosa_noea scspec
	| declspecs_sc_ts_nosa_ea scspec
	;

declspecs_sc_ts_nosa_ea:
	  declspecs_sc_ts_nosa_noea attributes
	| declspecs_sc_ts_nosa_noea typespec_reserved_attr
	| declspecs_sc_ts_nosa_ea typespec_reserved_attr
	| declspecs_sc_nots_nosa_noea typespec_attr
	| declspecs_sc_nots_nosa_ea typespec_attr
	;

declspecs_sc_ts_sa_noea:
	  declspecs_sc_ts_sa_noea TYPE_QUAL
	| declspecs_sc_ts_sa_ea TYPE_QUAL
	| declspecs_sc_ts_sa_noea typespec_reserved_nonattr
	| declspecs_sc_ts_sa_ea typespec_reserved_nonattr
	| declspecs_sc_nots_sa_noea typespec_nonattr
	| declspecs_sc_nots_sa_ea typespec_nonattr
	| declspecs_nosc_ts_sa_noea scspec
	| declspecs_nosc_ts_sa_ea scspec
	| declspecs_sc_ts_sa_noea scspec
	| declspecs_sc_ts_sa_ea scspec
	;

declspecs_sc_ts_sa_ea:
	  declspecs_sc_ts_sa_noea attributes
	| declspecs_sc_ts_sa_noea typespec_reserved_attr
	| declspecs_sc_ts_sa_ea typespec_reserved_attr
	| declspecs_sc_nots_sa_noea typespec_attr
	| declspecs_sc_nots_sa_ea typespec_attr
	;

/* Particular useful classes of declspecs.  */
declspecs_ts:
	  declspecs_nosc_ts_nosa_noea
	| declspecs_nosc_ts_nosa_ea
	| declspecs_nosc_ts_sa_noea
	| declspecs_nosc_ts_sa_ea
	| declspecs_sc_ts_nosa_noea
	| declspecs_sc_ts_nosa_ea
	| declspecs_sc_ts_sa_noea
	| declspecs_sc_ts_sa_ea
	;

declspecs_nots:
	  declspecs_nosc_nots_nosa_noea
	| declspecs_nosc_nots_nosa_ea
	| declspecs_nosc_nots_sa_noea
	| declspecs_nosc_nots_sa_ea
	| declspecs_sc_nots_nosa_noea
	| declspecs_sc_nots_nosa_ea
	| declspecs_sc_nots_sa_noea
	| declspecs_sc_nots_sa_ea
	;

declspecs_ts_nosa:
	  declspecs_nosc_ts_nosa_noea
	| declspecs_nosc_ts_nosa_ea
	| declspecs_sc_ts_nosa_noea
	| declspecs_sc_ts_nosa_ea
	;

declspecs_nots_nosa:
	  declspecs_nosc_nots_nosa_noea
	| declspecs_nosc_nots_nosa_ea
	| declspecs_sc_nots_nosa_noea
	| declspecs_sc_nots_nosa_ea
	;

declspecs_nosc_ts:
	  declspecs_nosc_ts_nosa_noea
	| declspecs_nosc_ts_nosa_ea
	| declspecs_nosc_ts_sa_noea
	| declspecs_nosc_ts_sa_ea
	;

declspecs_nosc_nots:
	  declspecs_nosc_nots_nosa_noea
	| declspecs_nosc_nots_nosa_ea
	| declspecs_nosc_nots_sa_noea
	| declspecs_nosc_nots_sa_ea
	;

declspecs_nosc:
	  declspecs_nosc_ts_nosa_noea
	| declspecs_nosc_ts_nosa_ea
	| declspecs_nosc_ts_sa_noea
	| declspecs_nosc_ts_sa_ea
	| declspecs_nosc_nots_nosa_noea
	| declspecs_nosc_nots_nosa_ea
	| declspecs_nosc_nots_sa_noea
	| declspecs_nosc_nots_sa_ea
	;

declspecs:
	  declspecs_nosc_nots_nosa_noea
	| declspecs_nosc_nots_nosa_ea
	| declspecs_nosc_nots_sa_noea
	| declspecs_nosc_nots_sa_ea
	| declspecs_nosc_ts_nosa_noea
	| declspecs_nosc_ts_nosa_ea
	| declspecs_nosc_ts_sa_noea
	| declspecs_nosc_ts_sa_ea
	| declspecs_sc_nots_nosa_noea
	| declspecs_sc_nots_nosa_ea
	| declspecs_sc_nots_sa_noea
	| declspecs_sc_nots_sa_ea
	| declspecs_sc_ts_nosa_noea
	| declspecs_sc_ts_nosa_ea
	| declspecs_sc_ts_sa_noea
	| declspecs_sc_ts_sa_ea
	;

/* A (possibly empty) sequence of type qualifiers and attributes.  */
maybe_type_quals_attrs	:	.
					|	declspecs_nosc_nots
					;


/* A type specifier (but not a type qualifier).
   Once we have seen one of these in a declaration,
   if a typedef name appears then it is being redeclared.

   The _reserved versions start with a reserved word and may appear anywhere
   in the declaration specifiers; the _nonreserved versions may only
   appear before any other type specifiers, and after that are (if names)
   being redeclared.

   FIXME: should the _nonreserved version be restricted to names being
   redeclared only?  The other entries there relate only the GNU extensions
   and Objective C, and are historically parsed thus, and don't make sense
   after other type specifiers, but it might be cleaner to count them as
   _reserved.

   _attr means: specifiers that either end with attributes,
   or are such that any following attributes would
   be parsed as part of the specifier.

   _nonattr: specifiers.  */

typespec_nonattr:
	  typespec_reserved_nonattr
	| typespec_nonreserved_nonattr
	;

typespec_attr:
	  typespec_reserved_attr
	;

typespec_reserved_nonattr:
	  TYPESPEC
	| structsp_nonattr
	;

typespec_reserved_attr:
	  structsp_attr
	;

typespec_nonreserved_nonattr:
	  TYPENAME
	| CLASSNAME protocolrefs
	| OBJECTNAME protocolrefs
	| non_empty_protocolrefs
	| typeof '(' expr ')'
	| typeof '(' typename ')'
	;

/* typespec_nonreserved_attr does not exist.  */

initdecls:
	initdcl
	| initdecls ',' maybe_resetattrs initdcl
	;

notype_initdecls:
	notype_initdcl
	| notype_initdecls ',' maybe_resetattrs notype_initdcl
	;

maybeasm:
	  .
	| ASM_KEYWORD '(' STRING ')'
	;

initdcl: declarator maybeasm maybe_attribute '=' init
	| declarator maybeasm maybe_attribute
	;

notype_initdcl:
	  notype_declarator maybeasm maybe_attribute '=' init
	| notype_declarator maybeasm maybe_attribute
	;

maybe_attribute:
      .
  	| attributes
	;

attributes:
      attribute
	| attributes attribute
	;

attribute:
      ATTRIBUTE '(' '(' attribute_list ')' ')'
	;

attribute_list:
      attrib
	| attribute_list ',' attrib
	;

attrib:
    .
	| any_word
	| any_word '(' IDENTIFIER ')'
	| any_word '(' IDENTIFIER ',' nonnull_exprlist ')'
	| any_word '(' exprlist ')'
	;

/* This still leaves out most reserved keywords,
   shouldn't we include them?  */

any_word:
	  identifier
	| scspec
	| TYPESPEC
	| TYPE_QUAL
	;

scspec:
	  STATIC
	| SCSPEC
	;

/* Initializers.  `init' is the entry point.  */

init:
	expr_no_commas
	| '{'
	| error
	;

/* `initlist_maybe_comma' is the guts of an initializer in braces.  */
initlist_maybe_comma:
	  .
	| initlist1 maybecomma
	;

initlist1:
	  initelt
	| initlist1 ',' initelt
	;

/* `initelt' is a single element of an initializer.
   It may use braces.  */
initelt:
	  designator_list '=' initval
	| designator initval
	| identifier ':'
	  initval
	| initval
	;

initval: '{' initlist_maybe_comma '}'
	| expr_no_commas
	| error
	;

designator_list:
	  designator
	| designator_list designator
	;

designator:
	  '.' identifier
	| '[' expr_no_commas ELLIPSIS expr_no_commas ']'
	| '[' expr_no_commas ']'
	;

nested_function:
	  declarator
	   old_style_parm_decls
	  save_filename save_lineno compstmt
	;

notype_nested_function:
	  notype_declarator
	 old_style_parm_decls
	  save_filename save_lineno compstmt
	;

/* Any kind of declarator (thus, all declarators allowed
   after an explicit typespec).  */

declarator:
	  after_type_declarator
	| notype_declarator
	;

/* A declarator that is allowed only after an explicit typespec.  */

after_type_declarator:
	  '(' maybe_attribute after_type_declarator ')'
	| after_type_declarator '(' parmlist_or_identifiers  %prec '.'
	| after_type_declarator '(' error ')'  %prec '.'
	| after_type_declarator array_declarator  %prec '.'
	| '*' maybe_type_quals_attrs after_type_declarator  %prec UNARY
	| TYPENAME
	| OBJECTNAME
	;

/* Kinds of declarator that can appear in a parameter list
   in addition to notype_declarator.  This is like after_type_declarator
   but does not allow a typedef name in parentheses as an identifier
   (because it would conflict with a function with that typedef as arg).  */
parm_declarator:
	  parm_declarator_starttypename
	| parm_declarator_nostarttypename
	;

parm_declarator_starttypename:
	  parm_declarator_starttypename '(' parmlist_or_identifiers  %prec '.'
	| parm_declarator_starttypename '(' error ')'  %prec '.'
	| parm_declarator_starttypename array_declarator  %prec '.'
	| TYPENAME
	| OBJECTNAME
	;

parm_declarator_nostarttypename:
	  parm_declarator_nostarttypename '(' parmlist_or_identifiers  %prec '.'
/*	| parm_declarator_nostarttypename '(' error ')'  %prec '.' */
	| parm_declarator_nostarttypename array_declarator  %prec '.'
	| '*' maybe_type_quals_attrs parm_declarator_starttypename  %prec UNARY
	| '*' maybe_type_quals_attrs parm_declarator_nostarttypename  %prec UNARY
	| '(' maybe_attribute parm_declarator_nostarttypename ')'
	;

/* A declarator allowed whether or not there has been
   an explicit typespec.  These cannot redeclare a typedef-name.  */

notype_declarator:
	  notype_declarator '(' parmlist_or_identifiers  %prec '.'
/*	| notype_declarator '(' error ')'  %prec '.' */
	| '(' maybe_attribute notype_declarator ')'
	| '*' maybe_type_quals_attrs notype_declarator  %prec UNARY
	| notype_declarator array_declarator  %prec '.'
	| IDENTIFIER
	;

struct_head:
	  STRUCT
	| STRUCT attributes
	;

union_head:
	  UNION
	| UNION attributes
	;

enum_head:
	  ENUM
	| ENUM attributes
	;

/* structsp_attr: struct/union/enum specifiers that either
   end with attributes, or are such that any following attributes would
   be parsed as part of the struct/union/enum specifier.

   structsp_nonattr: other struct/union/enum specifiers.  */

structsp_attr:
	  struct_head identifier '{'
	  component_decl_list '}' maybe_attribute
	| struct_head '{' component_decl_list '}' maybe_attribute
	| union_head identifier '{'
	  component_decl_list '}' maybe_attribute
	| union_head '{' component_decl_list '}' maybe_attribute
	| enum_head identifier '{'
	  enumlist maybecomma_warn '}' maybe_attribute
	| enum_head '{'
	  enumlist maybecomma_warn '}' maybe_attribute
	;

structsp_nonattr:
	  struct_head identifier
	| union_head identifier
	| enum_head identifier
	;

maybecomma:
	  .
	| ','
	;

maybecomma_warn:
	  .
	| ','
	;

component_decl_list:
	  component_decl_list2
	| component_decl_list2 component_decl
	;

component_decl_list2:	.
	| component_decl_list2 component_decl ';'
	| component_decl_list2 ';'
	| DEFS '(' CLASSNAME ')'
	;

component_decl:
	  declspecs_nosc_ts setspecs components
	| declspecs_nosc_ts setspecs save_filename save_lineno
	| declspecs_nosc_nots setspecs components_notype
	| declspecs_nosc_nots
	| error
	| extension component_decl
	;

components:
	  component_declarator
	| components ',' maybe_resetattrs component_declarator
	;

components_notype:
	  component_notype_declarator
	| components_notype ',' maybe_resetattrs component_notype_declarator
	;

component_declarator:
	  save_filename save_lineno declarator maybe_attribute
	| save_filename save_lineno
	  declarator ':' expr_no_commas maybe_attribute
	| save_filename save_lineno ':' expr_no_commas maybe_attribute
	;

component_notype_declarator:
	  save_filename save_lineno notype_declarator maybe_attribute
	| save_filename save_lineno
	  notype_declarator ':' expr_no_commas maybe_attribute
	| save_filename save_lineno ':' expr_no_commas maybe_attribute
	;

/* We chain the enumerators in reverse order.
   They are put in forward order where enumlist is used.
   (The order used to be significant, but no longer is so.
   However, we still maintain the order, just to be clean.)  */

enumlist:
	  enumerator
	| enumlist ',' enumerator
	| error
	;


enumerator:
	  identifier
	| identifier '=' expr_no_commas
	;

typename:
	  declspecs_nosc
	  absdcl
	;

absdcl:   /* an absolute declarator */
	.
	| absdcl1
	;

absdcl_maybe_attribute:   /* absdcl maybe_attribute, but not just attributes */
	.
	| absdcl1
	| absdcl1_noea attributes
	;

absdcl1:  /* a nonempty absolute declarator */
	  absdcl1_ea
	| absdcl1_noea
	;

absdcl1_noea:
	  direct_absdcl1
	| '*' maybe_type_quals_attrs absdcl1_noea
	;

absdcl1_ea:
	  '*' maybe_type_quals_attrs
	| '*' maybe_type_quals_attrs absdcl1_ea
	;

direct_absdcl1:
	  '(' maybe_attribute absdcl1 ')'
	| direct_absdcl1 '(' parmlist
	| direct_absdcl1 array_declarator
	| '(' parmlist
	| array_declarator
	;

/* The [...] part of a declarator for an array type.  */

array_declarator:
	'[' maybe_type_quals_attrs expr ']'
	| '[' maybe_type_quals_attrs ']'
	| '[' maybe_type_quals_attrs '*' ']'
	| '[' STATIC maybe_type_quals_attrs expr ']'
	/* declspecs_nosc_nots is a synonym for type_quals_attrs.  */
	| '[' declspecs_nosc_nots STATIC expr ']'
	;

/* A nonempty series of declarations and statements (possibly followed by
   some labels) that can form the body of a compound statement.
   NOTE: we don't allow labels on declarations; this might seem like a
   natural extension, but there would be a conflict between attributes
   on the label and prefix attributes on the declaration.  */

stmts_and_decls:
	  lineno_stmt_decl_or_labels_ending_stmt
	| lineno_stmt_decl_or_labels_ending_decl
	| lineno_stmt_decl_or_labels_ending_label
	| lineno_stmt_decl_or_labels_ending_error
	;

lineno_stmt_decl_or_labels_ending_stmt:
	  lineno_stmt
	| lineno_stmt_decl_or_labels_ending_stmt lineno_stmt
	| lineno_stmt_decl_or_labels_ending_decl lineno_stmt
	| lineno_stmt_decl_or_labels_ending_label lineno_stmt
	| lineno_stmt_decl_or_labels_ending_error lineno_stmt
	;

lineno_stmt_decl_or_labels_ending_decl:
	  lineno_decl
	| lineno_stmt_decl_or_labels_ending_stmt lineno_decl
	| lineno_stmt_decl_or_labels_ending_decl lineno_decl
	| lineno_stmt_decl_or_labels_ending_error lineno_decl
	;

lineno_stmt_decl_or_labels_ending_label:
	  lineno_label
	| lineno_stmt_decl_or_labels_ending_stmt lineno_label
	| lineno_stmt_decl_or_labels_ending_decl lineno_label
	| lineno_stmt_decl_or_labels_ending_label lineno_label
	| lineno_stmt_decl_or_labels_ending_error lineno_label
	;

lineno_stmt_decl_or_labels_ending_error:
	errstmt
	| lineno_stmt_decl_or_labels errstmt
	;

lineno_stmt_decl_or_labels:
	  lineno_stmt_decl_or_labels_ending_stmt
	| lineno_stmt_decl_or_labels_ending_decl
	| lineno_stmt_decl_or_labels_ending_label
	| lineno_stmt_decl_or_labels_ending_error
	;

errstmt:  error ';'
	;

pushlevel:  .
	;

poplevel:  .
        ;

/* Start and end blocks created for the new scopes of C99.  */
c99_block_start: .
	;

/* Productions using c99_block_start and c99_block_end will need to do what's
   in compstmt: RECHAIN_STMTS ($1, COMPOUND_BODY ($1)); $$ = $2; where
   $1 is the value of c99_block_start and $2 of c99_block_end.  */
c99_block_end: .
	;

/* Read zero or more forward-declarations for labels
   that nested functions can jump to.  */
maybe_label_decls:
	  .
	| label_decls
	;

label_decls:
	  label_decl
	| label_decls label_decl
	;

label_decl:
	  LABEL identifiers_or_typenames ';'
	;

/* This is the body of a function definition.
   It causes syntax errors to ignore to the next openbrace.  */
compstmt_or_error:
	  compstmt
	| error compstmt
	;

compstmt_start: '{' 
        ;

compstmt_nostart: '}'
	| pushlevel maybe_label_decls compstmt_contents_nonempty '}' poplevel
	;

compstmt_contents_nonempty:
	  stmts_and_decls
	| error
	;

compstmt_primary_start:
	'(' '{'
        ;

compstmt: compstmt_start compstmt_nostart
	;

/* Value is number of statements counted as of the closeparen.  */
simple_if:
	  if_prefix c99_block_lineno_labeled_stmt
/* Make sure c_expand_end_cond is run once
   for each call to c_expand_start_cond.
   Otherwise a crash is likely.  */
	| if_prefix error
	;

if_prefix:
	  /* We must build the IF_STMT node before parsing its
	     condition so that STMT_LINENO refers to the line
	     containing the "if", and not the line containing
	     the close-parenthesis.

	     c_begin_if_stmt returns the IF_STMT node, which
	     we later pass to c_expand_start_cond to fill
	     in the condition and other tidbits.  */
          IF '(' expr ')'
        ;

/* This is a subroutine of stmt.
   It is used twice, once for valid DO statements
   and once for catching errors in parsing the end test.  */
do_stmt_start:
	  DO
	  c99_block_lineno_labeled_stmt WHILE
	;

/* The forced readahead in here is because we might be at the end of a
   line, and the line and file won't be bumped until yylex absorbs the
   first token on the next line.  */
save_filename:	.
	;

save_lineno:	.
	;

lineno_labeled_stmt:
	  lineno_stmt
	| lineno_label lineno_labeled_stmt
	;

/* Like lineno_labeled_stmt, but a block in C99.  */
c99_block_lineno_labeled_stmt:
	  c99_block_start lineno_labeled_stmt c99_block_end
	;

lineno_stmt:
	  save_filename save_lineno stmt
	;

lineno_label:
	  save_filename save_lineno label
	;

select_or_iter_stmt:
	  simple_if ELSE
	| simple_if %prec IF
/* Make sure c_expand_end_cond is run once
   for each call to c_expand_start_cond.
   Otherwise a crash is likely.  */
	| simple_if ELSE error
       /* We must build the WHILE_STMT node before parsing its
	  condition so that STMT_LINENO refers to the line
	  containing the "while", and not the line containing
	  the close-parenthesis.

	  c_begin_while_stmt returns the WHILE_STMT node, which
	  we later pass to c_finish_while_stmt_cond to fill
	  in the condition and other tidbits.  */
	| WHILE
	  '(' expr ')'
	  c99_block_lineno_labeled_stmt
	| do_stmt_start
	  '(' expr ')' ';'
	| do_stmt_start error
	| FOR
	  '(' for_init_stmt
	  xexpr ';'
	  xexpr ')'
	  c99_block_lineno_labeled_stmt
	| SWITCH '(' expr ')'
	  c99_block_lineno_labeled_stmt
	;

for_init_stmt:
	  xexpr ';'
	| decl
	;

/* Parse a single real statement, not including any labels.  */
stmt:
	  compstmt
	| expr ';'
	| c99_block_start select_or_iter_stmt c99_block_end
	| BREAK ';'
	| CONTINUE ';'
	| RETURN ';'
	| RETURN expr ';'
	| ASM_KEYWORD maybe_type_qual '(' expr ')' ';'
	/* This is the case with just output operands.  */
	| ASM_KEYWORD maybe_type_qual '(' expr ':' asm_operands ')' ';'
	/* This is the case with input operands as well.  */
	| ASM_KEYWORD maybe_type_qual '(' expr ':' asm_operands ':'
	  asm_operands ')' ';'
	/* This is the case with clobbered registers as well.  */
	| ASM_KEYWORD maybe_type_qual '(' expr ':' asm_operands ':'
  	  asm_operands ':' asm_clobbers ')' ';'
	| GOTO identifier ';'
	| GOTO '*' expr ';'
	| ';'
	;

/* Any kind of label, including jump labels and case labels.
   ANSI C accepts labels only before statements, but we allow them
   also at the end of a compound statement.  */

label:	  CASE expr_no_commas ':'
	| CASE expr_no_commas ELLIPSIS expr_no_commas ':'
	| DEFAULT ':'
	| identifier save_filename save_lineno ':' maybe_attribute
	;

/* Either a type-qualifier or nothing.  First thing in an `asm' statement.  */

maybe_type_qual:
	.
	| TYPE_QUAL
	;

xexpr:
	.
	| expr
	;

/* These are the operands other than the first string and colon
   in  asm ("addextend %2,%1": "=dm" (x), "0" (y), "g" (*x))  */
asm_operands: .
	| nonnull_asm_operands
	;

nonnull_asm_operands:
	  asm_operand
	| nonnull_asm_operands ',' asm_operand
	;

asm_operand:
	  STRING '(' expr ')'
	| '[' identifier ']' STRING '(' expr ')'
	;

asm_clobbers	:	STRING	
			|	asm_clobbers ',' STRING
			;

/* This is what appears inside the parens in a function declarator.
   Its value is a list of ..._TYPE nodes.  Attributes must appear here
   to avoid a conflict with their appearance after an open parenthesis
   in an abstract declarator, as in
   "void bar (int (__attribute__((__mode__(SI))) int foo));".  */
parmlist:
	  maybe_attribute
	  parmlist_1
	;

parmlist_1:
	  parmlist_2 ')'
	| parms ';'
	  maybe_attribute
	  parmlist_1
	| error ')'
	;

/* This is what appears inside the parens in a function declarator.
   Is value is represented in the format that grokdeclarator expects.  */
parmlist_2:  .
	| ELLIPSIS
		  /* Gcc used to allow this as an extension.  However, it does
		     not work for all targets, and thus has been disabled.
		     Also, since func (...) and func () are indistinguishable,
		     it caused problems with the code in expand_builtin which
		     tries to verify that BUILT_IN_NEXT_ARG is being used
		     correctly.  */
	| parms
	| parms ',' ELLIPSIS
	;

parms:
	firstparm
	| parms ',' parm
	;

/* A single parameter declaration or parameter type name,
   as found in a parmlist.  */
parm:
	  declspecs_ts setspecs parm_declarator maybe_attribute
	| declspecs_ts setspecs notype_declarator maybe_attribute
	| declspecs_ts setspecs absdcl_maybe_attribute
	| declspecs_nots setspecs notype_declarator maybe_attribute
	| declspecs_nots setspecs absdcl_maybe_attribute
	;

/* The first parm, which must suck attributes from off the top of the parser
   stack.  */
firstparm:
	  declspecs_ts_nosa setspecs_fp parm_declarator maybe_attribute
	| declspecs_ts_nosa setspecs_fp notype_declarator maybe_attribute
	| declspecs_ts_nosa setspecs_fp absdcl_maybe_attribute
	| declspecs_nots_nosa setspecs_fp notype_declarator maybe_attribute
	| declspecs_nots_nosa setspecs_fp absdcl_maybe_attribute
	;

setspecs_fp:
	  setspecs
	;

/* This is used in a function definition
   where either a parmlist or an identifier list is ok.
   Its value is a list of ..._TYPE nodes or a list of identifiers.  */
parmlist_or_identifiers:
	  maybe_attribute
	  parmlist_or_identifiers_1
	;

parmlist_or_identifiers_1:
	  parmlist_1
	| identifiers ')'
	;

/* A nonempty list of identifiers.  */
identifiers:
	IDENTIFIER
	| identifiers ',' IDENTIFIER
	;

/* A nonempty list of identifiers, including typenames.  */
identifiers_or_typenames:
	identifier
	| identifiers_or_typenames ',' identifier
	;


extension	:	EXTENSION
		;

/* Objective-C productions.  */

objcdef:
	  classdef
	| classdecl
	| aliasdecl
	| protocoldef
	| methoddef
	| END
	;

/* A nonempty list of identifiers.  */
identifier_list:
	identifier
	| identifier_list ',' identifier
	;

classdecl:
	  CLASS identifier_list ';'
	;

aliasdecl:
	  ALIAS identifier identifier ';'
	;

classdef:
	  INTERFACE identifier protocolrefs '{'
	  ivar_decl_list '}'
	  methodprotolist
	  END
	| INTERFACE identifier protocolrefs
	  methodprotolist
	  END
	| INTERFACE identifier ':' identifier protocolrefs '{'
	  ivar_decl_list '}'
	  methodprotolist
	  END
	| INTERFACE identifier ':' identifier protocolrefs
	  methodprotolist
	  END
	| IMPLEMENTATION identifier '{'
	  ivar_decl_list '}'
	| IMPLEMENTATION identifier
	| IMPLEMENTATION identifier ':' identifier '{'
	  ivar_decl_list '}'
	| IMPLEMENTATION identifier ':' identifier
	| INTERFACE identifier '(' identifier ')' protocolrefs
	  methodprotolist
	  END
	| IMPLEMENTATION identifier '(' identifier ')'
	;

protocoldef:
	  PROTOCOL identifier protocolrefs
	  methodprotolist END
	/* The @protocol forward-declaration production introduces a
	   reduce/reduce conflict on ';', which should be resolved in
	   favor of the production 'identifier_list -> identifier'.  */
	| PROTOCOL identifier_list ';'
	;

protocolrefs:
	  .
	| non_empty_protocolrefs
	;

non_empty_protocolrefs:
	  ARITHCOMPARE identifier_list ARITHCOMPARE
	;

ivar_decl_list:
          ivar_decl_list visibility_spec ivar_decls
        | ivar_decls
        ;

visibility_spec:
	  PRIVATE
	| PROTECTED
	| PUBLIC
	;

ivar_decls:
          .
	| ivar_decls ivar_decl ';'
	| ivar_decls ';'
	;


/* There is a shift-reduce conflict here, because `components' may
   start with a `typename'.  It happens that shifting (the default resolution)
   does the right thing, because it treats the `typename' as part of
   a `typed_typespecs'.

   It is possible that this same technique would allow the distinction
   between `notype_initdecls' and `initdecls' to be eliminated.
   But I am being cautious and not trying it.  */

ivar_decl:
	declspecs_nosc_ts setspecs ivars
	| declspecs_nosc_nots setspecs ivars
	| error
	;

ivars:
	  .
	| ivar_declarator
	| ivars ',' maybe_resetattrs ivar_declarator
	;

ivar_declarator:
	  declarator
	| declarator ':' expr_no_commas
	| ':' expr_no_commas
	;

methodtype: '+' | '-'
	;

methoddef:
	  methodtype
	  methoddecl
	  optarglist
	  compstmt_or_error
	;

/* the reason for the strange actions in this rule
 is so that notype_initdecls when reached via datadef
 can find a valid list of type and sc specs in $0. */

methodprotolist:	.
	|  methodprotolist2
	;

methodprotolist2:		 /* eliminates a shift/reduce conflict */
	   methodproto
	|  datadef
	| methodprotolist2 methodproto
	| methodprotolist2  datadef
	;

semi_or_error:
	  ';'
	| error
	;

methodproto:
	  methodtype
	  methoddecl
	  semi_or_error
	;

methoddecl:
	  '(' typename ')' unaryselector
	| unaryselector
	| '(' typename ')' keywordselector optparmlist
	| keywordselector optparmlist
	;

/* "optarglist" assumes that start_method_def has already been called...
   if it is not, the "xdecls" will not be placed in the proper scope */

optarglist:
	  .
	| ';' myxdecls
	;

/* to get around the following situation: "int foo (int a) int b; {}" that
   is synthesized when parsing "- a:a b:b; id c; id d; { ... }" */

myxdecls:
	  .
	| mydecls
	;

mydecls:
	mydecl
	| errstmt
	| mydecls mydecl
	| mydecl errstmt
	;

mydecl:
	declspecs_ts setspecs myparms ';'
	| declspecs_ts ';'
	| declspecs_nots ';'
	;

myparms:
	myparm
	| myparms ',' myparm
	;

/* A single parameter declaration or parameter type name,
   as found in a parmlist. DOES NOT ALLOW AN INITIALIZER OR ASMSPEC */

myparm:
	  parm_declarator maybe_attribute
	| notype_declarator maybe_attribute
	| absdcl_maybe_attribute
	;

optparmlist	:	.
			|	',' ELLIPSIS
			|	',' parmlist_2
			;

unaryselector:
	  selector
	;

keywordselector:
	  keyworddecl

	| keywordselector keyworddecl
	;

selector:
	  IDENTIFIER
	| TYPENAME
	| CLASSNAME
	| OBJECTNAME
	| reservedwords
	;

reservedwords:
	  ENUM | STRUCT	| UNION	| IF | ELSE | WHILE | DO | FOR
	| SWITCH | CASE | DEFAULT | BREAK | CONTINUE | RETURN
	| GOTO | ASM_KEYWORD | SIZEOF | TYPEOF | ALIGNOF
	| TYPESPEC | TYPE_QUAL
	;

keyworddecl:
	  selector ':' '(' typename ')' identifier
	| selector ':' identifier
	| ':' '(' typename ')' identifier
	| ':' identifier
	;

messageargs:
	  selector
        | keywordarglist
	;

keywordarglist:
	  keywordarg
	| keywordarglist keywordarg
	;


keywordexpr:
	  nonnull_exprlist
	;

keywordarg:
	  selector ':' keywordexpr
	| ':' keywordexpr
	;

receiver:
	  expr
	| CLASSNAME
	;

objcmessageexpr:
	  '[' receiver messageargs ']'
	;

selectorarg:
	  selector
        | keywordnamelist
	;

keywordnamelist:
	  keywordname
	| keywordnamelist keywordname
	;

keywordname:
	  selector ':'
	| ':'
	;

objcselectorexpr:
	  SELECTOR '(' selectorarg ')'
	;

objcprotocolexpr:
	  PROTOCOL '(' identifier ')'
	;

/* extension to support C-structures in the archiver */

objcencodeexpr:
	  ENCODE '(' typename ')'
	;
















%name	delim 			:	"[ \r\n\t]"			
				;
%name	comment		:	"/\*([^\*]|\*+[^\*/])*\*+/"	
				;
%name	comment_line	:	"//[^\n]*\n"			
				;
%name	digit			:	"[0-9]"				
				;
%name	number			:	"{digit}+"				
				;
%name	letter			:	"[A-Z_a-z]"
				;



%name hex_digit		:	"[0-9a-fA-F]"
				;

%name hex_literal 	:	"0(x|X){hex_digit}+"
				;


%name dec_literal	:	"(0|[1-9][0-9]*)"
				;




%name skip_lexem	: 	"{delim}|{comment}|{comment_line}"
				;

/*  '"'  == \x22,  '\'' == \x27 */

%name	escape_seq		:	"(\\(\x22|\x27))"	
				;

%name	string_dq		: 	"(\x22({escape_seq}|[^\x22])*\x22)"		//只提取"..."或"\""此类串，其它词法规则要到语义例程中处理	
				;

%name	string_sq		:	"\x27({escape_seq}|[^\x27])*\x27"		//提取'...'或'\''此类串，其它词法规则要到语义例程中处理	
				;

%name string_literal	:	"{string_sq}|{string_dq}"
				;

%token %skip 		:	"{delim}+|{comment}+|{comment_line}+"		,1		%value	"TOK_DELIM_ID"		;



			


/*
由于引擎本身的算法原因，必须把相同前缀最长的匹配的优先级提到最高，例如匹配
"=" 和"=="，需要把==的优先级设置到大于"="才可以正常匹配
*/


//%token	HEX_CONSTANT	:	"{hex_literal}(?!{keyword_lhd})"			,2	%value "TOK_HEX_CONSTANT"		;
//%token	DEC_CONSTANT	:	"{dec_literal}(?!{keyword_lhd})"			,1	%value "TOK_DEC_CONSTANT"		;

%token	NUMBER		:	"({hex_literal}|{dec_literal})(?!{keyword_lhd})"	,2	%value "TOK_NUMBER"	;


%token	STRING_LITERAL	:	"{string_literal}"					%value "TOK_STRING_LITERAL"	;	
%token	IDENTIFIER		:	"{letter}({letter}|{digit})*"			%value "TOK_IDENTIFIER"		;


%name		keyword_lhd	:	"[A-Z_a-z0-9]"														;




%token	"switch"	:	'"switch"(?!{keyword_lhd})'	,1					%value 	"TOK_SWITCH"		;//SWITCH
%token	"for"		:	'"for"(?!{keyword_lhd})'		,1				%value		"TOK_FOR"			;//FOR

%token	"return"	:	'"return"(?!{keyword_lhd})'	,1					%value	"TOK_RETURN"		;//RETURN
%token	"do"		:	'"do"(?!{keyword_lhd})'		,1					%value	"TOK_DO"			;//DO
%token	"while"	:	'"while"(?!{keyword_lhd})'		,1					%value	"TOK_WHILE"		;//WHILE
%token	"if"		:	'"if"(?!{keyword_lhd})'		,1					%value	"TOK_IF"			;//IF
%token	"else"		:	'"else"(?!{keyword_lhd})'		,1					%value	"TOK_ELSE"			;//ELSE



%token	"true"		:	'"true"(?!{keyword_lhd})'		,1					%value	"TOK_TRUE"			;
%token	"false"	:	'"false"(?!{keyword_lhd})'		,1					%value	"TOK_FALSE"		;
%token	"this"		:	'"this"(?!{keyword_lhd})'		,1					%value	"TOK_THIS"			;

%token	"null"		:	'"null"(?!{keyword_lhd})'		,1					%value	"TOK_NULL"			;
%token	"const"	:	'"const"(?!{keyword_lhd})'		,1					%value	"TOK_CONST"		;
%token	"in"		:	'"in"(?!{keyword_lhd})'		,1					%value	"TOK_IN"			;
%token	"new"		:	'"new"(?!{keyword_lhd})'		,1					%value	"TOK_NEW"			;
%token	"delete"	:	'"delete"(?!{keyword_lhd})'		,1				%value	"TOK_DELETE"		;
%token	"typeof"	:	'"typeof"(?!{keyword_lhd})'		,1				%value	"TOK_TYPEOF"		;
%token	"function"	:	'"function"(?!{keyword_lhd})'		,1				%value	"TOK_FUNCTION"		;
%token	"var"		:	'"var"(?!{keyword_lhd})'			,1				%value	"TOK_VAR"			;
%token	"with"	:	'"with"(?!{keyword_lhd})'			,1				%value	"TOK_WITH"			;
%token	"instanceof"	:	'"instanceof"(?!{keyword_lhd})'		,1			%value	"TOK_INSTANCEOF"	;
%token	"debugger"	:	'"debugger"(?!{keyword_lhd})'		,1			%value	"TOK_DEBUGGER"	;
%token	"try"		:	'"try"(?!{keyword_lhd})'		,1					%value	"TOK_TRY"			;
%token	"catch"	:	'"catch"(?!{keyword_lhd})'		,1					%value	"TOK_CATCH"		;
%token	"finally"	:	'"finally"(?!{keyword_lhd})'	,1					%value	"TOK_FINALLY"		;
%token	"throw"	:	'"throw"(?!{keyword_lhd})'		,1					%value	"TOK_THROW"		;


%token	"continue"	:	'"continue"(?!{keyword_lhd})'	,1					%value	"TOK_CONTINUE"		;//CONTINUE
%token	"default"	:	'"default"(?!{keyword_lhd})'	,1					%value	"TOK_DEFAULT"		;//DEFAULT
%token	"case"		:	'"case"(?!{keyword_lhd})'		,1					%value	"TOK_CASE"			;//CASE
%token	"break"	:	'"break"(?!{keyword_lhd})'		,1					%value	"TOK_BREAK"		;//BREAK





%token	"void"	:	'"void"(?!{keyword_lhd})'		,1					%value	"TOK_VOID"			;//VOID




%token	">>="		:	'">>="'		,2								%value	"TOK_RIGHT_ASSIGN"	;//RIGHT_ASSIGN
%token	"<<="		:	'"<<="'		,2								%value	"TOK_LEFT_ASSIGN"	;//LEFT_ASSIGN


%token	">>>="	:	'">>>="'		,3								%value	"TOK_UNSIGNED_RIGHT_ASSIGN"	;

%token	">>>"		:	'">>>"'		,2								%value	"TOK_UNSIGNED_RIGHT"			;

%token	"==="		:	'"==="'		,2								%value	"TOK_STRICT_EQ_OP"			;
%token	"!=="		:	'"!=="'		,2								%value	"TOK_STRICT_NE_OP"			;






%token	"+="		:	'"+="'		,1								%value	"TOK_ADD_ASSIGN"	;//ADD_ASSIGN
%token	"-="		:	'"-="'		,1								%value	"TOK_SUB_ASSIGN"	;//SUB_ASSIGN
%token	"*="		:	'"*="'		,1								%value	"TOK_MUL_ASSIGN"	;//MUL_ASSIGN
%token	"/="		:	'"/="'		,1								%value	"TOK_DIV_ASSIGN"	;//DIV_ASSIGN
%token	"%="		:	'"%="'		,1								%value	"TOK_MOD_ASSIGN"	;//MOD_ASSIGN
%token	"&="		:	'"&="'		,1								%value	"TOK_AND_ASSIGN"	;//AND_ASSIGN

%token	"^="		:	'"^="'		,1								%value	"TOK_XOR_ASSIGN"	;//XOR_ASSIGN
%token	"|="		:	'"|="'		,1								%value	"TOK_OR_ASSIGN"		;//OR_ASSIGN
%token	">>"		:	'">>"'		,1								%value	"TOK_RIGHT_OP"		;//RIGHT_OP
%token	"<<"		:	'"<<"'		,1								%value	"TOK_LEFT_OP"		;//LEFT_OP
%token	"++"		:	'"++"'		,1								%value	"TOK_INC_OP"		;//INC_OP
%token	"--"		:	'"--"'		,1								%value	"TOK_DEC_OP"		;//DEC_OP



%token	"&&"		:	'"&&"'		,1								%value	"TOK_AND_OP"		;//AND_OP
%token	"||"		:	'"||"'		,1								%value	"TOK_OR_OP"		;//OR_OP

%token	"<="		:	'"<="'		,1								%value 	"TOK_LE_OP"		;//LE_OP
%token	">="		:	'">="'		,1								%value 	"TOK_GE_OP"		;//GE_OP
%token	"=="		:	'"=="'		,1								%value 	"TOK_EQ_OP"		;//EQ_OP
%token	"!="		:	'"!="'		,1								%value	"TOK_NE_OP"		;//NE_OP
%token	"<"		:	'"<"'		,0								%value	"TOK_LESS_OP"		;//<
%token	">"		:	'">"'		,0								%value	"TOK_GREATER_OP"	;//>



%token	";"		:	'";"'		,0								%value "TOK_SEMICOLON"			;//;
%token	"{"		:	'"{"'		,0								%value "TOK_L_BRACES"			;//{
%token	"}"		:	'"}"'		,0								%value "TOK_R_BRACES"			;//}
%token	","		:	'","'		,0								%value "TOK_COMMA"				;//,
%token	":"		:	'":"'		,0								%value "TOK_COLON"				;//:
%token	"="		:	'"="'		,0								%value "TOK_ASSIGN"				;//=
%token	"("		:	'"("'		,0								%value "TOK_L_PAREN"				;//(
%token	")"		:	'")"'		,0								%value "TOK_R_PAREN"				;//)
%token	"["		:	'"["'		,0								%value "TOK_L_SQUARE"			;//[
%token	"]"		:	'"]"'		,0								%value "TOK_R_SQUARE"			;//]
%token	"."		:	'"."'		,0								%value "TOK_DOT"				;//.
%token	"&"		:	'"&"'		,0								%value "TOK_AND"				;//&
%token	"!"		:	'"!"'		,0								%value "TOK_NOT"				;//!
%token	"~"		:	'"~"'		,0								%value "TOK_TILDE"				;//~
%token	"+"		:	'"+"'		,0								%value "TOK_ADD"				;//+
%token	"-"		:	'"-"'		,0								%value "TOK_SUB"				;//-
%token	"*"		:	'"*"'		,0								%value "TOK_MUL"				;//*
%token	"/"		:	'"/"'		,0								%value "TOK_DIV"				;///
%token	"%"		:	'"%"'		,0								%value "TOK_MOD"				;//%

%token	"^"		:	'"^"'		,0								%value "TOK_XOR"				;//^
%token	"|"		:	'"|"'		,0								%value "TOK_OR"					;//|
%token	"?"		:	'"?"'		,0								%value "TOK_QUEST"				;//?




%nonassoc IF_WITHOUT_ELSE	;
%nonassoc "else"		;


%start	Program		;

Literal	:	"null"
  		|	"true"
  		|	"false"
		| 	NUMBER
  		| 	STRING_LITERAL
		;

Property	:    IDENTIFIER 	":"	AssignmentExpr 	
		|	STRING_LITERAL	":"	AssignmentExpr
		|	NUMBER 		":"	AssignmentExpr
		|	IDENTIFIER IDENTIFIER "(" ")" "{" 	FunctionBody 	"}"
		|	IDENTIFIER IDENTIFIER "(" FormalParameterList ")" 	"{" FunctionBody "}"
		;


PropertyList	:	Property
  			|	PropertyList "," Property
			;

PrimaryExpr	:	PrimaryExprNoBrace
  			|	"{" 	"}"
  			|	"{" PropertyList "}"
  			|	"{" PropertyList "," "}"
			;


PrimaryExprNoBrace	:   "this"
  				|	Literal
  				|	ArrayLiteral
				|	IDENTIFIER
  				|	"("	Expr	")"
				;

ArrayLiteral		:    	"[" ElisionOpt "]"
  			|	"[" ElementList "]" 
  			|	"[" ElementList "," ElisionOpt "]"
			;

ElementList		:	ElisionOpt AssignmentExpr
  			|	ElementList "," ElisionOpt AssignmentExpr
			;

ElisionOpt		:	.
  			|	Elision
			;

Elision		:	","                                 
  			| 	Elision ","                         
			;


MemberExpr		:	PrimaryExpr
  			|	FunctionExpr                        
  			|	MemberExpr "[" Expr "]"             
  			|	MemberExpr "." IDENTIFIER         
  			|	"new" MemberExpr Arguments     
			;

MemberExprNoBF	:	PrimaryExprNoBrace
  			|	MemberExprNoBF "[" Expr "]"  
  			|	MemberExprNoBF "." IDENTIFIER     
  			|	"new" MemberExpr Arguments     
			;

NewExpr		:    MemberExpr
  			|	"new"	NewExpr 
			;

NewExprNoBF	:	MemberExprNoBF
	 		|	"new" NewExpr         
			;

CallExpr		:	MemberExpr Arguments      
  			|	CallExpr Arguments        
  			|	CallExpr "[" Expr "]"     
  			|	CallExpr "." IDENTIFIER        
			;

CallExprNoBF	:	MemberExprNoBF Arguments     
			|	CallExprNoBF Arguments       
  			|	CallExprNoBF "[" Expr "]"    
			|	CallExprNoBF "." IDENTIFIER  
			;

Arguments		:	"(" ")"                   
  			|	"(" ArgumentList ")"      
			;

ArgumentList		:	AssignmentExpr            
  			|	ArgumentList "," AssignmentExpr 
			;

LeftHandSideExpr	:	NewExpr
  			|	CallExpr
			;

LeftHandSideExprNoBF	:	NewExprNoBF
  				|	CallExprNoBF
				;

PostfixExpr		:	LeftHandSideExpr
  				|	LeftHandSideExpr "++"
  				|	LeftHandSideExpr "--"
				;

PostfixExprNoBF		:	LeftHandSideExprNoBF
  				|	LeftHandSideExprNoBF "++"
  				|	LeftHandSideExprNoBF "--"
				;

UnaryExprCommon		:	"delete" UnaryExpr            
  				|	"void" UnaryExpr          
  				|	"typeof" UnaryExpr             
  				|	"++" UnaryExpr           
  				|	"--" UnaryExpr       
  				|	"+" UnaryExpr              
  				|	"-" UnaryExpr              
  				|	"~" UnaryExpr              
  				|	"!" UnaryExpr
//  | AUTOMINUSMINUS UnaryExpr   
//  | AUTOPLUSPLUS UnaryExpr     
				;

UnaryExpr			:	PostfixExpr
  				|	UnaryExprCommon
				;

UnaryExprNoBF		:	PostfixExprNoBF
  				|	UnaryExprCommon
				;

MultiplicativeExpr	:    UnaryExpr
  				|	MultiplicativeExpr "*" UnaryExpr 
  				|	MultiplicativeExpr "/" UnaryExpr 
  				|	MultiplicativeExpr "%" UnaryExpr 
				;

MultiplicativeExprNoBF:    UnaryExprNoBF
  				|	MultiplicativeExprNoBF "*" UnaryExpr
                     	|	MultiplicativeExprNoBF "/" UnaryExpr
  				|	MultiplicativeExprNoBF "%" UnaryExpr
				;

AdditiveExpr		:    MultiplicativeExpr
  				|	AdditiveExpr "+" MultiplicativeExpr
  				| 	AdditiveExpr "-" MultiplicativeExpr
				;

AdditiveExprNoBF	:	MultiplicativeExprNoBF
  				|	AdditiveExprNoBF "+" MultiplicativeExpr
  				| 	AdditiveExprNoBF "-" MultiplicativeExpr
				;

ShiftExpr			:	AdditiveExpr
  				|	ShiftExpr "<<"	AdditiveExpr    
  				|	ShiftExpr ">>"	AdditiveExpr    
  				|	ShiftExpr ">>>"	AdditiveExpr   
				;

ShiftExprNoBF		:    AdditiveExprNoBF
  				|	ShiftExprNoBF "<<" AdditiveExpr
  				|	ShiftExprNoBF ">>" AdditiveExpr
  				|	ShiftExprNoBF ">>>" AdditiveExpr
				;

RelationalExpr		:    ShiftExpr
  				|	RelationalExpr "<" ShiftExpr      
  				|	RelationalExpr ">" ShiftExpr      
  				|	RelationalExpr "<=" ShiftExpr       
  				|	RelationalExpr ">=" ShiftExpr       
	 			|	RelationalExpr "instanceof" ShiftExpr 
				|	RelationalExpr "in"	ShiftExpr    
				;

RelationalExprNoIn	:    ShiftExpr
  				|	RelationalExprNoIn "<" ShiftExpr    
  				|	RelationalExprNoIn ">" ShiftExpr    
  				|	RelationalExprNoIn "<=" ShiftExpr     
  				|	RelationalExprNoIn ">=" ShiftExpr     
  				|	RelationalExprNoIn "instanceof" ShiftExpr
				;

RelationalExprNoBF	:    ShiftExprNoBF
  				|	RelationalExprNoBF "<" ShiftExpr   
  				|	RelationalExprNoBF ">" ShiftExpr   
  				|	RelationalExprNoBF "<=" ShiftExpr    
  				|	RelationalExprNoBF ">=" ShiftExpr    
  				|	RelationalExprNoBF "instanceof" ShiftExpr
	 			|	RelationalExprNoBF "in" ShiftExpr 
				;

EqualityExpr		:	RelationalExpr
  				|	EqualityExpr "==" RelationalExpr  
  				|	EqualityExpr "!=" RelationalExpr    
  				|	EqualityExpr "===" RelationalExpr 
  				|	EqualityExpr "!==" RelationalExpr
				;

EqualityExprNoIn	:	RelationalExprNoIn
  				|	EqualityExprNoIn "==" RelationalExprNoIn
  				|	EqualityExprNoIn "!=" RelationalExprNoIn
				|	EqualityExprNoIn "===" RelationalExprNoIn
       			|	EqualityExprNoIn "!==" RelationalExprNoIn
				;

EqualityExprNoBF	:    RelationalExprNoBF
  				|	EqualityExprNoBF "==" RelationalExpr
  				| 	EqualityExprNoBF "!=" RelationalExpr  
  				|	EqualityExprNoBF "===" RelationalExpr
  				|	EqualityExprNoBF "!==" RelationalExpr
				;

BitwiseANDExpr		:	EqualityExpr
  				| 	BitwiseANDExpr "&" EqualityExpr     
				;

BitwiseANDExprNoIn:
    EqualityExprNoIn
  | BitwiseANDExprNoIn "&" EqualityExprNoIn
;

BitwiseANDExprNoBF:
    EqualityExprNoBF
  | BitwiseANDExprNoBF "&" EqualityExpr 
;

BitwiseXORExpr:
    BitwiseANDExpr
  | BitwiseXORExpr "^" BitwiseANDExpr   
;

BitwiseXORExprNoIn:
    BitwiseANDExprNoIn
  | BitwiseXORExprNoIn "^" BitwiseANDExprNoIn
                                        
;

BitwiseXORExprNoBF:
    BitwiseANDExprNoBF
  | BitwiseXORExprNoBF "^" BitwiseANDExpr
                                        
;

BitwiseORExpr:
    BitwiseXORExpr
  | BitwiseORExpr "|" BitwiseXORExpr    
;

BitwiseORExprNoIn:
    BitwiseXORExprNoIn
  | BitwiseORExprNoIn "|" BitwiseXORExprNoIn
                                        
;

BitwiseORExprNoBF:
    BitwiseXORExprNoBF
  | BitwiseORExprNoBF "|" BitwiseXORExpr
                                        
;

LogicalANDExpr:
    BitwiseORExpr
  | LogicalANDExpr "&&" BitwiseORExpr    
;

LogicalANDExprNoIn:
    BitwiseORExprNoIn
  | LogicalANDExprNoIn "&&" BitwiseORExprNoIn
                                        
;

LogicalANDExprNoBF:
    BitwiseORExprNoBF
  | LogicalANDExprNoBF "&&" BitwiseORExpr
                                        
;

LogicalORExpr:
    LogicalANDExpr
  | LogicalORExpr "||" LogicalANDExpr     
;

LogicalORExprNoIn:
    LogicalANDExprNoIn
  | LogicalORExprNoIn "||" LogicalANDExprNoIn
                                        
;

LogicalORExprNoBF:
    LogicalANDExprNoBF
  | LogicalORExprNoBF "||" LogicalANDExpr 
;

ConditionalExpr:
    LogicalORExpr
  | LogicalORExpr "?" AssignmentExpr ":" AssignmentExpr
                                        
;

ConditionalExprNoIn:
    LogicalORExprNoIn
  | LogicalORExprNoIn "?" AssignmentExprNoIn ":" AssignmentExprNoIn
                                        
;

ConditionalExprNoBF:
    LogicalORExprNoBF
  | LogicalORExprNoBF "?" AssignmentExpr ":" AssignmentExpr
                                        
;

AssignmentExpr:
    ConditionalExpr
  | LeftHandSideExpr AssignmentOperator AssignmentExpr
                                        
;

AssignmentExprNoIn	:	ConditionalExprNoIn
  				|	LeftHandSideExpr AssignmentOperator AssignmentExprNoIn
				;


AssignmentExprNoBF:
    ConditionalExprNoBF
  | LeftHandSideExprNoBF AssignmentOperator AssignmentExpr
	;

AssignmentOperator	:    "="                                
  				|	"+="                          
  				|	"-="
  				|	"*="
  				|	"/="
  				|	"<<="
  				|	">>="
  				| ">>>="
  				| "&="
  				| "^="
  				| "|="
  				| "%="
;

Expr:
    AssignmentExpr
  | Expr "," AssignmentExpr            
;

ExprNoIn:
    AssignmentExprNoIn
  | ExprNoIn "," AssignmentExprNoIn    
;

ExprNoBF:
    AssignmentExprNoBF
  | ExprNoBF "," AssignmentExpr        
;

Statement:
    Block
  | VariableStatement
  | ConstStatement
  | FunctionDeclaration
  | EmptyStatement
  | ExprStatement
  | IfStatement
  | IterationStatement
  | ContinueStatement
  | BreakStatement
  | ReturnStatement
  | WithStatement
  | SwitchStatement
  | LabelledStatement
  | ThrowStatement
  | TryStatement
  | DebuggerStatement
;

Block:
    "{" "}"               
  | "{" SourceElements "}"
;

VariableStatement:
    "var" VariableDeclarationList ";"    
  | "var" VariableDeclarationList error  
;

VariableDeclarationList:
    IDENTIFIER                               
  | IDENTIFIER Initializer                   
  | VariableDeclarationList "," IDENTIFIER
                                        
  | VariableDeclarationList "," IDENTIFIER Initializer
                                        
;

VariableDeclarationListNoIn:
    IDENTIFIER                               
  | IDENTIFIER InitializerNoIn               
  | VariableDeclarationListNoIn "," IDENTIFIER
                                        
  | VariableDeclarationListNoIn "," IDENTIFIER InitializerNoIn
                                        
;

ConstStatement	:    "const" ConstDeclarationList ";" 
  			|	"const" ConstDeclarationList error
			;


ConstDeclarationList	:	ConstDeclaration                    
  				|	ConstDeclarationList "," ConstDeclaration
				;

ConstDeclaration:
    IDENTIFIER                               
  | IDENTIFIER Initializer                   
;

Initializer:
    "=" AssignmentExpr                  
;

InitializerNoIn:
    "=" AssignmentExprNoIn              
;

EmptyStatement:
    ";"                                 
;

ExprStatement:
    ExprNoBF ";"                        
  | ExprNoBF error                      
;

IfStatement	:	"if" "(" Expr ")" Statement %prec IF_WITHOUT_ELSE
  			|	"if" "(" Expr ")" Statement "else" Statement
			;

IterationStatement:
    "do" Statement "while" "(" Expr ")" ";"    
  | "do" Statement "while" "(" Expr ")" error   // Always performs automatic semicolon insertion.
  | "while" "(" Expr ")" Statement        
  | "for" "(" ExprNoInOpt ";" ExprOpt ";" ExprOpt ")" Statement
                                        
  | "for" "(" "var" VariableDeclarationListNoIn ";" ExprOpt ";" ExprOpt ")" Statement
                                        
  | "for" "(" LeftHandSideExpr "in" Expr ")" Statement
                                        
  | "for" "(" "var" IDENTIFIER "in" Expr ")" Statement
                                        
  | "for" "(" "var" IDENTIFIER InitializerNoIn "in" Expr ")" Statement
                                        
;

ExprOpt	:	.
  		|	Expr
		;

ExprNoInOpt	:	.
  			|	ExprNoIn
			;

ContinueStatement:
    "continue" ";"                        
  | "continue" error                      
  | "continue" IDENTIFIER ";"                  
  | "continue" IDENTIFIER error                
;

BreakStatement:
    "break" ";"                           
  | "break" error                         
  | "break" IDENTIFIER ";"                     
  | "break" IDENTIFIER error                   
;

ReturnStatement:
    "return" ";"                          
  | "return" error                        
  | "return" Expr ";"                     
  | "return" Expr error                   
;

WithStatement:
    "with" "(" Expr ")" Statement         
;

SwitchStatement:
    "switch" "(" Expr ")" CaseBlock       
;

CaseBlock:
    "{" CaseClausesOpt "}"              
  | "{" CaseClausesOpt DefaultClause CaseClausesOpt "}"
                                        
;

CaseClausesOpt	:	.                         
  			|	CaseClauses
			;


CaseClauses:
    CaseClause                          
  | CaseClauses CaseClause              
;

CaseClause:
    "case" Expr ":"                       
  | "case" Expr ":" SourceElements        
;

DefaultClause:
    "default" ":"                         
  | "default" ":" SourceElements          
;

LabelledStatement:
    IDENTIFIER ":" Statement                 
;

ThrowStatement:
    "throw" Expr ";"                      
  | "throw" Expr error                    
;

TryStatement:
    "try" Block "finally" Block             
  | "try" Block "catch" "(" IDENTIFIER ")" Block 
  | "try" Block "catch" "(" IDENTIFIER ")" Block "finally" Block
                                        
;

DebuggerStatement:
    "debugger" ";"                        
  | "debugger" error                      
;

FunctionDeclaration:
    "function" IDENTIFIER "(" ")" "{" FunctionBody "}" 
  | "function" IDENTIFIER "(" FormalParameterList ")" "{" FunctionBody "}"
      
;

FunctionExpr:
    "function" "(" ")" "{" FunctionBody "}" 
    | "function" "(" FormalParameterList ")" "{" FunctionBody "}"
      
  | "function" IDENTIFIER "(" ")" "{" FunctionBody "}" 
  | "function" IDENTIFIER "(" FormalParameterList ")" "{" FunctionBody "}"
      
;

FormalParameterList:
    IDENTIFIER                               
  | FormalParameterList "," IDENTIFIER       
;

FunctionBody	:	.
  			|	SourceElements_NoNode               
			;

Program		:	.
    			|	SourceElements                    
			;

SourceElements:
    Statement                           
  | SourceElements Statement            
;
 


// Start NoNodes

Literal_NoNode	:    "null"
		  	|	"true"
  			|	"false"
			|	NUMBER
  			|	STRING_LITERAL 
			;

Property_NoNode	:    IDENTIFIER ":" AssignmentExpr_NoNode 
  			|	STRING_LITERAL ":" AssignmentExpr_NoNode 
  			|	NUMBER ":" AssignmentExpr_NoNode 
  			|	IDENTIFIER IDENTIFIER "(" ")" "{" FunctionBody_NoNode "}" 
  			|	IDENTIFIER IDENTIFIER "(" FormalParameterList_NoNode ")" "{" FunctionBody_NoNode "}" 
;

PropertyList_NoNode:
    Property_NoNode
  | PropertyList_NoNode "," Property_NoNode
;

PrimaryExpr_NoNode:
    PrimaryExprNoBrace_NoNode
  | "{" "}" 
  | "{" PropertyList_NoNode "}" 
  | "{" PropertyList_NoNode "," "}" 
;

PrimaryExprNoBrace_NoNode:
    "this"
  | Literal_NoNode
  | ArrayLiteral_NoNode
  | IDENTIFIER 
  | "(" Expr_NoNode ")"
;

ArrayLiteral_NoNode:
    "[" ElisionOpt_NoNode "]"
  | "[" ElementList_NoNode "]"
  | "[" ElementList_NoNode "," ElisionOpt_NoNode "]"
;

ElementList_NoNode:
    ElisionOpt_NoNode AssignmentExpr_NoNode
  | ElementList_NoNode "," ElisionOpt_NoNode AssignmentExpr_NoNode
;

ElisionOpt_NoNode	:	.
  				|	Elision_NoNode
				;

Elision_NoNode:
    ","
  | Elision_NoNode ","
;

MemberExpr_NoNode:
    PrimaryExpr_NoNode
  | FunctionExpr_NoNode
  | MemberExpr_NoNode "[" Expr_NoNode "]"
  | MemberExpr_NoNode "." IDENTIFIER
  | "new" MemberExpr_NoNode Arguments_NoNode
;

MemberExprNoBF_NoNode:
    PrimaryExprNoBrace_NoNode
  | MemberExprNoBF_NoNode "[" Expr_NoNode "]"
  | MemberExprNoBF_NoNode "." IDENTIFIER
  | "new" MemberExpr_NoNode Arguments_NoNode
;

NewExpr_NoNode:
    MemberExpr_NoNode
  | "new" NewExpr_NoNode
;

NewExprNoBF_NoNode:
    MemberExprNoBF_NoNode
  | "new" NewExpr_NoNode
;

CallExpr_NoNode:
    MemberExpr_NoNode Arguments_NoNode
  | CallExpr_NoNode Arguments_NoNode
  | CallExpr_NoNode "[" Expr_NoNode "]"
  | CallExpr_NoNode "." IDENTIFIER
;

CallExprNoBF_NoNode:
    MemberExprNoBF_NoNode Arguments_NoNode
  | CallExprNoBF_NoNode Arguments_NoNode
  | CallExprNoBF_NoNode "[" Expr_NoNode "]"
  | CallExprNoBF_NoNode "." IDENTIFIER
;

Arguments_NoNode:
    "(" ")"
  | "(" ArgumentList_NoNode ")"
;

ArgumentList_NoNode:
    AssignmentExpr_NoNode
  | ArgumentList_NoNode "," AssignmentExpr_NoNode
;

LeftHandSideExpr_NoNode:
    NewExpr_NoNode
  | CallExpr_NoNode
;

LeftHandSideExprNoBF_NoNode:
    NewExprNoBF_NoNode
  | CallExprNoBF_NoNode
;

PostfixExpr_NoNode:
    LeftHandSideExpr_NoNode
  | LeftHandSideExpr_NoNode "++"
  | LeftHandSideExpr_NoNode "--"
;

PostfixExprNoBF_NoNode:
    LeftHandSideExprNoBF_NoNode
  | LeftHandSideExprNoBF_NoNode "++"
  | LeftHandSideExprNoBF_NoNode "--"
;

UnaryExprCommon_NoNode:
    "delete" UnaryExpr_NoNode
  | "void" UnaryExpr_NoNode
  | "typeof" UnaryExpr_NoNode
  | "++" UnaryExpr_NoNode
  | "--" UnaryExpr_NoNode
  | "+" UnaryExpr_NoNode
  | "-" UnaryExpr_NoNode
  | "~" UnaryExpr_NoNode
  | "!" UnaryExpr_NoNode
;

UnaryExpr_NoNode:
    PostfixExpr_NoNode
  | UnaryExprCommon_NoNode
;

UnaryExprNoBF_NoNode:
    PostfixExprNoBF_NoNode
  | UnaryExprCommon_NoNode
;

MultiplicativeExpr_NoNode:
    UnaryExpr_NoNode
  | MultiplicativeExpr_NoNode "*" UnaryExpr_NoNode
  | MultiplicativeExpr_NoNode "/" UnaryExpr_NoNode
  | MultiplicativeExpr_NoNode "%" UnaryExpr_NoNode
;

MultiplicativeExprNoBF_NoNode:
    UnaryExprNoBF_NoNode
  | MultiplicativeExprNoBF_NoNode "*" UnaryExpr_NoNode
  | MultiplicativeExprNoBF_NoNode "/" UnaryExpr_NoNode
  | MultiplicativeExprNoBF_NoNode "%" UnaryExpr_NoNode
;

AdditiveExpr_NoNode:
    MultiplicativeExpr_NoNode
  | AdditiveExpr_NoNode "+" MultiplicativeExpr_NoNode
  | AdditiveExpr_NoNode "-" MultiplicativeExpr_NoNode
;

AdditiveExprNoBF_NoNode:
    MultiplicativeExprNoBF_NoNode
  | AdditiveExprNoBF_NoNode "+" MultiplicativeExpr_NoNode
  | AdditiveExprNoBF_NoNode "-" MultiplicativeExpr_NoNode
;

ShiftExpr_NoNode:
    AdditiveExpr_NoNode
  | ShiftExpr_NoNode "<<" AdditiveExpr_NoNode
  | ShiftExpr_NoNode ">>" AdditiveExpr_NoNode
  | ShiftExpr_NoNode ">>>" AdditiveExpr_NoNode
;

ShiftExprNoBF_NoNode:
    AdditiveExprNoBF_NoNode
  | ShiftExprNoBF_NoNode "<<"	AdditiveExpr_NoNode
  | ShiftExprNoBF_NoNode ">>" AdditiveExpr_NoNode
  | ShiftExprNoBF_NoNode ">>>" AdditiveExpr_NoNode
;

RelationalExpr_NoNode:
    ShiftExpr_NoNode
  | RelationalExpr_NoNode "<" ShiftExpr_NoNode
  | RelationalExpr_NoNode ">" ShiftExpr_NoNode
  | RelationalExpr_NoNode "<=" ShiftExpr_NoNode
  | RelationalExpr_NoNode ">=" ShiftExpr_NoNode
  | RelationalExpr_NoNode "instanceof" ShiftExpr_NoNode
  | RelationalExpr_NoNode "in" ShiftExpr_NoNode
;

RelationalExprNoIn_NoNode:
    ShiftExpr_NoNode
  | RelationalExprNoIn_NoNode "<" ShiftExpr_NoNode
  | RelationalExprNoIn_NoNode ">" ShiftExpr_NoNode
  | RelationalExprNoIn_NoNode "<=" ShiftExpr_NoNode
  | RelationalExprNoIn_NoNode ">=" ShiftExpr_NoNode
  | RelationalExprNoIn_NoNode "instanceof" ShiftExpr_NoNode
;

RelationalExprNoBF_NoNode:
    ShiftExprNoBF_NoNode
  | RelationalExprNoBF_NoNode "<" ShiftExpr_NoNode
  | RelationalExprNoBF_NoNode ">" ShiftExpr_NoNode
  | RelationalExprNoBF_NoNode "<=" ShiftExpr_NoNode
  | RelationalExprNoBF_NoNode ">=" ShiftExpr_NoNode
  | RelationalExprNoBF_NoNode "instanceof" ShiftExpr_NoNode
  | RelationalExprNoBF_NoNode "in" ShiftExpr_NoNode
;

EqualityExpr_NoNode:
    RelationalExpr_NoNode
  | EqualityExpr_NoNode "==" RelationalExpr_NoNode
  | EqualityExpr_NoNode "!=" RelationalExpr_NoNode
  | EqualityExpr_NoNode "===" RelationalExpr_NoNode
  | EqualityExpr_NoNode "!==" RelationalExpr_NoNode
;

EqualityExprNoIn_NoNode:
    RelationalExprNoIn_NoNode
  | EqualityExprNoIn_NoNode "==" RelationalExprNoIn_NoNode
  | EqualityExprNoIn_NoNode "!=" RelationalExprNoIn_NoNode
  | EqualityExprNoIn_NoNode "===" RelationalExprNoIn_NoNode
  | EqualityExprNoIn_NoNode "!==" RelationalExprNoIn_NoNode
;

EqualityExprNoBF_NoNode:
    RelationalExprNoBF_NoNode
  | EqualityExprNoBF_NoNode "==" RelationalExpr_NoNode
  | EqualityExprNoBF_NoNode "!=" RelationalExpr_NoNode
  | EqualityExprNoBF_NoNode "===" RelationalExpr_NoNode
  | EqualityExprNoBF_NoNode "!==" RelationalExpr_NoNode
;

BitwiseANDExpr_NoNode:
    EqualityExpr_NoNode
  | BitwiseANDExpr_NoNode "&" EqualityExpr_NoNode
;

BitwiseANDExprNoIn_NoNode:
    EqualityExprNoIn_NoNode
  | BitwiseANDExprNoIn_NoNode "&" EqualityExprNoIn_NoNode
;

BitwiseANDExprNoBF_NoNode:
    EqualityExprNoBF_NoNode
  | BitwiseANDExprNoBF_NoNode "&" EqualityExpr_NoNode
;

BitwiseXORExpr_NoNode:
    BitwiseANDExpr_NoNode
  | BitwiseXORExpr_NoNode "^" BitwiseANDExpr_NoNode
;

BitwiseXORExprNoIn_NoNode:
    BitwiseANDExprNoIn_NoNode
  | BitwiseXORExprNoIn_NoNode "^" BitwiseANDExprNoIn_NoNode
;

BitwiseXORExprNoBF_NoNode:
    BitwiseANDExprNoBF_NoNode
  | BitwiseXORExprNoBF_NoNode "^" BitwiseANDExpr_NoNode
;

BitwiseORExpr_NoNode:
    BitwiseXORExpr_NoNode
  | BitwiseORExpr_NoNode "|" BitwiseXORExpr_NoNode
;

BitwiseORExprNoIn_NoNode:
    BitwiseXORExprNoIn_NoNode
  | BitwiseORExprNoIn_NoNode "|" BitwiseXORExprNoIn_NoNode
;

BitwiseORExprNoBF_NoNode:
    BitwiseXORExprNoBF_NoNode
  | BitwiseORExprNoBF_NoNode "|" BitwiseXORExpr_NoNode
;

LogicalANDExpr_NoNode:
    BitwiseORExpr_NoNode
  | LogicalANDExpr_NoNode "&&" BitwiseORExpr_NoNode
;

LogicalANDExprNoIn_NoNode:
    BitwiseORExprNoIn_NoNode
  | LogicalANDExprNoIn_NoNode "&&" BitwiseORExprNoIn_NoNode
;

LogicalANDExprNoBF_NoNode:
    BitwiseORExprNoBF_NoNode
  | LogicalANDExprNoBF_NoNode "&&" BitwiseORExpr_NoNode
;

LogicalORExpr_NoNode:
    LogicalANDExpr_NoNode
  | LogicalORExpr_NoNode "||" LogicalANDExpr_NoNode
;

LogicalORExprNoIn_NoNode:
    LogicalANDExprNoIn_NoNode
  | LogicalORExprNoIn_NoNode "||" LogicalANDExprNoIn_NoNode
;

LogicalORExprNoBF_NoNode:
    LogicalANDExprNoBF_NoNode
  | LogicalORExprNoBF_NoNode "||" LogicalANDExpr_NoNode
;

ConditionalExpr_NoNode:
    LogicalORExpr_NoNode
  | LogicalORExpr_NoNode "?" AssignmentExpr_NoNode ":" AssignmentExpr_NoNode
;

ConditionalExprNoIn_NoNode:
    LogicalORExprNoIn_NoNode
  | LogicalORExprNoIn_NoNode "?" AssignmentExprNoIn_NoNode ":" AssignmentExprNoIn_NoNode
;

ConditionalExprNoBF_NoNode:
    LogicalORExprNoBF_NoNode
  | LogicalORExprNoBF_NoNode "?" AssignmentExpr_NoNode ":" AssignmentExpr_NoNode
;

AssignmentExpr_NoNode:
    ConditionalExpr_NoNode
  | LeftHandSideExpr_NoNode AssignmentOperator_NoNode AssignmentExpr_NoNode
;

AssignmentExprNoIn_NoNode:
    ConditionalExprNoIn_NoNode
  | LeftHandSideExpr_NoNode AssignmentOperator_NoNode AssignmentExprNoIn_NoNode
;

AssignmentExprNoBF_NoNode:
    ConditionalExprNoBF_NoNode
  | LeftHandSideExprNoBF_NoNode AssignmentOperator_NoNode AssignmentExpr_NoNode
;

AssignmentOperator_NoNode	:	"="                                
  					|	"+="                          
  					|	"-="
  					|	"*="
  					|	"/="
  					|	"<<="
  					|	">>="
  					|	">>>="
  					|	"&="
  					|	"^="
  					|	"|="
  					|	"%="
					;

Expr_NoNode:
    AssignmentExpr_NoNode
  | Expr_NoNode "," AssignmentExpr_NoNode
;

ExprNoIn_NoNode:
    AssignmentExprNoIn_NoNode
  | ExprNoIn_NoNode "," AssignmentExprNoIn_NoNode
;

ExprNoBF_NoNode:
    AssignmentExprNoBF_NoNode
  | ExprNoBF_NoNode "," AssignmentExpr_NoNode
;

Statement_NoNode:
    Block_NoNode
  | VariableStatement_NoNode
  | ConstStatement_NoNode
  | FunctionDeclaration_NoNode
  | EmptyStatement_NoNode
  | ExprStatement_NoNode
  | IfStatement_NoNode
  | IterationStatement_NoNode
  | ContinueStatement_NoNode
  | BreakStatement_NoNode
  | ReturnStatement_NoNode
  | WithStatement_NoNode
  | SwitchStatement_NoNode
  | LabelledStatement_NoNode
  | ThrowStatement_NoNode
  | TryStatement_NoNode
  | DebuggerStatement_NoNode
;

Block_NoNode:
    "{" "}" 
  | "{" SourceElements_NoNode "}" 
;

VariableStatement_NoNode:
    "var" VariableDeclarationList_NoNode ";"
  | "var" VariableDeclarationList_NoNode error 
;

VariableDeclarationList_NoNode:
    IDENTIFIER 
  | IDENTIFIER Initializer_NoNode 
  | VariableDeclarationList_NoNode "," IDENTIFIER
  | VariableDeclarationList_NoNode "," IDENTIFIER Initializer_NoNode
;

VariableDeclarationListNoIn_NoNode:
    IDENTIFIER 
  | IDENTIFIER InitializerNoIn_NoNode 
  | VariableDeclarationListNoIn_NoNode "," IDENTIFIER
  | VariableDeclarationListNoIn_NoNode "," IDENTIFIER InitializerNoIn_NoNode
;

ConstStatement_NoNode:
    "const" ConstDeclarationList_NoNode ";"
  | "const" ConstDeclarationList_NoNode error 
;

ConstDeclarationList_NoNode:
    ConstDeclaration_NoNode
  | ConstDeclarationList_NoNode "," ConstDeclaration_NoNode
;

ConstDeclaration_NoNode:
    IDENTIFIER 
  | IDENTIFIER Initializer_NoNode 
;

Initializer_NoNode:
    "=" AssignmentExpr_NoNode
;

InitializerNoIn_NoNode:
    "=" AssignmentExprNoIn_NoNode
;

EmptyStatement_NoNode:
    ";"
;

ExprStatement_NoNode:
    ExprNoBF_NoNode ";"
  | ExprNoBF_NoNode error 
;

IfStatement_NoNode:
    "if" "(" Expr_NoNode ")" Statement_NoNode %prec IF_WITHOUT_ELSE
  | "if" "(" Expr_NoNode ")" Statement_NoNode "else" Statement_NoNode
;

IterationStatement_NoNode:
    "do" Statement_NoNode "while" "(" Expr_NoNode ")" ";"
  | "do" Statement_NoNode "while" "(" Expr_NoNode ")" error // Always performs automatic semicolon insertion
  | "while" "(" Expr_NoNode ")" Statement_NoNode
  | "for" "(" ExprNoInOpt_NoNode ";" ExprOpt_NoNode ";" ExprOpt_NoNode ")" Statement_NoNode
  | "for" "(" "var" VariableDeclarationListNoIn_NoNode ";" ExprOpt_NoNode ";" ExprOpt_NoNode ")" Statement_NoNode
  | "for" "(" LeftHandSideExpr_NoNode "in" Expr_NoNode ")" Statement_NoNode
  | "for" "(" "var" IDENTIFIER "in" Expr_NoNode ")" Statement_NoNode
  | "for" "(" "var" IDENTIFIER InitializerNoIn_NoNode "in" Expr_NoNode ")" Statement_NoNode
;

ExprOpt_NoNode	:	.
  			|	Expr_NoNode
			;

ExprNoInOpt_NoNode	:	.
  				|	ExprNoIn_NoNode
				;

ContinueStatement_NoNode:
    "continue" ";"
  | "continue" error 
  | "continue" IDENTIFIER ";"
  | "continue" IDENTIFIER error 
;

BreakStatement_NoNode:
    "break" ";"
  | "break" error 
  | "break" IDENTIFIER ";"
  | "break" IDENTIFIER error 
;

ReturnStatement_NoNode:
    "return" ";"
  | "return" error 
  | "return" Expr_NoNode ";"
  | "return" Expr_NoNode error 
;

WithStatement_NoNode:
    "with" "(" Expr_NoNode ")" Statement_NoNode
;

SwitchStatement_NoNode:
    "switch" "(" Expr_NoNode ")" CaseBlock_NoNode
;

CaseBlock_NoNode:
    "{" CaseClausesOpt_NoNode "}" 
  | "{" CaseClausesOpt_NoNode DefaultClause_NoNode CaseClausesOpt_NoNode "}" 
;

CaseClausesOpt_NoNode	:	.
	 				|	CaseClauses_NoNode
					;


CaseClauses_NoNode:
    CaseClause_NoNode
  | CaseClauses_NoNode CaseClause_NoNode
;

CaseClause_NoNode:
    "case" Expr_NoNode ":"
  | "case" Expr_NoNode ":" SourceElements_NoNode
;

DefaultClause_NoNode:
    "default" ":"
  | "default" ":" SourceElements_NoNode
;

LabelledStatement_NoNode:
    IDENTIFIER ":" Statement_NoNode 
;

ThrowStatement_NoNode:
    "throw" Expr_NoNode ";"
  | "throw" Expr_NoNode error 
;

TryStatement_NoNode:
    "try" Block_NoNode "finally" Block_NoNode
  | "try" Block_NoNode "catch" "(" IDENTIFIER ")" Block_NoNode
  | "try" Block_NoNode "catch" "(" IDENTIFIER ")" Block_NoNode "finally" Block_NoNode
;

DebuggerStatement_NoNode:
    "debugger" ";"
  | "debugger" error 
;



FunctionDeclaration_NoNode:
    "function" IDENTIFIER "(" ")" "{" FunctionBody_NoNode "}"
  | "function" IDENTIFIER "(" FormalParameterList_NoNode ")" "{" FunctionBody_NoNode "}"
;

FunctionExpr_NoNode	:    "function" "(" ")" "{" FunctionBody_NoNode "}"
  			|	"function" "(" FormalParameterList_NoNode ")" "{" FunctionBody_NoNode "}"
			|	"function" IDENTIFIER "(" ")" "{" FunctionBody_NoNode "}"
			|	"function" IDENTIFIER "(" FormalParameterList_NoNode ")" "{" FunctionBody_NoNode "}"
			;

FormalParameterList_NoNode:
    IDENTIFIER 
  | FormalParameterList_NoNode "," IDENTIFIER
;

FunctionBody_NoNode	:	.
  				|	SourceElements_NoNode
				;



SourceElements_NoNode	:    	Statement_NoNode
				|	SourceElements_NoNode Statement_NoNode
				;







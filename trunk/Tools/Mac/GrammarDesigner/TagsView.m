/* * Copyright (c) 2011 by Solidus * This file is part of Arsenal library tools source code. * * Permission to use, copy, modify, distribute and sell this software * and its documentation for any purpose is hereby granted without fee, * provided that the above copyright notice appear in all copies and * that both that copyright notice and this permission notice appear * in supporting documentation.It is provided "as is" without express  * or implied warranty. * */#import "TagsView.h"@implementation TagsItemInfo@synthesize		name;@synthesize		line;@synthesize		isRefreshed;+(id)TagsItemWithName : (NSString*)n Line : (int)l{		TagsItemInfo *info = [[TagsItemInfo alloc] initWithName : n														   Line : l							  ];						[info autorelease];		return info;							  }-(id)init{		self = [super init];		if(self)		{				name = [NSString stringWithString : @""];				line = -1;				isRefreshed = NO;		}		return self;}-(id)initWithName : (NSString*)n Line : (int)l{		assert(n != nil);		self = [super init];		if(self)		{				[n retain];				name = n;				line = l;		}		return self;}-(void)dealloc{		[name release];		name = nil;		[super dealloc];}@end@implementation TagsView-(void)resetFont{		NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];				NSString *name;		NSInteger size;						name = [defaults stringForKey : PREFERENCE_FONT_TAGS_NAME];		size = (NSInteger)[defaults doubleForKey : PREFERENCE_FONT_TAGS_SIZE];				[font release];		font = [NSFont fontWithName : name							   size : size				];				[font retain];				[self setFont : font];}-(void)handleFontChanged : (NSNotification*)note{		DLog(@"TagsView::handleFontChanged for notification %@", note);		[self resetFont];		}-(void)awakeFromNib{		nameSet = [[NSMutableArray alloc] init];		termSet = [[NSMutableArray alloc] init];		precSet = [[NSMutableArray alloc] init];		ruleSet = [[NSMutableArray alloc] init];		predefSet = [[NSMutableArray alloc] init];		actionSet  = [[NSMutableArray alloc] init];				NSNotificationCenter *nc = [NSNotificationCenter defaultCenter];		[nc addObserver : self			   selector : @selector(handleFontChanged:)				   name : NOTIFICATION_PREFERENCE_FONT_CHANGED				 object : nil		 ];				[self setDataSource : self];		[self resetFont];				}-(void)dealloc{		NSNotificationCenter *nc = [NSNotificationCenter defaultCenter];		[nc removeObserver : self];				[nameSet release];		[termSet release];		[precSet release];		[ruleSet release];		[predefSet release];		[actionSet release];						[font release];		font = nil;		[super dealloc];}-(BOOL)isRootItem : (id)item{		if(item == nil || item == nameSet || item == termSet || item == precSet || item == ruleSet || item == predefSet || item == actionSet)		{				return YES;		}else		{				return NO;		}}-(id)getRootItem : (int)idx{		switch(idx)		{				case 0:						return nameSet;				case 1: 						return termSet;				case 2:						return precSet;				case 3:						return ruleSet;				case 4:						return predefSet;				case 5:						return actionSet;				default:						return nil;		}}-(NSString*)getRootItemName : (id)item{		NSString *ret = nil;				if(item == nameSet)		{				ret = [NSString stringWithFormat : @"Name(%d)", [nameSet count]];						}else if(item == termSet)		{				ret = [NSString stringWithFormat : @"Term(%d)", [termSet count]];		}else if(item == precSet)		{				ret = [NSString stringWithFormat : @"Rule(%d)", [precSet count]];		}else if(item == ruleSet)		{				ret = [NSString stringWithFormat : @"Name(%d)", [ruleSet count]];		}else if(item == predefSet)		{				ret = [NSString stringWithFormat : @"PreDef(%d)", [predefSet count]];						}else if(item == actionSet)		{				ret = [NSString stringWithFormat : @"Action(%d)", [actionSet count]];		}else		{				ret = @"";		}		return ret;}-(NSInteger)outlineView:(NSOutlineView *)outlineView numberOfChildrenOfItem:(id)item{		return (item == nil) ? 6 : [item count];}-(BOOL)outlineView:(NSOutlineView *)outlineView isItemExpandable:(id)item {		if([self isRootItem : item])		{				if(item == nil)				{						return YES;				}								if([item count] > 0)				{						return YES;				}								return NO;		}else		{				return NO;		}}-(id)outlineView:(NSOutlineView *)outlineView child:(NSInteger)index ofItem:(id)item {		if(item == nil)		{				return [self getRootItem : index];		}else		{				return [item objectAtIndex : index];		}}-(id)outlineView:(NSOutlineView *)outlineView objectValueForTableColumn:(NSTableColumn *)tableColumn byItem:(id)item {		if([self isRootItem : item])		{				return [self getRootItemName :item];		}else		{				return [item name];		}}#if(0)void	CTagTree::update_table(CMapTable &src, LPCTSTR name, size_t line){		CString			key;		CSrcInfo		*val;				val = NULL;		if(src.Lookup(name, val))		{				ASSERT(val != NULL);								val->m_name = name;				val->m_line = line;				val->m_refreash = true;		}else		{				val = new CSrcInfo(name, line, NULL);				val->m_refreash = true;				src.SetAt(name, val);		}}#endif-(void)updateSet : (NSMutableArray*)set 			Name : (NSString*)name 			Line : (int)line{		size_t i;		assert(set != nil && name != nil && line >= 0);		const size_t count = [set count];				TagsItemInfo *info = nil;		for(i = 0; i < count; ++i)		{				info = [set objectAtIndex : i];				assert(info != nil);				if([info.name compare : name])				{						break;				}		}				if(info)		{				info.line = line;				info.isRefreshed = YES;		}else		{				TagsItemInfo *info = [TagsItemInfo TagsItemWithName : name															   Line : line									  ];								[set addObject : info];		}		}-(void)update : (const cfgConfig_t*)cfg{		}@end
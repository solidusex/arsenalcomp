/* * Copyright (c) 2011 by Solidus * This file is part of Arsenal library tools source code. * * Permission to use, copy, modify, distribute and sell this software * and its documentation for any purpose is hereby granted without fee, * provided that the above copyright notice appear in all copies and * that both that copyright notice and this permission notice appear * in supporting documentation.It is provided "as is" without express  * or implied warranty. * */#import "GrammarDesignerDocument.h"#import "GrammarCheckerTask.h"static void AR_STDCALL report_tag_func(const cfgReportInfo_t *report, void *context){		switch(report->type)		{				case CFG_REPORT_MESSAGE_T:						//AR_printf(L"%ls\r\n", report->message);						break;				case CFG_REPORT_ERROR_T:						//::AfxMessageBox(report->message);						//AR_printf(L"%ls : %d\r\n", report->message, report->err_level);						break;				case CFG_REPORT_ERROR_LEX_T:						//::AfxMessageBox(report->message);						//AR_printf(L"lex error %ls\r\n", report->message);						break;				case CFG_REPORT_ERROR_SYNTAX_T:						//::AfxMessageBox(report->message);						//AR_printf(L"syntax error %ls\r\n", report->message);						break;				case CFG_REPORT_WARNING_SYNTAX_T:						break;				default:						AR_ASSERT(false);		}}static cfgReport_t	__g_report = {report_tag_func, NULL};@implementation GrammarCheckTaskMessage@synthesize		parseResult;@synthesize		sourcesCode;-(id)init{		assert(NO);}-(id)initWithSources : (NSString*)src{		self = [super initWithName : nil];		if(self)		{				[src retain];				sourcesCode = src;				parseResult = NULL;		}		return self;}-(void)dealloc{		[sourcesCode release];		sourcesCode = nil;				if(parseResult)		{				CFG_DestroyGrammarConfig(parseResult);				parseResult = NULL;		}				[super dealloc];}-(void)run{		if([sourcesCode length] > 0)		{				wchar_t *tmp = [ARUtility convertNSStringToUTF32 : sourcesCode];				if(tmp == NULL)				{						DLog(@"GrammarCheckTaskMessage:[ARUtility convertNSStringToUTF32 : sourcesCode] failed");				}								parseResult = CFG_CollectGrammarConfig(tmp, &__g_report);		}else		{				parseResult = NULL;		}}@end/******************************************************************/@implementation GrammarCheckTask-(id)init{		assert(false);		return nil;}-(id)initWithDocument : (id)pdoc{		assert(pdoc != nil);		self = [super init];		if(self)		{				[pdoc retain];				grammarDocument = pdoc;		}				return self;		}-(void)dealloc{		if(grammarDocument != nil)		{				[grammarDocument release];				grammarDocument = nil;		}				[super dealloc];}-(void)onWorkerBegin{		DLog(@"GrammarCheckTask::onWorkerBegin");}-(void)onWorkerEnd{		DLog(@"GrammarCheckTask::onWorkerEnd");}-(void)handleWorkerThreadMessage : (ARDuplexTaskMessage*)msg forTask : (ARDuplexTask*)task{		assert(msg != nil && task != nil);		GrammarCheckTaskMessage *gmrMsg = (GrammarCheckTaskMessage*)msg;		DLog(@"GrammarCheckTask::handleWorkerThreadMessage : Sources == %@", gmrMsg.sourcesCode);		[gmrMsg run];		[task PostMsgToMain : msg];		}-(void)handleMainThreadMessage : (ARDuplexTaskMessage*)msg forTask : (ARDuplexTask*)task{		GrammarCheckTaskMessage *gmrMsg = (GrammarCheckTaskMessage*)msg;		DLog(@"GrammarCheckTask::handleMainThreadMessage : Sources == %@", gmrMsg.sourcesCode);		if(grammarDocument != nil)		{				[grammarDocument onGrammarCheckerCompleted : gmrMsg.parseResult];		}		[msg release];}@end
/* * Copyright (c) 2011 by Solidus * This file is part of Arsenal library tools source code. * * Permission to use, copy, modify, distribute and sell this software * and its documentation for any purpose is hereby granted without fee, * provided that the above copyright notice appear in all copies and * that both that copyright notice and this permission notice appear * in supporting documentation.It is provided "as is" without express  * or implied warranty. * */#import "GrammarDesignerDocument.h"@implementation GrammarDesignerDocument/****************************Internal************************/-(void)init_outlets{		DLog(@"GrammarDesignerDocument::init_outlets");		[consoleTabView selectTabViewItemAtIndex : 0];				[grammarTextView setString : grammarContent];		}-(void)load_default_config{		DLog(@"GrammarDesignerDocument::load_default_config");		NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];						NSInteger interval = (NSInteger)[defaults doubleForKey : PREFERENCE_BUILD_TAGS_INTERVAL];		[self on_reset_timer : interval];								NSInteger paser_mode = (NSInteger)[defaults doubleForKey : PREFERENCE_PARSER_MODE];		parserMode = (psrLRItemType_t)paser_mode;				lexIsSingleLine = [defaults boolForKey : PREFERENCE_LEX_IS_SINGLELINE];		lexIsIgnoreCase = [defaults boolForKey : PREFERENCE_LEX_IS_IGNORECASE];				}-(void)on_reset_timer : (NSInteger)milliseconds{		DLog(@"GrammarDesignerDocument::on_reset_timer");		if(grammarCheckTimer != nil)		{				[grammarCheckTimer invalidate];				//[grammarCheckTimer release];				grammarCheckTimer = nil;		}				if(milliseconds > 0)		{												grammarCheckTimer = [NSTimer scheduledTimerWithTimeInterval	 : (double)milliseconds / 1000.0																	  target : self																	selector : @selector(onGrammarChecker:)																	userInfo : nil																	 repeats : YES									 ];								//[grammarCheckTimer retain];										}		}/****************************Initialize************************/- (id)init{		DLog(@"GrammarDesignerDocument::init");		self = [super init];		if (self) {								grammarContent = [[NSString alloc] init];								NSNotificationCenter *nc = [NSNotificationCenter defaultCenter];				[nc addObserver : self					   selector : @selector(handleParserChanged:)						   name : NOTIFICATION_PREFERENCE_PARSER_CHANGED						 object : nil				 ];												[nc addObserver : self					   selector : @selector(handleFontChanged:)						   name : NOTIFICATION_PREFERENCE_FONT_CHANGED						 object : nil				 ];												[nc addObserver : self					   selector : @selector(handleLexerChanged:)						   name : NOTIFICATION_PREFERENCE_LEXER_CHANGED						 object : nil				 ];								[nc addObserver : self					   selector : @selector(handleApplicationChanged:)						   name : NOTIFICATION_PREFERENCE_APPLICATION_CHANGED						 object : nil				 ];																				grammarCheckerTaskDelegate = [[GrammarCheckTask alloc] initWithDocument : self];				grammarCheckerTask = [[ARDuplexTask alloc] init];				[grammarCheckerTask setDelegate : grammarCheckerTaskDelegate];				[grammarCheckerTask start];												[self load_default_config];														}		return self;}-(void)dealloc{		DLog(@"GrammarDesignerDocument::dealloc");		[self on_reset_timer : 0];				NSNotificationCenter *nc = [NSNotificationCenter defaultCenter];		[nc removeObserver : self];				[grammarContent release];		grammarContent = nil;						[super dealloc];}-(void)close{		DLog(@"GrammarDesignerDocument::close : doc retainCount %u", [self retainCount]);		[inputChecker release];		[self on_reset_timer : 0];				[grammarCheckerTask		stop];		[grammarCheckerTask		release];		grammarCheckerTask	= nil;		[grammarCheckerTaskDelegate release];		grammarCheckerTaskDelegate = nil;				[super close];}- (NSString *)windowNibName{		return @"GrammarDesignerDocument";}- (void)windowControllerDidLoadNib:(NSWindowController *) aController{		DLog(@"GrammarDesignerDocument::windowControllerDidLoadNib");		[super windowControllerDidLoadNib:aController];				[self init_outlets];						NSNotificationCenter *nc = [NSNotificationCenter defaultCenter];				[nc addObserver : self			   selector : @selector(handleMainWindowWillMiniaturize:)				   name : NSWindowWillMiniaturizeNotification				 object : mainWindow		 ];		[nc addObserver : self			   selector : @selector(handleMainWindowBecomeMain:)				   name : NSWindowDidBecomeMainNotification				 object : mainWindow		 ];						[nc addObserver : self			   selector : @selector(handleBuildParser:)				   name : NOTIFICATION_GRAMMARVIEW_INVOKE_BUILD_PARSER				 object : grammarTextView		 ];				[nc addObserver : self			   selector : @selector(handleFindAllReferences:)				   name : NOTIFICATION_GRAMMARVIEW_INVOKE_FIND_ALL_REFERENCES				 object : grammarTextView		 ];				[nc addObserver : self			   selector : @selector(handleGotoDeclaration:)				   name : NOTIFICATION_GRAMMARVIEW_INVOKE_GOTO_DECLARATION				 object : grammarTextView		 ];								[nc addObserver : self			   selector : @selector(handleShowActionTable:)				   name : NOTIFICATION_GRAMMARVIEW_INVOKE_SHOW_ACTION_TABLE				 object : grammarTextView		 ];				[nc addObserver : self			   selector : @selector(handleShowConflicts:)				   name : NOTIFICATION_GRAMMARVIEW_INVOKE_SHOW_CONFLICTS				 object : grammarTextView		 ];								[nc addObserver : self			   selector : @selector(handleShowFirstFollowSet:)				   name : NOTIFICATION_GRAMMARVIEW_INVOKE_SHOW_FIRSTFOLLOW_SET				 object : grammarTextView		 ];				[nc addObserver : self			   selector : @selector(handleShowLeftRecursive:)				   name : NOTIFICATION_GRAMMARVIEW_INVOKE_SHOW_LEFT_RECURSIVE				 object : grammarTextView		 ];				[nc addObserver : self			   selector : @selector(handleShowLeftFactor:)				   name : NOTIFICATION_GRAMMARVIEW_INVOKE_SHOW_LEFT_FACTOR				 object : grammarTextView		 ];						[nc addObserver : self			   selector : @selector(handleOutputRelocateText:)				   name : NOTIFICATION_OUTPUT_INVOKE_RELOCATE_TEXT				 object : outputView		 ];				[nc addObserver : self			   selector : @selector(handleFindResultsRelocateText:)				   name : NOTIFICATION_FINDRESULTS_INVOKE_RELOCATE_TEXT				 object : findResultsView		 ];		[nc addObserver : self			   selector : @selector(handleTagsViewRelocateText:)				   name : NOTIFICATION_TAGSVIEW_INVOKE_RELOCATE_TEXT				 object : tagsView		 ];										GrammarCheckTaskMessage *msg = [[GrammarCheckTaskMessage alloc] initWithSources : grammarContent];		[grammarCheckerTask PostMsgToWorker : msg];}- (NSData *)dataOfType:(NSString *)typeName error:(NSError **)outError{		DLog(@"GrammarDesignerDocument::dataOfType");				[grammarContent release];		grammarContent = [NSString stringWithString : [grammarTextView string]];		[grammarContent retain];				return [grammarContent dataUsingEncoding : NSUTF8StringEncoding];}- (BOOL)readFromData:(NSData *)data ofType:(NSString *)typeName error:(NSError **)outError{		BOOL ret = YES;				DLog(@"GrammarDesignerDocument::readFromData length == %d", [data length]);				if([data length] >= 1024 * 1024 * 10)		{				if(outError != NULL ) 				{						*outError = [NSError errorWithDomain:NSOSStatusErrorDomain code:unimpErr userInfo:NULL];				}												return NO;						}				size_t len = [data length];								arBuffer_t *buf = AR_CreateBuffer(len);		arString_t *str = AR_CreateString();		AR_InsertBuffer(buf, (const byte_t*)[data bytes], len);				if(AR_LoadBomTextFromBinary(buf, NULL, str))		{																NSString *tempStr = [ARUtility convertUTF32ToNSString : AR_GetStringCString(str)];				tempStr = [tempStr stringByReplacingOccurrencesOfString : @"\t" 															 withString : @"    "						   ];																[grammarContent release];				grammarContent = [NSString stringWithString : tempStr];				[grammarContent retain];								if(grammarTextView != nil)				{						[grammarTextView setString : grammarContent];				}								ret = YES;		}else		{				ret = NO;				if(outError != NULL ) 				{						*outError = [NSError errorWithDomain:NSOSStatusErrorDomain code:unimpErr userInfo:NULL];				}		}				AR_DestroyBuffer(buf);		AR_DestroyString(str);		buf = NULL;		str = NULL;				return ret;}/****************************Timer Callback************************/- (void)onGrammarChecker:(NSTimer*)theTimer{		DLog(@"GrammarDesignerDocument::onGrammarChecker for timer %@", theTimer);				NSString *newContent = [grammarTextView string];				if([grammarContent isEqualToString : newContent])		{				return;		}		[grammarContent release];		grammarContent = [NSString stringWithString : newContent];		[grammarContent retain];		if([grammarContent length] > 0)		{				GrammarCheckTaskMessage *msg = [[GrammarCheckTaskMessage alloc] initWithSources : grammarContent];				[grammarCheckerTask PostMsgToWorker : msg];		}		}-(void) onGrammarCheckerCompleted : (const cfgConfig_t*)parseResult{		DLog(@"GrammarDesignerDocument::onGrammarCheckerCompleted");		[tagsView update : parseResult];}/********************************************Notification*********************/-(void)handleFontChanged : (NSNotification*)note{		DLog(@"GrammarDesignerDocument::handleFontChanged for notification %@", note);				}-(void)handleLexerChanged : (NSNotification*)note{		DLog(@"GrammarDesignerDocument::handleLexerChanged for notification %@", note);				}-(void)handleParserChanged : (NSNotification*)note{		DLog(@"GrammarDesignerDocument::handleParserChanged for notification %@", note);				NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];		NSInteger interval = (NSInteger)[defaults doubleForKey : PREFERENCE_BUILD_TAGS_INTERVAL];		[self on_reset_timer : interval];		}-(void)handleApplicationChanged : (NSNotification*)note{		DLog(@"GrammarDesignerDocument::handleApplicationChanged for notification %@", note);		}-(void)handleMainWindowWillMiniaturize : (NSNotification*)note{		DLog(@"GrammarDesignerDocument::handleMainWindowMiniaturize for notification %@", note);		if(inputChecker != nil && [inputChecker isShow])		{				[inputChecker hide : self];				inputCheckerIsHide = YES;		}}-(void)handleMainWindowBecomeMain : (NSNotification*)note{		DLog(@"GrammarDesignerDocument::handleMainWindowBecomeMain for notification %@", note);		if(inputCheckerIsHide)		{				[inputChecker show : self];				inputCheckerIsHide = NO;		}}-(void)handleBuildParser : (NSNotification*)note{		DLog(@"GrammarDesignerDocument::handleBuildParser for notification %@", note);}-(void)handleFindAllReferences : (NSNotification*)note{		[findResultsView clear];		DLog(@"GrammarDesignerDocument::handleFindAllReferences for notification %@", note);			NSString *key = [[note userInfo] objectForKey:@"UserInfo"];				if(key == nil || [key length] == 0)		{				return;		}				wchar_t *wcs_key = [ARUtility convertNSStringToUTF32 : key];				if(wcs_key == NULL || wcslen(wcs_key) == 0)		{				return;		}				int find_cnt = 0;		NSString *src = [grammarTextView string];		if(src == nil || [src length] == 0)		{				return;		}				wchar_t *wcs_src = [ARUtility convertNSStringToUTF32 : src];				if(wcs_src == NULL || wcslen(wcs_src) == 0)		{				return;		}						const cfgLexicalSet_t *lx_set = CFG_CollectLexicalSet(wcs_src);						if(lx_set != NULL)		{								for(size_t i = 0; i < lx_set->cnt; ++i)				{						const lexToken_t *tok = &lx_set->token_set[i];												if(tok->count == 0 || tok->count != wcslen(wcs_key))						{								continue;						}						assert(tok->str != NULL);												if(wcsncmp(tok->str, wcs_key, tok->count) == 0)						{								NSString *msg = [NSString stringWithFormat : @"(Line : %u, Col : %u) : %@",												 (unsigned int)tok->line, 												 (unsigned int)tok->col, 												 [grammarTextView getLine : tok->line]												 												 ];																[findResultsView append :[ConsoleMessage consoleMessageWithType : CONSOLE_MSG_MESSAGE_T																							Msg : msg																						   Line : tok->line														  ]								 								 ];																find_cnt += 1;														}				}								CFG_DestroyLexicalSet(lx_set);				lx_set = NULL;		}				if(find_cnt <= 1)/*如果只找到一个词法值,则此词法值为当前词法值，启动全局搜索*/		{				[findResultsView clear];				NSArray *lines = nil;				lines = [grammarTextView getLines];								for(size_t i = 0; i < [lines count]; ++i)				{						NSString *line = [lines objectAtIndex : i];												NSRange range = [line rangeOfString : key];												if(range.location != NSNotFound && range.length > 0)						{								NSString *msg = [NSString stringWithFormat : @"(Line : %u) : %@",												 i,												 line												 ];																								[findResultsView append :[ConsoleMessage consoleMessageWithType : CONSOLE_MSG_MESSAGE_T																							Msg : msg																						   Line : i														  ]								 								 ];																find_cnt += 1;						}				}						}		if(find_cnt == 0)		{				[findResultsView append :[ConsoleMessage consoleMessageWithType : CONSOLE_MSG_MESSAGE_T																			Msg : @"Not found!"																		   Line : -1										  ]				 				 ];		}				[consoleTabView selectTabViewItemAtIndex : 1];}-(void)handleGotoDeclaration : (NSNotification*)note{		DLog(@"GrammarDesignerDocument::handleGotoDeclaration for notification %@", note);}-(void)handleShowActionTable : (NSNotification*)note{		DLog(@"GrammarDesignerDocument::handleShowActionTable for notification %@", note);}-(void)handleShowConflicts : (NSNotification*)note{		DLog(@"GrammarDesignerDocument::handleShowConflicts for notification %@", note);}-(void)handleShowFirstFollowSet : (NSNotification*)note{		DLog(@"GrammarDesignerDocument::handleShowFirstFollowSet for notification %@", note);}-(void)handleShowLeftRecursive : (NSNotification*)note{		DLog(@"GrammarDesignerDocument::handleShowLeftRecursive for notification %@", note);}-(void)handleShowLeftFactor : (NSNotification*)note{		DLog(@"GrammarDesignerDocument::handleShowLeftFactor for notification %@", note);}-(void)handleParseInput : (NSNotification*)note{		DLog(@"GrammarDesignerDocument::handleParseInput for notification %@", note);}-(void)handleOutputRelocateText : (NSNotification*)note{		DLog(@"GrammarDesignerDocument::handleOutputRelocateText for notification %@", note);				ConsoleMessage *msg = [[note userInfo] objectForKey:@"UserInfo"];				if(msg.line >= 0)		{				[grammarTextView selecteLine : msg.line ];		}		}-(void)handleFindResultsRelocateText : (NSNotification*)note{		DLog(@"GrammarDesignerDocument::handleOutputRelocateText for notification %@", note);				ConsoleMessage *msg = [[note userInfo] objectForKey:@"UserInfo"];				if(msg.line >= 0)		{				[grammarTextView selecteLine : msg.line ];		}}-(void)handleTagsViewRelocateText : (NSNotification*)note{		NSNumber *num = [[note userInfo] objectForKey:@"UserInfo"];		if(num != nil && [num intValue] >= 0)		{				[grammarTextView selecteLine : [num intValue]];		}}/***************************************************Action********************************/-(IBAction)setDocumentLexerSingleLine : (id)sender{		DLog(@"On GrammarDesignerDocument::setDocumentLexerSingleLine");		lexIsSingleLine = !lexIsSingleLine;}-(IBAction)setDocumentLexerIgnoreCase : (id)sender{		DLog(@"On GrammarDesignerDocument::setDocumentLexerIgnoreCase");		lexIsIgnoreCase = !lexIsIgnoreCase;}-(IBAction)setDocumentParserModeSLR : (id)sender{		DLog(@"On GrammarDesignerDocument::setDocumentParserModeSLR");		parserMode = PARSER_SLR;}-(IBAction)setDocumentParserModeLALR : (id)sender{		DLog(@"On GrammarDesignerDocument::setDocumentParserModeLALR");		parserMode = PARSER_LALR;}-(IBAction)buildDocumentParser	:	(id)sender{		DLog(@"On GrammarDesignerDocument::buildDocumentParser");}-(IBAction)rebuildDocumentTags	:	(id)sender{		DLog(@"On GrammarDesignerDocument::rebuildDocumentTags");}-(IBAction)generateDocumentGrammarTemplateCode : (id)sender{		DLog(@"On GrammarDesignerDocument::generateDocumentGrammarTemplateCode");		}-(IBAction)showInputChecker : (id)sender{		DLog(@"On GrammarDesignerDocument::showInputChecker");		BOOL need_register_notification = NO;		if(inputChecker == nil)		{				inputChecker = [[InputChecker alloc] init];				need_register_notification = YES;		}				[inputChecker show : self];				if(need_register_notification)		{				NSNotificationCenter *nc = [NSNotificationCenter defaultCenter];		   				[nc addObserver : self					   selector : @selector(handleParseInput:)						   name : NOTIFICATION_INPUTVIEW_INVOKE_PARSEINPUT						 object : inputChecker.textView				 ];		}}/***********************************UpdateUI***********************//*  -(IBAction)setDocumentLexerSingleLine : (id)sender; -(IBAction)setDocumentLexerIgnoreCase : (id)sender; -(IBAction)setDocumentParserModeSLR : (id)sender; -(IBAction)setDocumentParserModeLALR : (id)sender; -(IBAction)buildDocumentParser	:	(id)sender; -(IBAction)parseDocumentInput	:	(id)sender; -(IBAction)rebuildDocumentTags	:	(id)sender; -(IBAction)generateDocumentGrammarTemplateCode : (id)sender;  */-(BOOL)validateUserInterfaceItem:(id < NSValidatedUserInterfaceItem >)item{		BOOL ret = YES;		assert(item != nil);				NSMenuItem *menuItem = (NSMenuItem*)item;				if([menuItem action] == @selector(setDocumentLexerSingleLine:)) 		{				if(lexIsSingleLine)				{						[menuItem setState : NSOnState];				}else				{						[menuItem setState : NSOffState];				}						}else if([menuItem action] == @selector(setDocumentLexerIgnoreCase:))		{				if(lexIsIgnoreCase)				{						[menuItem setState : NSOnState];				}else				{						[menuItem setState : NSOffState];				}						}else if([menuItem action] == @selector(setDocumentParserModeSLR:))		{				if(parserMode == PARSER_SLR)				{						[menuItem setState : NSOnState];				}else				{						[menuItem setState : NSOffState];				}						}else if([menuItem action] == @selector(setDocumentParserModeLALR:))		{				if(parserMode == PARSER_LALR)				{						[menuItem setState : NSOnState];				}else				{						[menuItem setState : NSOffState];				}						}else if([menuItem action] == @selector(buildDocumentParser:))		{										}else if([menuItem action] == @selector(rebuildDocumentTags:))		{						}else if([menuItem action] == @selector(generateDocumentGrammarTemplateCode:))		{						}			return ret;}/***********************************Used for other class***********************/-(BOOL)hasParser{		return NO;}@end
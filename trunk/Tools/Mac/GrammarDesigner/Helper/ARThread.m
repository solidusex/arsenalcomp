////  ARThread.m//  ThreadTest////  Created by liu peng on 9/14/11.//  Copyright 2011 none. All rights reserved.//#import "ARThread.h"@interface ThreadData	: NSObject{		id				target;		SEL				action;		id				arg;		AREvent			*eventIsDone;		AREvent			*eventIsInitialized;}@property (readwrite, retain) id		target;@property (readwrite, assign) SEL		action;@property (readwrite, retain) id		arg;-(id)	init;-(void) dealloc;-(void) waitForInitialized;-(void) waitForDone;-(BOOL) waitForDoneTimeout : (NSTimeInterval) milliseconds;-(void) run;@end@implementation ThreadData@synthesize target;@synthesize action;@synthesize arg;-(id)	init{		self = [super init];				if(self)		{				eventIsDone				= [[AREvent alloc] initEvent : NO];				eventIsInitialized		= [[AREvent alloc] initEvent : NO];		}		return (self);}-(void) dealloc{		[target release];		action = nil;				[arg release];		[eventIsDone release];		[eventIsInitialized release];		[super dealloc];}-(void) waitForInitialized{		[eventIsInitialized wait];}-(void) waitForDone{		[eventIsDone wait];}-(BOOL) waitForDoneTimeout : (NSTimeInterval) milliseconds{		return [eventIsDone waitTimeout : milliseconds];}-(void) run{		[eventIsInitialized set];				@try{		if(target != nil && action != nil)		{				if(arg != nil)				{						[target performSelector : action withObject : arg];				}else				{						[target performSelector : action];				}		}		}@catch(NSException *e)		{				NSLog(@"exception occur in ARThread (%@ : %@)!", [e name], [e reason]);		}				[eventIsDone set];		}@endstatic void* __thread_routine(void *param){		assert(param != NULL);					NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];				ThreadData *thd_data = (ThreadData*)param;				if(thd_data != nil)		{				[thd_data run];		}				[pool drain];				return NULL;}@implementation ARThread +(void)	sleep : (NSTimeInterval)milliseconds{		long m = (long)milliseconds;				usleep(m * 1000);		}+(void) yield{		pthread_yield_np();}-(id)init{		return [self initWithTarget : nil selector : nil argument : nil];}-(id)	initWithTarget : (id)obj 			selector : (SEL)sel 			argument : (id)arg{				self = [super init];				if(self)		{				data = [[ThreadData alloc] init];				data.target = obj;				data.action = sel;				data.arg = arg;												pthread_attr_t attr;				pthread_attr_init(&attr);				pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);								memset(&thread, 0, sizeof(thread));								if(pthread_create(&thread, &attr, __thread_routine, (void*)data) != 0)				{						@throw [ARSystemException exceptionWithReason : @"cannot start thread"];				}								pthread_attr_destroy(&attr);								[data waitForInitialized];		}		return (self);}-(void)dealloc{		[self join];				[data release];						[super dealloc];}-(void)	join{		[data waitForDone];		pthread_join(thread, NULL);}-(BOOL) joinTimeout : (NSTimeInterval) milliseconds{		if([data waitForDoneTimeout : milliseconds])		{				pthread_join(thread, NULL);				return YES;		}else		{				return NO;		}}-(BOOL)isActive{		if([self joinTimeout : 0])		{				return NO;		}else		{				return YES;		}}-(void)setPriority : (int)prio{		struct sched_param param;		memset(&param, 0, sizeof(param));		param.sched_priority = prio;		if(pthread_setschedparam(thread, SCHED_OTHER, &param) != 0)		{				@throw [ARSystemException exceptionWithReason : @"cannot set thread priority"];		}}-(void) getPriority : (int*)prio{		assert(prio != NULL);		int policy = 0;		struct sched_param param;		memset(&param, 0, sizeof(param));				if(pthread_getschedparam(thread, &policy, &param) == 0)		{				*prio = param.sched_priority;		}else		{				@throw [ARSystemException exceptionWithReason : @"cannot get thread priority"];		}}@end
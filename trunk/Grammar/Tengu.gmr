
%code {:
/*
 * The Arsenal Library
 * Copyright (c) 2009 by Solidus
 * 
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.It is provided "as is" without express 
 * or implied warranty.
 *
 */
:}
;



/******************************************PreDefined code********************************************/



%code syntax_node {:
	typedef enum
	{
		TGU_NODE_TOKEN_T,
		TGU_NODE_STMT_T,
		TGU_NODE_EXPR_T,
		TGU_NODE_SYMB_T,
		TGU_NODE_PARAMS_T,
		TGU_NODE_FUNC_T
	}tguSynNodeType_t;

	typedef struct __tengu_syntax_node_tag
	{
		tguSynNodeType_t		type;
		
		union{
				tguToken_t			token;
				tguStmt_t			*stmt;
				tguExpr_t			*expr;
				tguParams_t			*params;
				tguSymb_t			*symb;
		};
	}tguSynNode_t;


	static tguSynNode_t*	__create_synnode(tguSynNodeType_t type, void *data)
	{
			tguSynNode_t *node;

			node = AR_NEW0(tguSynNode_t);
			node->type = type;

			switch(node->type)
			{
			case TGU_NODE_TOKEN_T:
				node->token = *(tguToken_t*)data;
				break;
			case TGU_NODE_STMT_T:
				node->stmt = (tguStmt_t*)data;
				break;
			case TGU_NODE_EXPR_T:
				node->expr = (tguExpr_t*)data;
				break;
			case TGU_NODE_SYMB_T:
				node->symb = (tguSymb_t*)data;
				break;
			case TGU_NODE_PARAMS_T:
				node->params = (tguParams_t*)data;
				break;
			}

			return node;
	}


	static void	__destroy_synnode(	tguSynNode_t* node)
	{
		AR_ASSERT(node != NULL);
		switch(node->type)
		{
		case TGU_NODE_TOKEN_T:
			break;
		case TGU_NODE_STMT_T:
			if(node->stmt)
			{
				TGU_DestroyStmt(node->stmt);
				node->stmt = NULL;
			}
			break;
		case TGU_NODE_EXPR_T:
			if(node->expr)
			{
				tguExpr_t	*expr = node->expr;
				while(expr)
				{
					tguExpr_t	*tmp = expr->next;
					TGU_DestroyExpr(node->expr);
					expr = tmp;
				}
				node->expr = NULL;
			}
			break;
		case TGU_NODE_SYMB_T:
			if(node->symb)
			{
				TGU_DestroySymb(node->symb);
				node->symb = NULL;
			}
			break;
		case TGU_NODE_PARAMS_T:
			if(node->params)
			{	
				TGU_DestroyParams(node->params);
				node->params = NULL;
			}
			break;
		}

		AR_DEL(node);
	}
:}
;





%code syntax_tree_handler {:

	static void		AR_STDCALL on_free_node(psrNode_t *node, void *ctx)
	{
		AR_ASSERT(node != NULL && ctx != NULL);
		__destroy_synnode((tguSynNode_t*)node);
		
	}

	static void		AR_STDCALL on_error(const psrToken_t *tok, const size_t expected[], size_t count, void *ctx)
	{
		
	}
	
	static const psrHandler_t	__g_handler = {on_error, on_free_node};
:}
;








%name	delim 			:	"[ \r\n\t]"			
				;
%name	comment		:	"/\*([^\*]|\*+[^\*/])*\*+/"	
				;

%name	comment_line		:	"(//[^\r\n]*\r?(\n|$))"
				;

%name skip_lexem		: 	"{comment_line}|{delim}|{comment}"
				;


%name	digit			:	"[0-9]"				
				;
%name	number			:	"{digit}+"				
				;


/*
\x{4E00}-\x{9FA5} 	(中文)
\x{3130}-\x{318F} 	(韩文)
\x{AC00}-\x{D7A3}	(韩文)
\x{0800}-\x{4E00}	(日文)
*/

//ASCII + 中日韩

%name	letter			:	"[A-Z_a-z\x{0800}-\x{4E00}\x{4E00}-\x{9FA5}\x{3130}-\x{318F}\x{AC00}-\x{D7AF}]"
				;



%name hex_digit		:	"[0-9a-fA-F]"
				;

%name hex_literal 		:	"0(x|X){hex_digit}+"
				;

%name oct_literal		:	"0[0-7]+"
				;

%name dec_literal		:	"(0|[1-9][0-9]*)"
				;




%name	exponet			:	"(e|E)(\+|\-)?[0-9]+"
					;


%name float_literal			:	"(((([0-9]\.[0-9]*)|(\.[0-9]+)){exponet}?)|([0-9]+{exponet}))"
					;





/*  '"'  == \x22,  '\'' == \x27 */

%name	escape_seq		:	"(\\(\x22|\x27))"	
				;

%name	string_dq		: 	"(\x22({escape_seq}|[^\x22])*\x22)"		//只能提取"..."或"\""此类串，其它词法规则要到语义例程中处理	
				;

%name	string_sq		:	"\x27({escape_seq}|[^\x27])*\x27"		//提取'...'或'\''此类串，其它词法规则要到语义例程中处理	
				;



%name	keyword_lhd		:	"[A-Z_a-z0-9]"
				;


%name		float_constant	:	"{float_literal}(?!{keyword_lhd})"
					;
%name		hex_constant		:	"{hex_literal}(?!{keyword_lhd})"
					;
%name		oct_constant		:	"{oct_literal}(?!{keyword_lhd})"
					;
%name		dec_constant		:	"{dec_literal}(?!{keyword_lhd})"
					;


%token 	%skip			:	"{skip_lexem}"				,1				%value	"TOK_DELIM_ID"	 		;			//空白，需要过滤



%code token_operation{:
	
	static tguSynNode_t*	on_lex_node(tguParser_t *parser, const wchar_t *str, size_t term_val, size_t line, size_t col)
	{
		tguToken_t token;
		AR_ASSERT(parser != NULL && parser->model_name);
		token.token = str;
		token.term_val = term_val;
		token.lex_info.linenum = line;
		token.lex_info.col = col;
		token.lex_info.model_name = parser->model_name;
		return __create_synnode(TGU_NODE_TOKEN_T, (void*)&token);
	}

:}
;



%token		NAME		:	"{letter}({letter}|{digit})*"					%value	"TOK_NAME"			%action default_leaf_handler		
				{:
					tguParser_t	*parser = (tguParser_t*)ctx;
					const wchar_t	*term_str = NULL;
					AR_ASSERT(parser != NULL && tok != NULL);
					AR_ASSERT(tok->str_cnt > 0);
					term_str = TGU_AllocStringN(tok->str, tok->str_cnt);
					return on_lex_node(parser, term_str, tok->term_val, tok->line, tok->col);
				:}
				;


%token		STRING		:	"{string_dq}|{string_sq}"						%value	"TOK_STRING"			%action on_string_leaf_handler		
				{:
					arEscStrErr_t	err;
					tguParser_t	*parser = (tguParser_t*)ctx;
					wchar_t	*str = NULL;
					const wchar_t *term_str;
					AR_ASSERT(parser != NULL && tok != NULL);
					AR_ASSERT(tok->str_cnt >= 2);			
					AR_ASSERT(tok->str[0] == L'"' || tok->str[0] == L'\'');
					AR_ASSERT(tok->str[tok->str_cnt-1] == L'"' || tok->str[tok->str_cnt-1] == L'\'');

					str = AR_escstr_to_str_n(tok->str + 1, tok->str_cnt - 2, &err);
					if(str == NULL)
					{
						wchar_t	msg[1024];
						parser->has_error = true;
						AR_swprintf(msg, 1024, L"error : character escape sequence\r\n");
						TGU_ReportError(&parser->report, msg, tok->line);
					}
					term_str = TGU_AllocString(str == NULL ? L"" : str);
					
					if(str)
					{
						AR_DEL(str);
						str = NULL;
					}

					return on_lex_node(parser, term_str, tok->term_val, tok->line, tok->col);
				:}
				;


%token		FLOAT_NUMBER	:	"{float_constant}"						,2	%value	"TOK_FLOAT_NUMBER"		%action default_leaf_handler		;
%token		INT_NUMBER	:	"{hex_constant}|{oct_constant}|{dec_constant}"		,2	%value	"TOK_INT_NUMBER"		%action default_leaf_handler		;







%token	"for"		:	'"for"(?!{keyword_lhd})'		,1			%value	"TOK_FOR"			%action default_leaf_handler			;
%token	"do"		:	'"do"(?!{keyword_lhd})'		,1			%value	"TOK_DO"			%action default_leaf_handler			;
%token	"while"	:	'"while"(?!{keyword_lhd})'		,1			%value	"TOK_WHILE"			%action default_leaf_handler			;
%token	"if"		:	'"if"(?!{keyword_lhd})'		,1			%value	"TOK_IF"			%action default_leaf_handler			;
%token	"else"		:	'"else"(?!{keyword_lhd})'		,1			%value	"TOK_ELSE"			%action default_leaf_handler			;

%token	"continue"	:	'"continue"(?!{keyword_lhd})'	,1			%value	"TOK_CONTINUE"		%action default_leaf_handler			;
%token	"break"	:	'"break"(?!{keyword_lhd})'		,1			%value	"TOK_BREAK"			%action default_leaf_handler			;
%token	"return"	:	'"return"(?!{keyword_lhd})'	,1				%value	"TOK_RETURN"			%action default_leaf_handler			;

%token	"null"		:	'"null"(?!{keyword_lhd})'		,1			%value	"TOK_NULL"			%action default_leaf_handler			;
%token	"true"		:	'"true"(?!{keyword_lhd})'		,1			%value	"TOK_TRUE"			%action default_leaf_handler			;
%token	"false"	:	'"false"(?!{keyword_lhd})'		,1			%value	"TOK_FALSE"			%action default_leaf_handler			;
%token	"var"		:	'"var"(?!{keyword_lhd})'		,1			%value	"TOK_VAR"			%action default_leaf_handler			;

%token	"import"	:	'"import"(?!{keyword_lhd})'		,1			%value	"TOK_IMPORT"			%action default_leaf_handler			;


%token	"..."		:	'"..."'		,2					%value	"TOK_ELLIPSIS"		%action default_leaf_handler			;	


%token	"++"		:	'"++"'		,1						%value	"TOK_INC"			%action default_leaf_handler			;
%token	"--"		:	'"--"'		,1						%value	"TOK_DEC"			%action default_leaf_handler			;


%token	"&&"		:	'"&&"'		,1						%value	"TOK_ANDAND"			%action default_leaf_handler				;
%token	"||"		:	'"||"'		,1						%value	"TOK_OROR"			%action default_leaf_handler			;



%token	"<="		:	'"<="'		,1						%value	"TOK_LE"			%action default_leaf_handler			;
%token	">="		:	'">="'		,1						%value	"TOK_GE"			%action default_leaf_handler			;
%token	"=="		:	'"=="'		,1						%value	"TOK_EQ"			%action default_leaf_handler			;
%token	"!="		:	'"!="'		,1						%value	"TOK_NE"			%action default_leaf_handler			;
%token	"<"		:	'"<"'			,0					%value	"TOK_LESS"			%action default_leaf_handler			;
%token	">"		:	'">"'			,0					%value	"TOK_GREATER"			%action default_leaf_handler				;




%token	"{"		:	'"{"'			,0					%value	"TOK_L_BRACES"		%action default_leaf_handler			;
%token	"}"		:	'"}"'			,0					%value	"TOK_R_BRACES"		%action default_leaf_handler			;
%token	"("		:	'"("'			,0					%value	"TOK_L_PAREN"			%action default_leaf_handler			;
%token	")"		:	'")"'			,0					%value	"TOK_R_PAREN"			%action default_leaf_handler			;
%token	"["		:	'"["'			,0					%value	"TOK_L_SQUARE"		%action default_leaf_handler			;
%token	"]"		:	'"]"'			,0					%value	"TOK_R_SQUARE"		%action default_leaf_handler			;

%token	";"		:	'";"'			,0					%value	"TOK_SEMICOLON"		%action default_leaf_handler			;
%token	","		:	'","'			,0					%value	"TOK_COMMA"			%action default_leaf_handler			;
%token	"="		:	'"="'			,0					%value	"TOK_ASSIGN"			%action default_leaf_handler			;



%token	"+"		:	'"+"'			,0					%value	"TOK_ADD"			%action default_leaf_handler			;
%token	"-"		:	'"-"'			,0					%value	"TOK_SUB"			%action default_leaf_handler			;
%token	"*"		:	'"*"'			,0					%value	"TOK_MUL"			%action default_leaf_handler			;
%token	"/"		:	'"/"'			,0					%value	"TOK_DIV"			%action default_leaf_handler			;
%token	"%"		:	'"%"'			,0					%value	"TOK_MOD"			%action default_leaf_handler			;

%token	"!"		:	'"!"'			,0					%value	"TOK_NOT"			%action default_leaf_handler			;


%token	":"		:	'":"'			,0					%value	"TOK_COLON"			%action default_leaf_handler			;
%token	"?"		:	'"?"'			,0					%value	"TOK_QUEST"			%action default_leaf_handler			;


%token	"."		:	'"."'			,0					%value	"TOK_DOT"			%action default_leaf_handler			;





/**************************************************优先级*****************************************************/

%right		"?"	":"							;
%left		"||"								;
%left		"&&"								;
%left		"=="	"!="	"<"	"<="	">"	">="			;
%left		"+"	"-"							;
%left		"*"	"/"	"%"						;




/*
"if" "(" expression ")" statement "else" statement 
产生式的优先级依赖于其最右终结符或显性指定,这里就是"else"
*/
%nonassoc IF_WITHOUT_ELSE						;
%nonassoc "else"							;






/**********************************************产生式****************************************/


%start	program		;


program			:	translation_unit			%action	on_translation_unit	
				|	.					%action	on_translation_unit
				{:
					tguParser_t 	*parser = (tguParser_t*)ctx;
					tguBlock_t	*result;
					AR_ASSERT(count == 0 || count == 1);
					return NULL;

				:}
				;

translation_unit		:	element				%action	auto_return_null
				|	translation_unit	element	%action	auto_return_null
				;


element			:	declaration			%action	auto_return_null
				|	function_defination		%action	auto_return_null
				|	statement			%action	on_global_stmtement
				{:
						
						tguSynNode_t	**ns = (tguSynNode_t**)nodes;
						tguParser_t	*parser = (tguParser_t*)ctx;
						AR_ASSERT(ns != NULL && count == 1);
						if(ns[0] == NULL)
						{
							return NULL;
						}
						
						AR_ASSERT(ns[0]->type == TGU_NODE_STMT_T && ns[0]->stmt != NULL);
						
						AR_ASSERT(parser->top_block == parser->abs_tree);
						TGU_InsertStmtToBlock(parser->top_block, ns[0]->stmt);
						ns[0]->stmt = NULL;
						return NULL;

				:}
				;





/**************************************function_defination***********************************************/


%code{:
	
	static void	start_function(tguParser_t *parser, const wchar_t *func_name, const tguParams_t	*params, const tguLexInfo_t *lex_info)
	{
		size_t	i;
		AR_ASSERT(parser != NULL && func_name != NULL && lex_info != NULL);

		AR_ASSERT(parser->top_block == parser->abs_tree && parser->current_function == NULL);
		AR_ASSERT(!parser->is_on_function_compound);
		
		parser->is_on_function_compound = true;
		if(	TGU_FindSymbFromBlock(parser->abs_tree, func_name, TGU_SYMB_FUNC_T, true) != NULL 
		|| 	TGU_FindSymbFromBlock(parser->abs_tree, func_name, TGU_SYMB_CFUNC_T, true) != NULL
		||	TGU_FindSymb((tguSymbTbl_t*)parser->build_in, func_name, TGU_SYMB_FUNC_T) != NULL
		||	TGU_FindSymb((tguSymbTbl_t*)parser->build_in, func_name, TGU_SYMB_CFUNC_T) != NULL
		)
		{
			wchar_t	msg[1024];
			parser->has_error = true;
			AR_swprintf(msg, 1024, L"error : function '%ls' : redefinition\r\n",  func_name);
			TGU_ReportError(&parser->report, msg, lex_info->linenum);

		}

		parser->current_function = TGU_CreateFunction(func_name, parser->top_block);
		parser->top_block = parser->current_function->block;
		parser->current_function->is_variadic_param = params ? params->is_variadic : false;
		
		
		for(i = 0; params != NULL && i < params->count; ++i)
		{
			tguSymb_t	*symb;
			tguBlock_t	*block = parser->current_function->block;
			const wchar_t	*name = params->names[i];
			const tguLexInfo_t	lex_info = params->lex_info[i];
			AR_ASSERT(name != NULL);

			symb = TGU_FindSymbFromBlock(block, name, TGU_SYMB_VAR_T, true);

			if(symb)
			{
				wchar_t	msg[1024];
				parser->has_error = true;
				AR_swprintf(msg, 1024, L"error : '%ls' : redefinition\r\n",  name);
				TGU_ReportError(&parser->report, msg, lex_info.linenum);
			}else
			{
				symb = TGU_CreateSymb(TGU_SYMB_VAR_T, name);
				TGU_InsertSymbToBlock(block, symb);
			}
		}
		
		AR_ASSERT(parser->top_block != NULL);
		
	}
	

	static void	close_function(tguParser_t *parser, tguStmt_t	*stmt)
	{
		tguSymb_t	*symb;
		tguFunc_t	*func;
		AR_ASSERT(parser != NULL);
		AR_ASSERT(parser->top_block== parser->abs_tree && parser->current_function != NULL);
		AR_ASSERT(stmt->stmt_type == TGU_STT_COMPOUND && stmt->compound_stmt.block == parser->current_function->block);
		func = parser->current_function;
		parser->current_function = NULL;
		symb = TGU_CreateSymb(TGU_SYMB_FUNC_T, func->name);
		symb->function = func;
		
		
		parser->is_on_function_compound = false;
		if(	TGU_FindSymbFromBlock(parser->abs_tree, func->name, TGU_SYMB_FUNC_T, true) != NULL 
		|| 	TGU_FindSymbFromBlock(parser->abs_tree, func->name, TGU_SYMB_CFUNC_T, true) != NULL
		||	TGU_FindSymb((tguSymbTbl_t*)parser->build_in, func->name, TGU_SYMB_FUNC_T) != NULL
		||	TGU_FindSymb((tguSymbTbl_t*)parser->build_in, func->name, TGU_SYMB_CFUNC_T) != NULL
		)
		{
				TGU_DestroySymb(symb);
		}else
		{
				TGU_InsertSymbToBlock(parser->top_block, symb);
		}
		stmt->compound_stmt.block = NULL;
		TGU_DestroyStmt(stmt);
	}
:}
;


function_signature		:	"var"		NAME "(" params ")"						%action	on_function_signature
				{:
						tguParser_t 	*parser = (tguParser_t*)ctx;
						tguSynNode_t	**ns = (tguSynNode_t**)nodes;
						tguToken_t		name;
						tguLexInfo_t		lex_info;
						tguParams_t		*params;
						AR_ASSERT(ns[0] != NULL && ns[1] != NULL);

						lex_info = ns[0]->token.lex_info;
						name = ns[1]->token;
						if(ns[3] == NULL)
						{
							params = NULL;
							parser->has_error = true;
						}else
						{
							params = ns[3]->params;
							AR_ASSERT(params != NULL);
						}
						
						start_function(parser, name.token, params, &lex_info);
						return NULL;
				:}
				;


function_defination		:	function_signature	compound_statement	%action	on_function_defination
				{:
						tguParser_t 	*parser = (tguParser_t*)ctx;
						tguSynNode_t	**ns = (tguSynNode_t**)nodes;
						tguStmt_t	*stmt;
						if(ns[1] != NULL)
						{
							stmt = ns[1]->stmt;
							ns[1]->stmt = NULL;
						}else
						{
							stmt = NULL;
						}

						close_function(parser, stmt);
						return NULL;
				:}
				;






params				:	namelist	","	"..."		%action on_namelist_ellipsis
				{:
						tguSynNode_t	**ns = (tguSynNode_t**)nodes;
						tguSynNode_t	*ret;
						AR_ASSERT(nodes != NULL && count == 3);
						ns[0]->params->is_variadic = true;
						ret = ns[0];
						ns[0] = NULL;
						return ret;
				:}
				|	namelist		%action	auto_return_0
				{:
						psrNode_t *ret = nodes[0];
						ret  = nodes[0];
						nodes[0] = NULL;
						return ret;
				:}
				|	"..."			%action	on_ellipsis
				{:
						tguParams_t	*params;
						tguSynNode_t	*ret;
						AR_ASSERT(nodes != NULL && count == 1);

						params = TGU_CreateParams();
						params->is_variadic = true;
						ret = __create_synnode(TGU_NODE_PARAMS_T, (void*)params);
						return ret;
				:}

				|	.			%action	NULL
				;



namelist			:	namelist	"," NAME		%action	on_name_list
				{:
						tguSynNode_t	**ns = (tguSynNode_t**)nodes;
						tguSynNode_t	*ret;
						tguParams_t	*params;
						tguToken_t	tok;
						AR_ASSERT(nodes != NULL && count == 2);
						tok = ns[1]->token;
						params = ns[0]->params;
						TGU_InsertToParams(params, &tok);
						ret = ns[0];
						ns[0] = NULL;
						return ret;
				:}

				|	NAME					%action	on_name
				{:
						tguSynNode_t	**ns = (tguSynNode_t**)nodes;
						tguSynNode_t	*ret;
						tguParams_t	*params;
						tguToken_t	tok;
						AR_ASSERT(nodes != NULL && count == 1);
						tok = ns[0]->token;
						params = TGU_CreateParams();
						TGU_InsertToParams(params, &tok);
						ret = __create_synnode(TGU_NODE_PARAMS_T, (void*)params);
						return ret;
				:}
				;








/*************************************声明语句***************************************************/


declaration				:	"var"		init_declarator_list 	semi			%action	auto_return_null
					;



init_declarator_list			:	init_declarator						%action	auto_return_null
					|	init_declarator_list "," init_declarator			%action	auto_return_null
					;



%code{:
	
	static void	handle_symb_from_expression(tguParser_t 	*parser, const tguToken_t *tok, tguExpr_t *expr)
	{
			tguSymb_t	*symb;
			AR_ASSERT(parser != NULL && tok != NULL);
			symb = TGU_FindSymbFromBlock(parser->top_block, tok->token, TGU_SYMB_VAR_T, true);
			
			if(symb)
			{
				wchar_t	msg[1024];
				parser->has_error = true;
				AR_swprintf(msg, 1024, L"error : '%ls' : redefinition\r\n",  tok->token);
				TGU_ReportError(&parser->report, msg, tok->lex_info.linenum);
			}else
			{
				symb = TGU_CreateSymb(TGU_SYMB_VAR_T, tok->token);
				symb->init_expr = expr;
				TGU_InsertSymbToBlock(parser->top_block, symb);
				TGU_InsertDeclToBlock(parser->top_block, symb);
			}
	}
:};




init_declarator			:	NAME	"=" 	expression				%action	on_declarator
					|	NAME 	"="	table_constructor			%action	on_declarator
					|	NAME							%action	on_declarator
					{:
						tguParser_t 		*parser = (tguParser_t*)ctx;
						tguSynNode_t		**ns = (tguSynNode_t**)nodes;
						tguExpr_t		*expr;
						AR_ASSERT(nodes != NULL && parser != NULL && (count == 1 || count == 3));

						if(count == 1)
						{
							/*声明了一个null类型的变量*/
							handle_symb_from_expression(parser, &ns[0]->token, NULL);
						}else
						{
							if(ns[2] == NULL)
							{
								/*expression 或者 table_constructor出现错误*/
								parser->has_error = true;
								handle_symb_from_expression(parser, &ns[0]->token, NULL);
							}else 
							{
								expr = ns[2]->expr;
								ns[2]->expr = NULL;
								AR_ASSERT(expr != NULL);
								handle_symb_from_expression(parser, &ns[0]->token, expr);
							}
						}

						return NULL;
					:}
					;





table_constructor			:	"{"	filed_list "}"		%action	on_table_constructor
					|	"{"	"}"				%action	on_table_constructor
					|	"{" error "}"				%action	on_table_constructor
					{:
						tguParser_t 	*parser = (tguParser_t*)ctx;
						tguSynNode_t	**ns = (tguSynNode_t**)nodes;
						tguSynNode_t	*ret;
						tguExpr_t	*expr;
						AR_ASSERT(parser != NULL && ns != NULL);
						AR_ASSERT(count == 2 || count == 3);
						
						expr = TGU_CreateExpr(TGU_ET_TABLE_INIT);

						if(count == 2)
						{
							/*创建了个空的表结构*/
							expr->table_init.expr_list = NULL;
						}else
						{
							if(ns[1] == NULL)
							{
								parser->has_error = true;
								expr->table_init.expr_list = NULL;
							}else
							{
								expr->table_init.expr_list = ns[1]->expr;
								ns[1]->expr = NULL;
								AR_ASSERT(expr->table_init.expr_list != NULL);
							}
						}
						
						ret = __create_synnode(TGU_NODE_EXPR_T, (void*)expr);
						return ret;

					:}
					;




filed_list 				:	filed_list "," filed			%action	on_filed_list
					{:
						tguSynNode_t	**ns = (tguSynNode_t**)nodes;
						tguSynNode_t	*ret;
						tguExpr_t		*lst;
						AR_ASSERT(ns != NULL && count == 3);
						if(ns[0] == NULL) return ns[2];
						if(ns[2] == NULL) return ns[0];
						AR_ASSERT(ns[0]->expr != NULL  && ns[2]->expr != NULL);

						for(lst = ns[0]->expr; lst->next != NULL; lst = lst->next);
						
						lst->next = ns[2]->expr;
						ns[2]->expr = NULL;
						ret = ns[0];
						ns[0] = NULL;
						return ret;

					:}

					|	filed						%action	auto_return_0
					;



filed					:	expression			%action	auto_return_0
					|	table_constructor		%action	auto_return_0
					;




/*************************************语句***************************************************/


statement				:	compound_statement			%action	auto_return_0
					|	expression_statement			%action	auto_return_0
					|	selection_statement			%action	auto_return_0
					|	iteration_statement			%action	auto_return_0
					|	jump_statement			%action	auto_return_0
					|	empty_statement			%action	auto_return_0
					|	import_statement			%action	auto_return_0
					;




/**************************************import_statement***********************************************/



import_statement		:	"import"	STRING	";"		%action	on_import_statement
				|	"import"	error 	";"		%action	on_import_statement
				{:
					tguParser_t 	*parser = (tguParser_t*)ctx;
					tguSynNode_t	**ns = (tguSynNode_t**)nodes;
					bool_t		has_error = false;
					const 		wchar_t	*path;
					tguLexInfo_t	*lex_info;
					AR_ASSERT(parser != NULL);
					lex_info = &ns[0]->token.lex_info;
					if(ns[1] == NULL)
					{
						has_error = true;
						path = NULL;
					}else
					{
						tguSrc_t	*src;
						path = ns[1]->token.token;
						src = TGU_LoadSources(path);
						
						if(src)
						{
							if(TGU_FindSymb(parser->import_models, TGU_AllocString(src->model_name), TGU_SYMB_BLOCK_T) == NULL)
							{
								tguSymb_t		*model_symb;
								tguParseResult_t	parse_result;
								tguParser_t	*psr;

								model_symb = TGU_CreateSymb(TGU_SYMB_BLOCK_T, src->model_name);
								TGU_InsertToSymbTable(parser->import_models, model_symb);

								psr = TGU_CreateParser(&parser->report, parser->build_in, parser->import_models);
								parse_result = TGU_ParseCode(psr, src->model_name, src->code);
							
								if(parse_result.has_error)
								{
									has_error = true;
									TGU_RemoveFromSymbTable(parser->import_models, model_symb->name, model_symb->type);
								}else
								{
									AR_ASSERT(parse_result.block);
									model_symb->block = parse_result.block;
								}
								TGU_DestroyParser(psr);
							}
						}else
						{
							has_error = true;
						}

						if(src)
						{
							TGU_ReleaseSources(src);	
							src = NULL;
						}
					}
					
					if(has_error)
					{
						wchar_t msg[1024];
						parser->has_error = true;
						AR_swprintf(msg, 1024, L"import '%ls' failed\r\n", path == NULL ? L"" : path);
						TGU_ReportError(&parser->report, msg, lex_info->linenum);

					}

					return NULL;
				:}
				;





/**************************************compound_statement*****************************/


%code {:
	tguStmt_t*		make_compound_stmt(tguParser_t 	*parser, tguBlock_t		*block, const tguLexInfo_t *start, const tguLexInfo_t *end)
	{
			tguStmt_t	*ret;
			AR_ASSERT(parser != NULL);
			ret = TGU_CreateStmt(TGU_STT_COMPOUND);
			ret->lex_info = *start;
			

			if(block)
			{
				block->begin = *start;
				block->end = *end;
			}
			ret->compound_stmt.block = block;
			return ret;

	}
:};



compound_statement		:	start_block	compound_element_list		"}"		%action	on_compound_statement
				{:
					tguParser_t 	*parser = (tguParser_t*)ctx;
					tguSynNode_t	**ns = (tguSynNode_t**)nodes;
					tguSynNode_t	*ret;
					tguBlock_t		*cb = NULL;
					tguStmt_t *stmt;
						
					AR_ASSERT(nodes != NULL && (count == 3));
					cb = TGU_ParserPopBlock(parser);
						
					stmt = make_compound_stmt(parser, cb, &ns[0]->token.lex_info,&ns[2]->token.lex_info);
					ret = __create_synnode(TGU_NODE_STMT_T, (void*)stmt);
					return ret;
				:}

				|	start_block  	error  				"}"		%action	on_compound_error_statement
				{:
						tguParser_t 	*parser = (tguParser_t*)ctx;
						/*tguSynNode_t	**ns = (tguSynNode_t**)nodes;*/
						tguBlock_t		*cb = NULL;
						AR_ASSERT(nodes != NULL && (count == 2));
						AR_ASSERT(parser != NULL);
						parser->has_error = true;
						cb = TGU_ParserPopBlock(parser);
						TGU_DestroyBlock(cb);
						return NULL;
				:}

				|	start_block						"}"		%action	on_empty_compound_statement
				{:
						tguSynNode_t	**ns = (tguSynNode_t**)nodes;
						tguSynNode_t	*ret;
						tguStmt_t *stmt;		
						tguBlock_t		*cb = NULL;
						tguParser_t	*parser = (tguParser_t*)ctx;
						AR_ASSERT(nodes != NULL && (count == 2));
						cb = TGU_ParserPopBlock(parser);
						cb->begin = ns[0]->token.lex_info;
						cb->end = ns[1]->token.lex_info;
						
						stmt = make_compound_stmt(parser, cb, &ns[0]->token.lex_info,&ns[1]->token.lex_info);
						ret = __create_synnode(TGU_NODE_STMT_T, (void*)stmt);
						return ret;
						
				:}
				;




start_block			:	"{"		%action	on_start_block
				{:
							tguParser_t 	*parser = (tguParser_t*)ctx;
							tguSynNode_t	**ns = (tguSynNode_t**)nodes;
							tguSynNode_t	*ret;
							AR_ASSERT(ns != NULL && count == 1);
							ret = ns[0]; 
							ns[0] = NULL;
							if(!parser->is_on_function_compound)
							{
								TGU_ParserPushBlock(parser);
							}else
							{
								parser->is_on_function_compound = false;
							}
							return ret;
				:}
				;








compound_element_list		:	compound_element_list		compound_element	%action	auto_return_null
					|	compound_element						%action	auto_return_null
					{:
						return NULL;
					:}
					;






compound_element		:	statement		%action	on_compound_element
				{:
						tguSynNode_t	**ns = (tguSynNode_t**)nodes;
						tguParser_t	*parser = (tguParser_t*)ctx;
						AR_ASSERT(ns != NULL && count == 1);
						if(ns[0] == NULL)
						{
							return NULL;
						}
						
						AR_ASSERT(ns[0]->type == TGU_NODE_STMT_T && ns[0]->stmt != NULL);
						TGU_InsertStmtToBlock(parser->top_block, ns[0]->stmt);
						ns[0]->stmt = NULL;
						return NULL;
				:}

				|	declaration		%action	auto_return_null
				;










/*****************************************************************************/

%code {:
	static tguStmt_t*	make_empty_statement(tguParser_t *parser, const tguLexInfo_t *lex_info)
	{
			tguStmt_t	*ret;
			AR_ASSERT(parser != NULL && lex_info != NULL);
			ret = TGU_CreateStmt(TGU_STT_EMPTY);
			ret->lex_info = *lex_info;
			return ret;

	}



	static tguStmt_t*	make_expression_statement(tguParser_t *parser, tguExpr_t *expr, const tguLexInfo_t *lex_info)
	{
			tguStmt_t	*ret;
			AR_ASSERT(parser != NULL);
			ret = TGU_CreateStmt(TGU_STT_EXPR);

			if(lex_info)
			{
				ret->lex_info = *lex_info;
			}
			ret->expr = expr;
			return ret;

	}


		

:};


empty_statement			:	";"		%action	on_empty_statement
					{:
						tguSynNode_t	**ns = (tguSynNode_t**)nodes;
						tguParser_t	*parser = (tguParser_t*)ctx;
						tguSynNode_t 	*ret;
						tguStmt_t		*stmt;
						AR_ASSERT(ns != NULL && parser != NULL && count == 1);

						stmt = make_empty_statement(parser, &ns[0]->token.lex_info);
						ret = __create_synnode(TGU_NODE_STMT_T, (void*)stmt);
						return ret;
					:}
					;


expression_statement			:	expression	 semi		%action on_expression_statement
					{:
						tguSynNode_t	**ns = (tguSynNode_t**)nodes;
						tguParser_t	*parser = (tguParser_t*)ctx;
						tguSynNode_t	*ret;
						tguStmt_t	*stmt;
						tguExpr_t	*expr;
						AR_ASSERT(ns != NULL && count == 2);
						
						if(ns[0] == NULL)
						{
							expr = NULL;
							parser->has_error = true;
						}else
						{
							expr = ns[0]->expr;
							ns[0]->expr = NULL;
							AR_ASSERT(expr != NULL);
						}
							
						stmt = make_expression_statement(parser, expr, expr ? &expr->lex_info : NULL);
						ret = __create_synnode(TGU_NODE_STMT_T, (void*)stmt);
						return ret;

					:}
					;





selection_statement			:	if_statement		%action auto_return_0
					|	if_else_statement	%action auto_return_0
					;





%code	{:

	static tguStmt_t*	make_if_statement(tguParser_t *parser, tguExpr_t *cond, tguStmt_t *if_true, tguStmt_t *if_false, const tguLexInfo_t *lex_info)
	{
			tguStmt_t	*ret;
			AR_ASSERT(parser != NULL && lex_info != NULL);
			ret = TGU_CreateStmt(TGU_STT_IF);
			ret->lex_info = *lex_info;
			ret->if_stmt.expr = cond;
			ret->if_stmt.true_part = if_true;
			ret->if_stmt.false_part = if_false;
			return ret;

	}

:};


if_statement			:	"if" "(" expression ")" statement			%prec IF_WITHOUT_ELSE		%action on_if_statement
				|	"if" "(" error ")" statement			%prec IF_WITHOUT_ELSE		%action on_if_statement
				{:
						tguSynNode_t	**ns = (tguSynNode_t**)nodes;
						tguParser_t	*parser = (tguParser_t*)ctx;
						tguSynNode_t	*ret;
						tguExpr_t		*expr;
						tguStmt_t		*if_true, *stmt;
						AR_ASSERT(ns != NULL && count == 5);
						
						if(ns[2] == NULL)
						{
							expr = NULL;
							parser->has_error = true;
						}else
						{
							expr = ns[2]->expr;
							ns[2]->expr = NULL;
							AR_ASSERT(expr != NULL);
						}
							
						if(ns[4] == NULL)
						{	
							if_true = NULL;
							parser->has_error = true;
						}else
						{
							if_true = ns[4]->stmt;
							ns[4]->stmt = NULL;
							AR_ASSERT(if_true != NULL);
						}

						stmt = make_if_statement(parser, expr, if_true, NULL, &ns[0]->token.lex_info);
						ret = __create_synnode(TGU_NODE_STMT_T, (void*)stmt);
						return ret;
				:}
				;


if_else_statement		:	"if" "(" expression ")" statement "else" statement	%action on_if_else_statement
				|	"if" "(" error ")" statement "else" statement		%action on_if_else_statement
				{:
						tguSynNode_t	**ns = (tguSynNode_t**)nodes;
						tguParser_t	*parser = (tguParser_t*)ctx;
						tguSynNode_t	*ret;
						tguExpr_t		*expr;
						tguStmt_t		*if_true;
						tguStmt_t		*if_false;
						tguStmt_t		*stmt;
						AR_ASSERT(ns != NULL && count == 7);
						if(ns[2] == NULL)
						{
							expr = NULL;
							parser->has_error = true;
						}else
						{
							expr = ns[2]->expr;
							ns[2]->expr = NULL;
							AR_ASSERT(expr != NULL);
						}
							
						if(ns[4] == NULL)
						{	
							if_true = NULL;
							parser->has_error = true;
						}else
						{
							if_true = ns[4]->stmt;
							ns[4]->stmt = NULL;
							AR_ASSERT(if_true != NULL);
						}

						if(ns[6] == NULL)
						{	
							if_false = NULL;
							parser->has_error = true;
						}else
						{
							if_false = ns[6]->stmt;
							ns[6]->stmt = NULL;
							AR_ASSERT(if_false != NULL);
						}


						stmt = make_if_statement(parser, expr, if_true, if_false,  &ns[0]->token.lex_info);	
						ret = __create_synnode(TGU_NODE_STMT_T, (void*)stmt);
						return ret;
				:}
				;



iteration_statement		:	while_statement			%action	auto_return_0
				|	do_while_statement			%action	auto_return_0
				|	for_statement				%action	auto_return_0
				;






%code {:
	static tguStmt_t*	make_while_statement(tguParser_t *parser, tguStmtType_t type, tguExpr_t *cond, tguStmt_t *loop, const tguLexInfo_t *lex_info)
	{
			tguStmt_t	*ret;
			AR_ASSERT(parser != NULL && lex_info != NULL);
			ret = TGU_CreateStmt(type);
			ret->lex_info = *lex_info;
			ret->while_stmt.expr = cond;
			ret->while_stmt.loop_part = loop;
			return ret;

	}
:}
;






while_statement			:	"while" enter_loop  "(" expression ")" statement leave_loop	%action	on_while_statement
					|	"while" enter_loop  "(" error ")" statement leave_loop		%action	on_while_statement
					{:
						tguSynNode_t	**ns = (tguSynNode_t**)nodes;
						tguParser_t	*parser = (tguParser_t*)ctx;
						tguSynNode_t	*ret;
						tguExpr_t		*expr;
						tguStmt_t		*stmt;
						AR_ASSERT(ns != NULL && count == 7);
						if(ns[3] == NULL)
						{
							expr = NULL;
							parser->has_error = true;
						}else
						{
							expr = ns[3]->expr;
							ns[3]->expr = NULL;
							AR_ASSERT(expr != NULL);
						}
							
						if(ns[5] == NULL)
						{	
							stmt = NULL;
							parser->has_error = true;
						}else
						{
							stmt = ns[5]->stmt;
							ns[5]->stmt = NULL;
							AR_ASSERT(stmt != NULL);
						}

						stmt = make_while_statement(parser, TGU_STT_WHILE, expr, stmt, &ns[0]->token.lex_info);
						ret = __create_synnode(TGU_NODE_STMT_T, (void*)stmt);
						return ret;
					:}
					;



do_while_statement			:	"do" enter_loop statement "while" "(" expression ")" leave_loop semi			%action	on_do_while_statement
					|	"do" enter_loop statement "while" "(" error ")" leave_loop semi				%action	on_do_while_statement
					{:
						tguSynNode_t	**ns = 	(tguSynNode_t**)nodes;
						tguParser_t	*parser =	(tguParser_t*)ctx;
						tguSynNode_t	*ret;
						tguExpr_t		*expr;
						tguStmt_t		*stmt;
						AR_ASSERT(ns != NULL && count == 9);
						if(ns[2] == NULL)
						{
							stmt = NULL;
							parser->has_error = true;
						}else
						{
							stmt = ns[2]->stmt;
							ns[2]->stmt = NULL;
							AR_ASSERT(stmt != NULL);
						}
							
						if(ns[5] == NULL)
						{	
							expr = NULL;
							parser->has_error = true;
						}else
						{
							expr = ns[5]->expr;
							ns[5]->expr = NULL;
							AR_ASSERT(expr != NULL);
						}

						stmt = make_while_statement(parser, TGU_STT_DO, expr, stmt, &ns[0]->token.lex_info);
						ret = __create_synnode(TGU_NODE_STMT_T, (void*)stmt);
						return ret;
					:}
					;



%code {:
	
	static tguStmt_t*	make_for_statement(tguParser_t *parser, tguExpr_t *init, tguExpr_t *cond, tguExpr_t *step, tguStmt_t *loop, const tguLexInfo_t *lex_info)
	{
			tguStmt_t	*ret;
			AR_ASSERT(parser != NULL && lex_info != NULL);
			ret = TGU_CreateStmt(TGU_STT_FOR);
			ret->lex_info = *lex_info;
			ret->for_stmt.init_expr = init;
			ret->for_stmt.cond_expr = cond;
			ret->for_stmt.step_expr = step;
			ret->for_stmt.loop_part = loop;
			return ret;
	}

:};


for_statement			:	"for"	"("	for_expression	";"	for_expression	";"	for_expression	")"	enter_loop  statement leave_loop	%action	on_for_statement
				{:
						tguSynNode_t		**ns = (tguSynNode_t**)nodes;
						tguParser_t		*parser = (tguParser_t*)ctx;
						tguSynNode_t		*ret;
						tguExpr_t		*init, *cond, *step;
						tguStmt_t		*loop;
						tguStmt_t		*stmt;

						AR_ASSERT(ns != NULL && count == 11);

						if(ns[2] == NULL)
						{
							init = NULL;
						}else
						{
							init = ns[2]->expr;
							ns[2]->expr = NULL;
							AR_ASSERT(init != NULL);
						}

						if(ns[4] == NULL)
						{
							cond = NULL;
						}else
						{
							cond = ns[4]->expr;
							ns[4]->expr = NULL;
							AR_ASSERT(cond != NULL);
						}
						

						if(ns[6] == NULL)
						{
							step = NULL;
						}else
						{
							step = ns[6]->expr;
							ns[6]->expr = NULL;
							AR_ASSERT(step != NULL);
						}

						if(ns[9] == NULL)
						{
							loop = NULL;
							parser->has_error = true;
						}else
						{
							loop = ns[9]->stmt;
							ns[9]->stmt = NULL;
							AR_ASSERT(loop != NULL);
						}

						stmt = make_for_statement(parser, init, cond, step, loop, &ns[0]->token.lex_info);
						
						ret = __create_synnode(TGU_NODE_STMT_T, (void*)stmt);
						return ret;
				:}
				|	"for"	"("	error	")"	enter_loop  statement leave_loop	%action	on_error_for_statement
				{:
						tguSynNode_t		**ns = (tguSynNode_t**)nodes;
						tguParser_t		*parser = (tguParser_t*)ctx;
						tguSynNode_t		*ret;
						tguStmt_t		*stmt;
						

						stmt = make_for_statement(parser, NULL, NULL, NULL, NULL, &ns[0]->token.lex_info);
						ret = __create_synnode(TGU_NODE_STMT_T, (void*)stmt);
						return ret;
				:}
				;


for_expression		:	expression_list	%action	auto_return_0
				|	.			%action	auto_return_0
				;





enter_loop				:	.					%action on_enter_loop
					{:
						tguParser_t	*parser = NULL;
						AR_ASSERT(ctx != NULL);
						parser = (tguParser_t*)ctx;
						parser->loop_level++;
						return NULL;
					:}
					;


leave_loop				:	.					%action on_leave_loop
					{:
						tguParser_t	*parser = NULL;
						AR_ASSERT(ctx != NULL);
						parser = (tguParser_t*)ctx;
						AR_ASSERT(parser->loop_level > 0);
						parser->loop_level--;
						return NULL;
					:}
					;






%code{:
	static tguStmt_t*	make_jump_statement(tguParser_t *parser, tguStmtType_t type, tguExpr_t *expr, const tguLexInfo_t *lex_info)
	{
		tguStmt_t	*ret;
		wchar_t	msg[512];
		AR_ASSERT(parser != NULL && lex_info != NULL);
		
		ret = TGU_CreateStmt(type);
		ret->lex_info = *lex_info;

		if(type == TGU_STT_RETURN)
		{
			ret->return_stmt.expr = expr;
			
		}else
		{

			if(parser->loop_level == 0)
			{
				const wchar_t *err_msg = NULL;
				if(type == TGU_STT_CONTINUE)
				{
					err_msg = L"error : illegal continue";
				}else if(type == TGU_STT_BREAK)
				{
					err_msg =  L"error : illegal break";
				}
			
				if(err_msg)
				{
					parser->has_error = true;
					AR_swprintf(msg, 512, L"%ls\r\n", err_msg);
					TGU_ReportError(&parser->report, msg, ret->lex_info.linenum);
				}
			}
		}


		return ret;
	}
:}
;


jump_statement			:	"continue" semi				%action on_continue_statement
					{:
						tguSynNode_t	**ns = (tguSynNode_t**)nodes;
						tguSynNode_t 	*ret;
						tguStmt_t		*stmt;
						tguParser_t	*parser = (tguParser_t*)ctx;
						stmt = make_jump_statement(parser, TGU_STT_CONTINUE, 	NULL, &ns[0]->token.lex_info);
						ret = __create_synnode(TGU_NODE_STMT_T, (void*)stmt);
						return ret;

					:}

					|	"break" 	semi				%action on_break_statement
					{:
						tguSynNode_t	**ns = (tguSynNode_t**)nodes;
						tguSynNode_t 	*ret;
						tguStmt_t		*stmt;
						tguParser_t	*parser = (tguParser_t*)ctx;
						ret = AR_NEW(tguSynNode_t);
						ret->type = TGU_NODE_STMT_T;
						stmt = make_jump_statement(parser, TGU_STT_BREAK, 	NULL, &ns[0]->token.lex_info);
						ret = __create_synnode(TGU_NODE_STMT_T, (void*)stmt);
						return ret;
						
					:}

					|	"return" 	semi				%action on_return_statement
					|	"return" 	expression semi		%action on_return_statement
					{:
						tguSynNode_t	**ns = (tguSynNode_t**)nodes;
						tguSynNode_t 	*ret;
						tguExpr_t		*expr;
						tguParser_t	*parser = (tguParser_t*)ctx;
						tguStmt_t		*stmt;
						AR_ASSERT(nodes != NULL && (count == 2 || count == 3));
						AR_ASSERT(parser->current_function != NULL);
						
						if(count == 2)
						{
							expr = NULL;
						}else
						{
							if(ns[1] == NULL)
							{
								expr = NULL;
								parser->has_error = true;
							}else
							{
								AR_ASSERT(ns[1]->type == TGU_NODE_EXPR_T);
								expr = ns[1]->expr;
								ns[1]->expr = NULL;
								AR_ASSERT(expr != NULL);
							}
						}

						stmt = make_jump_statement(parser, TGU_STT_RETURN, 	expr, &ns[0]->token.lex_info);
						ret = __create_synnode(TGU_NODE_STMT_T, (void*)stmt);
						return ret;
					:}
					;




semi					:	";"								%action	auto_return_0
					|	error								%action	on_semi_error
					{:
						tguParser_t	*parser = (tguParser_t*)ctx;
						AR_ASSERT(parser != NULL);
						parser->has_error = true;
						return NULL;
					:}
					;


/*****************************************表达式*********************************************/


expression				:	assignment_expression		%action auto_return_0
					;



%code {:

	static tguExpr_t*		make_assignment_expression(tguParser_t	*parser, 	tguExpr_t *addr, tguExpr_t *value, const tguLexInfo_t *lex_info)
	{
			tguExpr_t	*ret;
			wchar_t	msg[512];
			AR_ASSERT(parser != NULL && lex_info != NULL);
			ret = TGU_CreateExpr(TGU_ET_ASSIGN);

			if(addr)
			{
				if(!addr->is_lvalue)
				{
					parser->has_error = true;
					AR_swprintf(msg, 512, L"%ls\r\n", L"error  : left operand must be l-value");
					TGU_ReportError(&parser->report, msg, addr->lex_info.linenum);
				}else
				{
					AR_ASSERT(!addr->is_constant);
				}
			}

			ret->is_lvalue = true;
			ret->is_constant = true;
			ret->lex_info = *lex_info;

			ret->assign_expr.addr = addr;
			ret->assign_expr.value = value;

			return ret;
	}

:}
;



assignment_expression		:	constant_expression						%action 	auto_return_0
					|	unary_expression	"="	table_constructor		%action	on_assignment_expression
					|	unary_expression	"="	assignment_expression	%action	on_assignment_expression
					{:
						tguSynNode_t	**ns = (tguSynNode_t**)nodes;
						tguSynNode_t 	*ret;
						tguParser_t	*parser = (tguParser_t*)ctx;
						tguExpr_t		*addr, *value, *expr;
						const tguLexInfo_t *lex_info; 
						AR_ASSERT(ns != NULL && count == 3 && parser != NULL);

						if(ns[0] == NULL)
						{
							parser->has_error = true;
							addr = NULL;	
						}else
						{
							addr = ns[0]->expr;
							ns[0]->expr = NULL;
							AR_ASSERT(addr != NULL);
						}
						

						if(ns[2] == NULL)
						{
							parser->has_error = true;
							value = NULL;	
						}else
						{
							value = ns[2]->expr;
							ns[2]->expr = NULL;
							AR_ASSERT(value != NULL);
						}

						lex_info = addr != NULL ? &addr->lex_info : &ns[1]->token.lex_info;
						AR_ASSERT(lex_info != NULL);
						expr = make_assignment_expression(parser, addr, value, lex_info);
						ret = __create_synnode(TGU_NODE_EXPR_T, (void*)expr);

						return ret;

					:}
					;




%code {:

	static tguExpr_t*		make_condition_expression(tguParser_t	*parser, 	tguExpr_t *cond, tguExpr_t *if_true, tguExpr_t *if_false, const tguLexInfo_t *lex_info)
	{
			tguExpr_t	*ret;
			AR_ASSERT(parser != NULL && lex_info != NULL);
			ret = TGU_CreateExpr(TGU_ET_CONDITIONAL);

			ret->is_lvalue = true;
			ret->is_constant = false;
			if(if_true)
			{
				if(!if_true->is_lvalue)
				{
					ret->is_lvalue = false;
				}

				if(if_true->is_constant)
				{
					ret->is_constant = true;
				}
			}

			if(if_false)
			{
				if(!if_false->is_lvalue)
				{
					ret->is_lvalue = false;
				}
				
				if(if_false->is_constant)
				{
					ret->is_constant = true;
				}
			}

			ret->lex_info = *lex_info;

			ret->cond_expr.cond = cond;
			ret->cond_expr.if_true  = if_true;
			ret->cond_expr.if_false = if_false;
			return ret;

	}

:}
;


constant_expression			:	binary_expression									%action 	auto_return_0
					|	binary_expression	"?"	expression	":"		expression		%action	on_condition_expression
					{:
						tguSynNode_t	**ns = (tguSynNode_t**)nodes;
						tguSynNode_t 	*ret;
						tguParser_t	*parser = (tguParser_t*)ctx;
						tguExpr_t		*cond, *if_true, *if_false, *expr;
						const tguLexInfo_t *lex_info;
						AR_ASSERT(ns != NULL && count == 3 && parser != NULL);

						if(ns[0] == NULL)
						{
							parser->has_error = true;
							cond= NULL;	
						}else
						{
							cond = ns[0]->expr;
							ns[0]->expr = NULL;
							AR_ASSERT(cond != NULL);
						}

						

						if(ns[2] == NULL)
						{
							parser->has_error = true;
							if_true = NULL;	
						}else
						{
							if_true= ns[2]->expr;
							ns[2]->expr = NULL;
							AR_ASSERT(if_true != NULL);
						}
						
						if(ns[4] == NULL)
						{
							parser->has_error = true;
							if_false = NULL;	
						}else
						{
							if_false= ns[4]->expr;
							ns[4]->expr = NULL;
							AR_ASSERT(if_false != NULL);
						}

						lex_info = cond != NULL ? &cond->lex_info : &ns[1]->token.lex_info;
						AR_ASSERT(lex_info != NULL);
						expr = make_condition_expression(parser, cond, if_true, if_false, lex_info);
						ret = __create_synnode(TGU_NODE_EXPR_T, (void*)expr);
						return ret;

					:}
					;





%code {:

	static tguExpr_t*		make_binary_expression(tguParser_t	*parser, 	tguExprOP_t op, tguExpr_t *left, tguExpr_t *right, const tguLexInfo_t *lex_info)
	{
			tguExpr_t	*ret;	
			AR_ASSERT(parser != NULL && lex_info != NULL);
			ret = TGU_CreateExpr(TGU_ET_BINARY);
			ret->is_lvalue = false;
			ret->is_constant = false;
			ret->lex_info = *lex_info;
			ret->binary_expr.op = op;
			ret->binary_expr.left  = left;
			ret->binary_expr.right = right;
			return ret;
	}

:}
;

binary_expression			:	unary_expression						%action 	auto_return_0
					|	binary_expression	"+"	binary_expression		%action	on_binary_expression
					|	binary_expression	"-"	binary_expression		%action	on_binary_expression
					|	binary_expression	"*"	binary_expression		%action	on_binary_expression
					|	binary_expression	"/"	binary_expression		%action	on_binary_expression
					|	binary_expression	"%"	binary_expression		%action	on_binary_expression
					|	binary_expression	"<"	binary_expression		%action	on_binary_expression
					|	binary_expression	"<="	binary_expression		%action	on_binary_expression
					|	binary_expression	">"	binary_expression		%action	on_binary_expression
					|	binary_expression	">="	binary_expression		%action	on_binary_expression
					|	binary_expression	"=="	binary_expression		%action	on_binary_expression
					|	binary_expression	"!="	binary_expression		%action	on_binary_expression
					|	binary_expression	"&&"	binary_expression		%action	on_binary_expression
					|	binary_expression	"||"	binary_expression		%action	on_binary_expression
					{:
						tguSynNode_t	**ns = (tguSynNode_t**)nodes;
						tguSynNode_t 	*ret;
						tguParser_t	*parser = (tguParser_t*)ctx;
						tguExpr_t		*left, *right, *expr;

						tguExprOP_t	op;
						const tguLexInfo_t *lex_info;
						tguToken_t	tok;
						AR_ASSERT(ns != NULL && count == 3 && parser != NULL);

						if(ns[0] == NULL)
						{
							parser->has_error = true;
							left = NULL;	
						}else
						{
							left = ns[0]->expr;
							ns[0]->expr = NULL;
							AR_ASSERT(left != NULL);
						}

						AR_ASSERT(ns[1] != NULL);
						tok = ns[1]->token;


						if(ns[2] == NULL)
						{
							parser->has_error = true;
							right = NULL;	
						}else
						{
							right = ns[2]->expr;
							ns[2]->expr = NULL;
							AR_ASSERT(right != NULL);
						}

						switch(tok.term_val)
						{
						case TOK_INC:
							op = TGU_OP_PLUS;
							break;
						case TOK_SUB :
							op = TGU_OP_MINUS;
							break;
						case TOK_MUL:
							op = TGU_OP_MUL;
							break;
						case TOK_DIV:
							op = TGU_OP_DIV;
							break;
						case TOK_MOD:
							op = TGU_OP_MOD;
							break;
						case TOK_LESS:
							op = TGU_OP_LESS;
							break;
						case TOK_LE:
							op = TGU_OP_LESS_OR_EQUAL;
							break;
						case TOK_GREATER:
							op = TGU_OP_GREATER;
							break;
						case TOK_GE:
							op = TGU_OP_GREATER_OR_EQUAL;
							break;
						case TOK_EQ:
							op = TGU_OP_IS_EQUAL;
							break;
						case TOK_NE:
							op = TGU_OP_NOT_EQUAL;
							break;
						case TOK_ANDAND:
							op = TGU_OP_LOGICAL_AND;
							break;
						case TOK_OROR:
							op = TGU_OP_LOGICAL_OR;
							break;
						default:
							op = TGU_OP_NONE;/*op如果在此不赋值会导致一个warning*/
							AR_ASSERT(false);
							break;
						}

						lex_info  = left != NULL ? &left->lex_info : &tok.lex_info;
						AR_ASSERT(lex_info != NULL);
						expr = make_binary_expression(parser, op, left, right, lex_info);
						ret = __create_synnode(TGU_NODE_EXPR_T, (void*)expr);
						return ret;
					:}
					;


%code {:

	static tguExpr_t*		make_unary_expression(tguParser_t	*parser, 	tguExprOP_t op, tguExpr_t *expr, bool_t is_lvalue, const tguLexInfo_t *lex_info)
	{
			tguExpr_t	*ret;
			wchar_t 	msg[512];
			const 		wchar_t *op_str;
			AR_ASSERT(parser != NULL && lex_info != NULL);
			
			ret = TGU_CreateExpr(TGU_ET_UNARY);
			ret->is_lvalue = is_lvalue;
			ret->lex_info = *lex_info;
			ret->unary_expr.op = op;
			ret->unary_expr.expr = expr;
			ret->is_constant = expr == NULL ? false : expr->is_constant;
			
			switch(op)
			{
			case TGU_OP_PREINC:
			case TGU_OP_POSTINC:
				op_str = L"++";
				break;
			case TGU_OP_PREDEC:
			case TGU_OP_POSTDEC:
				op_str = L"--";
				break;
			default:
				op_str = NULL;
				break;
			}

			if(op_str != NULL && !ret->is_lvalue)
			{
				parser->has_error = true;
				AR_swprintf(msg, 512, L"error : '%ls' needs l-value\r\n", op_str);
				TGU_ReportError(&parser->report, msg, lex_info->linenum);

			}
			
			return ret;
	}



	static tguExpr_t*	make_index_expression(tguParser_t *parser, tguExpr_t *expr, tguExpr_t *index_expr, const tguLexInfo_t *lex_info)
	{
		tguExpr_t	*ret;
		wchar_t msg[512];

		AR_ASSERT(parser != NULL && lex_info != NULL);

		if(expr != NULL)
		{
			if(expr->is_constant)
			{
				parser->has_error = true;
				AR_swprintf(msg, 512, L"%ls\r\n", L"error : invalid table action");
				TGU_ReportError(&parser->report, msg, lex_info->linenum);
			}
		}
		
		ret = TGU_CreateExpr(TGU_ET_INDEX);
		ret->index_expr.expr = expr;
		ret->index_expr.index_expr = index_expr;
		ret->is_lvalue = expr == NULL ? true : expr->is_lvalue;
		ret->is_constant = false;
		ret->lex_info = *lex_info;

		return ret;
	}


	static tguExpr_t*		make_identifier_expression(tguParser_t	*parser, tguToken_t *token)
	{
			tguExpr_t	*expr;
			tguSymb_t	*symb;
			tguSymbType_t	t;
			AR_ASSERT(parser != NULL && token != NULL);
			AR_ASSERT(parser->top_block != NULL);
			
			
			for(t = TGU_SYMB_VAR_T, symb = NULL; t <= TGU_SYMB_BLOCK_T && symb == NULL; ++t)
			{
				symb = TGU_FindSymbFromBlock(parser->top_block, token->token, t, false);
			}
				
			if(symb == NULL)
			{
				wchar_t msg[512];
				expr = TGU_CreateExpr(TGU_ET_UNDEF_NAME);
				expr->name = token->token;
				parser->has_error = true;
				AR_swprintf(msg, 512, L"error : '%ls' : undeclared identifier", token->token);
				TGU_ReportError(&parser->report, msg, token->lex_info.linenum);
				
			}else
			{
				expr = TGU_CreateExpr(TGU_ET_SYMBOL);
				expr->symb = symb;
			}
			
			expr->is_lvalue = true;
			expr->is_constant = false;
			expr->lex_info = token->lex_info;
			return expr;
	}


	static tguExpr_t*		make_constant_expression(tguParser_t	*parser, tguToken_t *token)
	{
			tguSymb_t		*symb;
			tguSymbTbl_t		*symb_tbl;
			tguExpr_t		*expr;
			AR_ASSERT(parser != NULL && token != NULL); 
			
			expr = NULL;
			symb = NULL;
			symb_tbl = TGU_GetBlockSymbolTable(parser->abs_tree);
			AR_ASSERT(symb_tbl != NULL);

			switch(token->term_val)
			{
			default:
				AR_ASSERT(false);
				break;
			case TOK_NULL:
				symb = TGU_InstallNull(symb_tbl);
				break;
			case TOK_TRUE:
				symb = TGU_InstallBoolean(symb_tbl, true);
				break;
			case TOK_FALSE:
				symb = TGU_InstallBoolean(symb_tbl, false);
				break;
			case TOK_FLOAT_NUMBER:
			{
				double df;
				AR_wtod(token->token, &df);
				symb = TGU_InstallFloat(symb_tbl, df); 
			}
				break;
			case TOK_INT_NUMBER:
			{
				int_64_t	num;
				AR_wtoi64(token->token, &num, 0);/*0表示AR_wtoi64自动识别*/
				symb = TGU_InstallInt(symb_tbl, num); 
			}
				break;
			case TOK_STRING:
				TGU_InstallString(symb_tbl, token->token);
				break;
			}
			
			expr = TGU_CreateExpr(TGU_ET_SYMBOL);
			expr->is_lvalue = false;
			expr->is_constant = true;
			expr->lex_info = token->lex_info;
			expr->symb = symb;
			return expr;
	}
:}
;




unary_expression		:	"+"	unary_expression	%action	on_unary_expression
				|	"-"	unary_expression	%action	on_unary_expression
				|	"!"	unary_expression	%action	on_unary_expression
				|	"++" 	unary_expression	%action	on_unary_expression
				|	"--"	unary_expression	%action	on_unary_expression
				{:
						tguSynNode_t	**ns = (tguSynNode_t**)nodes;
						tguSynNode_t 	*ret;
						tguParser_t	*parser = (tguParser_t*)ctx;
						tguExpr_t		*expr;

						tguExprOP_t		op;
						tguToken_t		tok;
						const tguLexInfo_t	*lex_info;
						bool_t			is_lvalue;
						AR_ASSERT(ns != NULL && count == 2 && parser != NULL);
			
						if(ns[1] == NULL)
						{
							parser->has_error = true;
							expr = NULL;	
						}else
						{
							expr = ns[1]->expr;
							ns[1]->expr = NULL;
							AR_ASSERT(expr != NULL);
						}

						AR_ASSERT(ns[0] != NULL);
						tok = ns[0]->token;	
						
						switch(tok.term_val)
						{
						case TOK_INC:
							op = TGU_OP_PREINC;
							is_lvalue = true;
							break;
						case TOK_DEC:
							op = TGU_OP_PREDEC;
							is_lvalue = true;
							break;
						case TOK_ADD:
							op = TGU_OP_UNARY_PLUS;
							is_lvalue = false;
							break;
						case TOK_SUB:
							op = TGU_OP_UNARY_MINUS;
							is_lvalue = false;
							break;
						case TOK_NOT:
							op = TGU_OP_LOGICAL_NOT;
							is_lvalue = false;
							break;
						default:
							op = TGU_OP_NONE;
							is_lvalue = false;
							AR_ASSERT(false);
							break;
						}
						lex_info = expr != NULL ? &expr->lex_info : &tok.lex_info;
						expr = make_unary_expression(parser, op, expr, is_lvalue, lex_info);
						ret = __create_synnode(TGU_NODE_EXPR_T, (void*)expr);
						return ret;

				:}

				|	postfix_expression		%action 	auto_return_0
				;



postfix_expression		:	postfix_expression	"++"		%action	on_post_add_minus_expression
				|	postfix_expression	"--"		%action	on_post_add_minus_expression
				{:
						tguSynNode_t		**ns = (tguSynNode_t**)nodes;
						tguSynNode_t 		*ret;
						tguParser_t		*parser = (tguParser_t*)ctx;
						tguExpr_t		*expr;
						tguToken_t		tok;
						tguExprOP_t		op;
						const tguLexInfo_t	*lex_info; 

						AR_ASSERT(ns != NULL && count == 2 && parser != NULL);

						if(ns[0] == NULL)
						{
							parser->has_error = true;
							expr = NULL;	
						}else
						{
							expr = ns[0]->expr;
							ns[0]->expr = NULL;
							AR_ASSERT(expr != NULL);
						}

						AR_ASSERT(ns[1] != NULL );
						tok = ns[1]->token;	
							
						switch(tok.term_val)	
						{
						case TOK_INC:
							op = TGU_OP_POSTINC;
							break;
						case TOK_DEC:
							op = TGU_OP_POSTDEC;
							break;
						default:
							op = TGU_OP_NONE;
							AR_ASSERT(false);
							break;
						}
						
						lex_info = expr != NULL ? &expr->lex_info : &tok.lex_info;
						expr = make_unary_expression(parser, op, expr, false, lex_info);
						ret = __create_synnode(TGU_NODE_EXPR_T, (void*)expr);
						return ret;
				:}

				|	postfix_expression "[" expression "]"		%action	on_index_expression
				|	postfix_expression "[" error "]"			%action	on_index_expression
				{:
					
						tguSynNode_t	**ns = (tguSynNode_t**)nodes;
						tguSynNode_t 	*ret;
						tguParser_t	*parser = (tguParser_t*)ctx;
						tguExpr_t		*expr, *index_expr;
						const tguLexInfo_t	*lex_info;
						AR_ASSERT(ns != NULL && count == 4 && parser != NULL);

						if(ns[0] == NULL)
						{
							parser->has_error = true;
							expr = NULL;
						}else
						{
							expr = ns[0]->expr;
							ns[0]->expr = NULL;
							AR_ASSERT(expr != NULL);
						}

						if(ns[2] == NULL)
						{
							index_expr = NULL;
							parser->has_error = true;
						}else
						{
							index_expr = ns[2]->expr;
							ns[2]->expr = NULL;
							AR_ASSERT(index_expr != NULL);
						}

						lex_info = expr != NULL ? &expr->lex_info : &ns[1]->token.lex_info;
						expr = make_index_expression(parser, expr, index_expr, lex_info);
						ret = __create_synnode(TGU_NODE_EXPR_T, (void*)expr);
						return ret;
				:}
				|	postfix_expression 	"."	NAME	%action	on_access_name_expression
				{:
						tguSynNode_t		**ns = (tguSynNode_t**)nodes;
						tguSynNode_t		*ret;
						tguParser_t		*parser = (tguParser_t*)ctx;
						tguExpr_t		*expr, *index_expr;
						tguToken_t		tmp;
						const tguLexInfo_t	*lex_info;
						AR_ASSERT(ns != NULL && count == 3 && parser != NULL);

						if(ns[0] == NULL)
						{
							parser->has_error = true;
							expr = NULL;
						}else
						{
							expr = ns[0]->expr;
							ns[0]->expr = NULL;
							AR_ASSERT(expr != NULL);
						}

						tmp = ns[2]->token;
						tmp.term_val = TOK_STRING;
						tmp.token = ns[2]->token.token;
						index_expr = make_constant_expression(parser, &tmp);
						AR_ASSERT(index_expr != NULL);
						tmp.token = NULL;

						lex_info = expr != NULL ? &expr->lex_info : &index_expr->lex_info;
						expr = make_index_expression(parser, expr, index_expr, lex_info);
						ret = __create_synnode(TGU_NODE_EXPR_T, (void*)expr);
						return ret;
				:}

				|	call_expression				%action auto_return_0
				|	primary_expression				%action auto_return_0
				;	
				




primary_expression		:	"(" expression")"							%action	on_lp_rp_expression
				|	"(" error ")"								%action	on_lp_rp_expression
				{:
					tguParser_t	*parser = (tguParser_t*)ctx;
					psrNode_t 	*ret;
					if(nodes[1] == NULL)
					{
						parser->has_error = true;
						ret = NULL;
					}else
					{
						ret = nodes[1];
						nodes[1] = NULL;
					}
					return ret;
				:}

				|	NAME										%action	on_identifier_expression
				{:
						tguSynNode_t		**ns = (tguSynNode_t**)nodes;
						tguSynNode_t 		*ret;
						tguParser_t		*parser = (tguParser_t*)ctx;
						tguExpr_t		*expr;
						AR_ASSERT(parser != NULL && ns != NULL && count == 1);
						expr = make_identifier_expression(parser, &ns[0]->token);
						
						ret = __create_synnode(TGU_NODE_EXPR_T, (void*)expr);
						return ret;

				:}

				|	FLOAT_NUMBER			%action	on_constant_expression
				|	INT_NUMBER			%action	on_constant_expression
				|	STRING				%action	on_constant_expression
				|	"true"				%action	on_constant_expression
				|	"false"			%action	on_constant_expression
				|	"null"				%action	on_constant_expression
				{:
						tguSynNode_t	**ns = (tguSynNode_t**)nodes;
						tguSynNode_t 	*ret;
						tguParser_t	*parser = (tguParser_t*)ctx;
						tguExpr_t		*expr;
						AR_ASSERT(parser != NULL && ns != NULL && count == 1);
						expr = make_constant_expression(parser, &ns[0]->token);
						
						ret = __create_synnode(TGU_NODE_EXPR_T, (void*)expr);
						return ret;
				:}
				;





/*辅助函数*/
%code {:
	static tguExpr_t*		make_call_expression(tguParser_t	*parser, tguExpr_t *call_expr, tguExpr_t *args, const tguLexInfo_t *lex_info)
	{
			tguExpr_t *expr;
			AR_ASSERT(parser != NULL && lex_info != NULL);

			expr = TGU_CreateExpr(TGU_ET_FUNC_CALL);
			expr->is_lvalue = false;
			expr->is_constant = false;
			expr->lex_info = *lex_info;
			
			expr->func_call_expr.func_call = call_expr;
			expr->func_call_expr.arg_list = args;

			return expr;
	}
:}
;


call_expression		:	postfix_expression "(" expression_list ")"		%action	on_call_expression
				|	postfix_expression "(" error ")"				%action	on_call_expression
				|	postfix_expression "(" 	")"				%action	on_call_expression
				{:
						tguSynNode_t		**ns = (tguSynNode_t**)nodes;
						tguSynNode_t 		*ret;
						tguParser_t	*parser = (tguParser_t*)ctx;
						tguExpr_t		*expr, *call_expr, *args;
						const tguLexInfo_t	*lex_info;

						/*如果postfix_expression 为空，则表明此call表达式错误*/
						if(ns[0] == NULL)				
						{
							parser->has_error = true;
							call_expr = NULL;
						}else
						{
							call_expr= ns[0]->expr;
							ns[0]->expr = NULL;
						}


						if(count == 4)
						{
							if(ns[2] == NULL)/*对应"(" error ")"*/
							{
								args = NULL;
								parser->has_error = true;
							}else
							{
								args = ns[2]->expr;
								ns[2]->expr = NULL;
								AR_ASSERT(args != NULL);
							}
						}else
						{
						
							AR_ASSERT(count == 3);
							args = NULL;
						}
						
						lex_info = call_expr != NULL ? &call_expr->lex_info : &ns[1]->token.lex_info;
						expr = make_call_expression(parser, call_expr, args, lex_info );
						
						ret = __create_synnode(TGU_NODE_EXPR_T, (void*)expr);
						return ret;
				:}
				;




expression_list		:	expression					%action	auto_return_0
				|	expression_list "," expression		%action	on_expression_list
				{:
						tguSynNode_t	**ns = (tguSynNode_t**)nodes;
						tguSynNode_t	*ret;
						tguExpr_t		*lst;
						AR_ASSERT(ns != NULL && count == 3);
						if(ns[0] == NULL) return ns[2];
						if(ns[2] == NULL) return ns[0];
						AR_ASSERT(ns[0]->expr != NULL  && ns[2]->expr != NULL);

						for(lst = ns[0]->expr; lst->next != NULL; lst = lst->next);
						
						lst->next = ns[2]->expr;
						ns[2]->expr = NULL;
						ret = ns[0];
						ns[0] = NULL;
						return ret;
				:}
				;






%name delim            :    "[\t\r\n ]+"
                        ;

%name letter        :     "[A-Z_a-z]"
                    ;


%name digit            :    "[0-9]"
                        ;

%name number            :    "0|[1-9]{digit}*"
                        ;

%name name              :    "{letter}({letter}|{digit})*"
                        ;


%name lexeme                :    "{name}"
                            ;


%name comment            :     "/\*([^\*]|\*+[^\*/])*\*+/"
                            ;

%name comment_line        :     "//[^\n]*\n"
                            ;

%name skip_lexem         :     "{delim}|{comment}|{comment_line}"
                            ;


%name key_lookahead           :     '{skip_lexem}+|"{"'
                            ;


%code header{:
/*
 * MarshalDie
 * Copyright (c) 2012 by Solidus
 * 
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.It is provided "as is" without express 
 * or implied warranty.
 *
 */

:}
;


%code include{:

#include <vector>
#include <list>
#include <string>
#include <set>
#include <map>
#include "Arsenal.h"

:}
;


%code class_def{:

typedef enum
{
        BYET_T,

        INT8_T,
        UINTT8_T,
        
        INT16_T,
        UINTT16_T,
        
        INT32_T,
        UINTT32_T,
        
        INT64_T,
        UINTT64_T,

        CHAR_T,
        WCHAR_T,
        
        FLOAT_T,
        DOUBLE_T,
        
        CUSTOM_T,
}FieldType_t;


const wchar_t* __g_inner_type[CUSTOM_T] = 
{
        L"byte_t",
        L"int_8_t",
        L"uint_8_t",
        L"int_16_t",
        L"uint_16_t",
        L"int_32_t",
        L"uint_32_t",
        L"int_64_t",
        L"uint_64_t",

	 L"float",
        L"double",

        L"char",
        L"wchar_t",
        
};


static bool_t is_inner_type(FieldType_t t)
{
        switch(t)
        {
                case BYET_T:
                case INT8_T:
                case UINTT8_T:
                case INT16_T:
                case UINTT16_T:
                case INT32_T:
                case UINTT32_T:
                case INT64_T:
                case UINTT64_T:
                case CHAR_T:
                case WCHAR_T:
                        return true;
                case CUSTOM_T:
                default:
                        return false;
        };
}



static bool_t is_inner_type_name(const wchar_t *name)
{
        for(size_t i = 0; i < CUSTOM_T; ++i)
        {
                if(AR_wcscmp(name, __g_inner_type[i]) == 0)
                {
                        return true;
                }
        }
        
        return false;
}

static const wchar_t* get_inner_type_name(FieldType_t t)
{
        AR_ASSERT(is_inner_type(t));
        return __g_inner_type[t];
}


typedef struct Type					Type_t;
typedef struct Field					Field_t;
typedef std::map<std::wstring, Field_t*>    	FieldMap;



typedef struct Field
{
	std::wstring		name;
	Type_t			*type;
	bool_t			is_array;
	size_t			array_size;
}Field_t;



typedef struct Type
{
        FieldType_t             type;
        bool_t                  is_inner_type;

        std::wstring            name;
        
        FieldMap                fields;
}Type_t;




std::vector<Type_t*>    			g_type_list;
std::vector<std::wstring>			g_head_code;
std::vector<std::wstring>			g_tail_code;


:}
;


%code {:
/******************************************************************************************/
:};


%code {:




typedef enum
{
	FIELD_T,
	TYPE_T,
	NAME_T,
	NUM_T,
	CODEBLOCK_T,
}astNodeType_t;

typedef struct node_tag
{
	astNodeType_t		t;
	size_t			line;
	union{
		Field_t	*field;
		Type_t		*type;
		wchar_t	name[256];
		uint_64_t	num;
		struct {
			bool_t		is_tail;
			wchar_t	*code;
		}code_block;
	};
}ast_node_t;

:};


%token    %skip                	:    "{skip_lexem}+"
                        		;


%token    CODE_BLOCK        :    '\{:[^\u0]*?:\}'            %value "TOK_CLODE_BLOCK"	%action on_codeblock
				{:
						
						ast_node_t	*node = AR_NEW0(ast_node_t);
						node->t = CODEBLOCK_T;
						node->line = tok->line;
						node->code_block.code = AR_wcsndup(tok->str + 2, tok->str_cnt - 2);
						node->code_block.is_tail = false;
						psrRetVal_t ret = {AR_S_YES, (psrToken_t*)node}; 
						return ret;
				:}
                		;


%token    HEAD        	:    '"%head"'			%value "TOK_HEAD"		
                		;

%token    TAIL        	:    '"%tail"'			%value "TOK_TAIL"
				;


%token    LEXEME        	:    "{lexeme}"			%value "TOK_NAME"		%action on_codeblock
				{:
						ast_node_t	*node = AR_NEW0(ast_node_t);
						node->t = NAME_T;
						node->line = tok->line;
						if(tok->str_cnt >= 256)
						{
							wchar_t *tmp = AR_wcsndup(tok->str, tok->str_cnt);
							AR_error(AR_ERR_FATAIL, L"invalid name length : '%ls' line : %Iu!", tmp, tok->line );
							AR_abort();
						}
						
						AR_wcsncpy(node->name, tok->str, tok->str_cnt);
						node->name[tok->str_cnt] = L'\0';
						psrRetVal_t ret = {AR_S_YES, (psrToken_t*)node}; 
						return ret;
				:}
                        	;
                

%token    NUMBER        	:    "{number}"			%value "TOK_NUM"		%action on_number
				{:
						ast_node_t	*node = AR_NEW0(ast_node_t);
						node->t = NUM_T;
						node->line = tok->line;
						if(AR_wtou64_s(tok->str, tok->str + tok->str_cnt, &node->num, 10) == NULL)
						{
							wchar_t *tmp = AR_wcsndup(tok->str, tok->str_cnt);
							AR_error(AR_ERR_FATAIL, L"invalid number : '%ls' line : %Iu!", tmp, tok->line);
							AR_abort();
						}

						psrRetVal_t ret = {AR_S_YES, (psrToken_t*)node}; 
						return ret;

				:}
                        	;


%token    ":"            	:    '":"'					
                        	;

%token    ";"            	:    '";"'
                        	;

%token    "{"            	:    '"{"'
                        	;

%token    "}"            	:    '"}"'
                        	;


%token    "["            	:    '"["'
                        	;

%token    "]"            	:    '"]"'
                        	;



%start          program    ;



program         :    item_list
                |    .
                ;


item_list       :    item_list    item
                |    item
                ;



item  		  :    head_code
                |    tail_code
                |    named_type_def
                ;


head_code       	:    HEAD     CODE_BLOCK		%action on_head_code_def
			{:	
				ast_node_t *n = (ast_node_t*)nodes[1];
				AR_ASSERT(n != NULL);
				if(n->codeblock.code)
				{
					g_head_code.push_back(n->codeblock.code);
				}
			:}
                	;


tail_code       	:    TAIL    CODE_BLOCK			%action on_head_code_def
			{:	
				ast_node_t *n = (ast_node_t*)nodes[1];
				AR_ASSERT(n != NULL);
				if(n->codeblock.code)
				{
					g_tail_code.push_back(n->codeblock.code);
				}
			:}
			;



named_type_def  	:    LEXEME    anonymous_type_def ";"	%action on_named_type_def
			{:
				
			:}
                	;

anonymous_type_def   :    "{"    field_def_list    "}"
                	;

field_def_list	:    field_def_list	field_def
	              |    field_def
                	;


/*field_type节点为Filed_t*，这里将其命名，并当做综合属性传递给上层*/
field_def		:    field_name    ":"    field_type    ";"
                	;


field_name         	:    LEXEME        %action    auto_return_0
                	{:
				psrRetVal_t ret = {AR_S_YES, nodes[0]};
		              nodes[0] = NULL;
		              return ret;
	             :}
			;


/*创建一个Field_t，并当做综合属性，传递给上层，这里只能解决类型和是否为数组的问题，上层负责命名*/

field_type		:    LEXEME						%action on_named_type_name
			{:
				psrRetVal_t	ret = {AR_S_YES, NULL};		/*搜索g_type_list,有返回Type节点， 否则报告错误程序终止*/


				return ret;
			:}
	
			|    LEXEME "["    NUMBER "]"			%action on_named_array_type
			{:
				psrRetVal_t	ret = {AR_S_YES, NULL};		/*搜索g_type_list,如果未找到则程序终止，返回Type节点*/


				return ret;
			:}
			
			|    anonymous_type_def					%action	on_named_anonymous_type				
			{:
				psrRetVal_t	ret = {AR_S_YES, NULL};		/*创建Type*并加入g_type_list*/

				return ret;
			:}

                	;







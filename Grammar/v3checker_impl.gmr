




%name	delim 			:	"[ \r\n\t]"			
				;
%name	comment		:	"/\*([^\*]|\*+[^\*/])*\*+/"	
				;
%name	comment_line		:	"//[^\n]*\n"			
				;

%name skip_lexem		:	"{delim}|{comment}|{comment_line}"
				;



/*  '"'  == \x22,  '\'' == \x27 */

%name	escape_seq		:	"(\\(\x22|\x27))"	
				;

%name	string_dq		: 	"(\x22({escape_seq}|[^\x22])*\x22)"		//只能提取"..."或"\""此类串，其它C规则要到语义例程中处理	
				;

%name	string_sq		:	"\x27({escape_seq}|[^\x27])*\x27"		//提取'...'或'\''此类串，其它C规则要到语义例程中处理	
				;


%name	file_variable		:	"%fver_([^%])+%"						//提取%xxx% 变量
				;


%name	variable		:	"%([^%])+%"							//提取%xxx% 变量
				;







/************************************************************************************************/


/*
\x{4E00}-\x{9FA5}     	(中文)
\x{3130}-\x{318F}     	(韩文)
\x{AC00}-\x{D7A3}    	(韩文)
\x{0800}-\x{4E00}    	(日文)
*/

//ASCII + 中日韩

%name    letter         :    "[A-Z_a-z\x{0800}-\x{4E00}\x{4E00}-\x{9FA5}\x{3130}-\x{318F}\x{AC00}-\x{D7AF}]"
                        ;


%name    digit          :    "[0-9]"                
                        ;

%name    number         :    "{digit}+"                
                        ;



/***********************************Token*********************************/

%token %skip			:	"{skip_lexem}+"				,1		%value	"TOK_DELIM_ID"	;//空白，需要过滤







%code {:
/******************************************************************************************/
:};


%code {:

typedef enum
{
	OPERATOR_T,
	VARIABLE_T,
	CONSTANT_T,
	NAME_T,
	EXPR_T,
	CALL_T,
}checkerNodeType_t;


struct __checker_expression_node_tag;
typedef struct __checker_expression_node_tag	exprNode_t;

typedef enum
{
	CHECKER_EXPR_OR,
	CHECKER_EXPR_AND,

	CHECKER_EXPR_LESS,
	CHECKER_EXPR_GREATER,
	CHECKER_EXPR_LE,
	CHECKER_EXPR_GE,

	CHECKER_EXPR_EQ,
	CHECKER_EXPR_NE,

	CHECKER_EXPR_NOT,

}exprOperator_t;


typedef struct __var_node_tag
{
	ar_bool_t	is_file_check;
	wchar_t	name[1024];
}var_t;


typedef struct __constant_node_tag
{
	wchar_t	constant[1024];			//根据需要解析此字符串
}constant_t;

typedef struct __name_node_tag
{
	wchar_t	name[1024];				//根据此名称调用函数
}name_t;


typedef struct __expr_node_tag
{
	exprOperator_t	op;
	exprNode_t		*left;
	exprNode_t		*right;
}expr_t;

typedef struct __call_node_tag
{
	wchar_t	name[256];		//最大256个名称
	exprNode_t	*params[32];		//最大32个参数
	size_t		param_count;
}call_t;


struct __checker_expression_node_tag
{
	checkerNodeType_t	t;
	size_t			line;
	size_t			col;

	union{
		exprOperator_t	op;
		var_t			var;
		constant_t		constant;
		name_t			name;
		expr_t			expr;
		call_t			call;
	};
};


exprNode_t*	CreateExprNode(checkerNodeType_t	t)
{
	exprNode_t	*node;

	node = AR_NEW0(exprNode_t);

	if(node == NULL)
	{
		AR_error(AR_ERR_WARNING, L"low mem : %hs\r\n", AR_FUNC_NAME);
		return NULL;
	}

	node->t = t;
	reuturn node;
}

void		DestroyExprNode(exprNode_t *node)
{
	AR_ASSERT(node != NULL);

	switch(node->t)
	{
	case 	OPERATOR_T:
		break;
	case 	VARIABLE_T:
		break;
	case 	CONSTANT_T:
		break;
	case 	NAME_T:
		break;
	case	EXPR_T:
	{
		if(node->expr.left)
		{
			DestroyExprNode(node->expr.left);
			node->expr.left = NULL;
		}

		if(node->expr.right)
		{
			DestroyExprNode(node->expr.right);
			node->expr.right= NULL;
		}
	}
		break;
	case	CALL_T:
	{
		size_t i;
		for(i = 0; i < node->call.count; ++i)
		{
			if(node->call.params[i] != NULL)
			{
				DestroyExprNode(node->call.params[i]);
				node->call.params[i] = NULL;
			}
		}
	}
		break;
	default:
		AR_ASSERT(false);
	}
	
	if(node)
	{
		AR_DEL(node);
		node = NULL;
	}
}




:};



%token	CONSTANT	:	"{string_sq}|{string_dq}"			,2		%value 	"TOK_CONSTANT"		%action on_constant
				{:
						psrRetVal_t	ret;
						exprNode_t	*expr_node;

						AR_ASSERT(tok != NULL);
						AR_UNUSED(ctx);

						AR_memset(&ret, 0, sizeof(ret));

						expr_node = NULL;
						expr_node =	CreateExprNode();
						
						if(expr_node == NULL)
						{
							AR_error(AR_ERR_WARNING, L"low mem : %hs\r\n", AR_FUNC_NAME);
							ret.status = AR_E_NOMEM;
							ret.node = NULL;
							return ret;
						}

						node->t = CONSTANT_T;
						node->line = tok->line;
						node->col = tok->col;

						if(tok->str_cnt >= 1024 || tok->str_cnt <= 2)
						{
							AR_error(AR_ERR_WARNING, L"invalid constant length, line : (%Iu, %Iu)!", tok->line, tok->col);
							DestroyExprNode(expr_node);
							ret.status = AR_E_INVAL;
							ret.node = NULL;
							return ret;
						}
						
						AR_wcsncpy(node->constant.constant, tok->str, tok->str_cnt);
						node->name[tok->str_cnt] = L'\0';
						ret.status = AR_S_YES;
						ret.node = (psrToken_t*)expr_node;
						return ret;
				:}
                        	;

			;

%token FILE_VAR	:	"{file_variable}"				,2		%value		"TOK_FILE_VAR"		
			;


%token VAR		:	"{variable}"					,2		%value		"TOK_VAR"			
			;



%token NAME     	:    "{letter}({letter}|{digit})*"              ,2		%value    	"TOK_NAME"           	
			;





%token	"<="		:	'"<="'		,1						%value 	"TOK_LE"			
			;

%token	">="		:	'">="'		,1						%value 	"TOK_GE"			
			;

%token	"=="		:	'"=="'		,1						%value 	"TOK_EQ"			
			;

%token	"!="		:	'"!="'		,1						%value		"TOK_NE"			
			;


%token	"&&"		:	'"&&"'		,1						%value 	"TOK_ANDAND"			
			;

%token	"||"		:	'"||"'		,1						%value		"TOK_OROR"			
			;


%token	"("		:	'"("'		,0						%value "TOK_L_PAREN"			
			;

%token	")"		:	'")"'		,0						%value "TOK_R_PAREN"			
			;


%token	"<"		:	'"<"'		,0						%value	"TOK_LESS"			
			;

%token	">"		:	'">"'		,0						%value	"TOK_GREATER"			
			;

%token	"!"		:	'"!"'		,0						%value "TOK_NOT"			
			;

%token	","		:	'","'		,0						%value "TOK_COMMA"
			;









%left	"||"						;
%left 	"&&"						;
%left	">" 	"<" 	"<="	">="			;
%left 	"=="	"!="					;
%right     NOTEXPR            			;



%start		expression					;


expression 	:	expr
		;

	
expr		:	"("	 expr	")"
		|	"("	error ")"
     		|	expr "&&"	expr
     		|	expr "||"	expr
     		|	expr "<="	expr
     		|	expr ">="	expr
     		|	expr "<"	expr
     		|	expr ">"	expr
     		|	expr "=="	expr
     		|	expr "!="	expr
		|	call
		|	unary_expr
		|	term
		;

unary_expr	:	"!" expr			%prec	NOTEXPR
		;


term		:	VAR
		|	CONSTANT
		|	FILE_VAR
		;


call		:	NAME	"(" params ")"
		;





params        :    params "," param		
              |    param	
		|	.			
              ;


param		:	CONSTANT
		|	VAR
		|	FILE_VAR
		;


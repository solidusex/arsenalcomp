




%name	delim 			:	"[ \r\n\t]"			
				;
%name	comment		:	"/\*([^\*]|\*+[^\*/])*\*+/"	
				;
%name	comment_line		:	"//[^\n]*\n"			
				;

%name skip_lexem		:	"{delim}|{comment}|{comment_line}"
				;



/*  '"'  == \x22,  '\'' == \x27 */

%name	escape_seq		:	"(\\(\x22|\x27))"	
				;

%name	string_dq		: 	"(\x22({escape_seq}|[^\x22])*\x22)"		//只能提取"..."或"\""此类串，其它C规则要到语义例程中处理	
				;

%name	string_sq		:	"\x27({escape_seq}|[^\x27])*\x27"		//提取'...'或'\''此类串，其它C规则要到语义例程中处理	
				;


%name	file_variable		:	"%fver_([^%])+%"						//提取%xxx% 变量
				;


%name	variable		:	"%([^%])+%"							//提取%xxx% 变量
				;







/************************************************************************************************/


/*
\x{4E00}-\x{9FA5}     	(中文)
\x{3130}-\x{318F}     	(韩文)
\x{AC00}-\x{D7A3}    	(韩文)
\x{0800}-\x{4E00}    	(日文)
*/

//ASCII + 中日韩

%name    letter         :    "[A-Z_a-z\x{0800}-\x{4E00}\x{4E00}-\x{9FA5}\x{3130}-\x{318F}\x{AC00}-\x{D7AF}]"
                        ;


%name    digit          :    "[0-9]"                
                        ;

%name    number         :    "{digit}+"                
                        ;



/***********************************Token*********************************/

%token %skip			:	"{skip_lexem}+"				,1		%value	"TOK_DELIM_ID"	;//空白，需要过滤







%code {:
/******************************************************************************************/
:};


%code {:

typedef enum
{
	VARIABLE_T,
	CONSTANT_T,
	NAME_T,
	EXPR_T,
	CALL_T,
}checkerNodeType_t;


struct __checker_expression_node_tag;
typedef struct __checker_expression_node_tag	exprNode_t;

typedef enum
{
	CHECKER_EXPR_OR,
	CHECKER_EXPR_AND,

	CHECKER_EXPR_LESS,
	CHECKER_EXPR_GREATER,
	CHECKER_EXPR_LE,
	CHECKER_EXPR_GE,

	CHECKER_EXPR_EQ,
	CHECKER_EXPR_NE,

	CHECKER_EXPR_NOT,

}exprOperator_t;

#define IsBinaryOperator(_op)	((_op) < CHECKER_EXPR_NOT)


typedef struct __var_node_tag
{
	ar_bool_t	is_file_check;
	wchar_t	name[1024];
}var_t;


typedef struct __constant_node_tag
{
	wchar_t	constant[1024];			//根据需要解析此字符串
}constant_t;

typedef struct __name_node_tag
{
	wchar_t	name[1024];				//根据此名称调用函数
}name_t;


typedef struct __expr_node_tag
{
	exprOperator_t	op;
	exprNode_t		*left;
	exprNode_t		*right;
}expr_t;

typedef struct __call_node_tag
{
	wchar_t	name[256];		//最大256个名称
	exprNode_t	*params[32];		//最大32个参数
	size_t		param_cnt;
}call_t;


struct __checker_expression_node_tag
{
	checkerNodeType_t	t;
	size_t			line;
	size_t			col;

	union{
		var_t			var;
		constant_t		constant;
		name_t			name;
		expr_t			expr;
		call_t			call;
	};
};


exprNode_t*	CreateExprNode(checkerNodeType_t	t)
{
	exprNode_t	*node;

	node = AR_NEW0(exprNode_t);

	if(node == NULL)
	{
		AR_error(AR_ERR_WARNING, L"low mem : %hs\r\n", AR_FUNC_NAME);
		return NULL;
	}

	node->t = t;
	return node;
}

void		DestroyExprNode(exprNode_t *node)
{
	AR_ASSERT(node != NULL);

	switch(node->t)
	{
	case 	VARIABLE_T:
		break;
	case 	CONSTANT_T:
		break;
	case 	NAME_T:
		break;
	case	EXPR_T:
	{
		if(node->expr.left)
		{
			DestroyExprNode(node->expr.left);
			node->expr.left = NULL;
		}

		if(node->expr.right)
		{
			DestroyExprNode(node->expr.right);
			node->expr.right= NULL;
		}
	}
		break;
	case	CALL_T:
	{
		size_t i;
		for(i = 0; i < node->call.param_cnt; ++i)
		{
			if(node->call.params[i] != NULL)
			{
				DestroyExprNode(node->call.params[i]);
				node->call.params[i] = NULL;
			}
		}
	}
		break;
	default:
		AR_ASSERT(false);
	}
	
	if(node)
	{
		AR_DEL(node);
		node = NULL;
	}
}




:};



%token	CONSTANT	:	"{string_sq}|{string_dq}"			,2		%value 	"TOK_CONSTANT"		%action on_constant
			{:

					psrRetVal_t	ret;
					exprNode_t	*expr_node;

					AR_ASSERT(tok != NULL);
					AR_UNUSED(ctx);
					AR_memset(&ret, 0, sizeof(ret));

					expr_node = NULL;
					expr_node =	CreateExprNode(CONSTANT_T);
						
					if(expr_node == NULL)
					{
						AR_error(AR_ERR_WARNING, L"low mem : %hs\r\n", AR_FUNC_NAME);
						ret.status = AR_E_NOMEM;
						ret.node = NULL;
						return ret;
					}

					expr_node->line = tok->line;
					expr_node->col = tok->col;

					if(tok->str_cnt >= 1024 || tok->str_cnt <= 2)
					{
						AR_error(AR_ERR_WARNING, L"invalid constant length, (%Iu, %Iu)!", tok->line, tok->col);
						DestroyExprNode(expr_node);
						ret.status = AR_E_MALFORMAT;
						ret.node = NULL;
						return ret;
					}
						
					AR_wcsncpy(expr_node->constant.constant, tok->str + 1, tok->str_cnt - 1);	//消去'xxx'或"xxx"中的'和"
					expr_node->constant.constant[tok->str_cnt - 2] = L'\0';
					ret.status = AR_S_YES;
					ret.node = (psrToken_t*)expr_node;
					return ret;
			:}
                   	;


%token FILE_VAR	:	"{file_variable}"				,2		%value		"TOK_FILE_VAR"		%action on_file_variable
			{:
						psrRetVal_t	ret;
						exprNode_t	*expr_node;

						AR_ASSERT(tok != NULL);
						AR_UNUSED(ctx);

						AR_memset(&ret, 0, sizeof(ret));

						expr_node = NULL;
						expr_node =	CreateExprNode(VARIABLE_T);
						
						if(expr_node == NULL)
						{
							AR_error(AR_ERR_WARNING, L"low mem : %hs\r\n", AR_FUNC_NAME);
							ret.status = AR_E_NOMEM;
							ret.node = NULL;
							return ret;
						}

						expr_node->line = tok->line;
						expr_node->col = tok->col;

						if(tok->str_cnt >= 1024 || tok->str_cnt <= 7)		
						{
							AR_error(AR_ERR_WARNING, L"invalid variable length, (%Iu, %Iu)!", tok->line, tok->col);
							DestroyExprNode(expr_node);
							ret.status = AR_E_MALFORMAT;
							ret.node = NULL;
							return ret;
						}
						
						AR_wcsncpy(expr_node->var.name, tok->str + 6, tok->str_cnt - 1);	//消去%fver_...%中的%fver_和%
						expr_node->var.name[tok->str_cnt - 7] = L'\0';
						expr_node->var.is_file_check = true;
						ret.status = AR_S_YES;
						ret.node = (psrNode_t*)expr_node;
						return ret;
			:}
			;


%token VAR		:	"{variable}"					,2		%value		"TOK_VAR"	%action on_variable
			{:
						psrRetVal_t	ret;
						exprNode_t	*expr_node;

						AR_ASSERT(tok != NULL);
						AR_UNUSED(ctx);

						AR_memset(&ret, 0, sizeof(ret));

						expr_node = NULL;
						expr_node =	CreateExprNode(VARIABLE_T);
						
						if(expr_node == NULL)
						{
							AR_error(AR_ERR_WARNING, L"low mem : %hs\r\n", AR_FUNC_NAME);
							ret.status = AR_E_NOMEM;
							ret.node = NULL;
							return ret;
						}

						expr_node->line = tok->line;
						expr_node->col = tok->col;

						if(tok->str_cnt >= 1024 || tok->str_cnt <= 2)	
						{
							AR_error(AR_ERR_WARNING, L"invalid variable length, (%Iu, %Iu)!", tok->line, tok->col);
							DestroyExprNode(expr_node);
							ret.status = AR_E_MALFORMAT;
							ret.node = NULL;
							return ret;
						}
						
						AR_wcsncpy(expr_node->var.name, tok->str + 1, tok->str_cnt - 1);	//消去%xxx%中的'%'
						expr_node->var.name[tok->str_cnt - 2] = L'\0';
						expr_node->var.is_file_check = false;
						ret.status = AR_S_YES;
						ret.node = (psrNode_t*)expr_node;
						return ret;
			:}
			;



%token NAME     	:    "{letter}({letter}|{digit})*"              ,2		%value    	"TOK_NAME"	%action on_name
			{:
						psrRetVal_t	ret;
						exprNode_t	*expr_node;

						AR_ASSERT(tok != NULL);
						AR_UNUSED(ctx);

						AR_memset(&ret, 0, sizeof(ret));

						expr_node = NULL;
						expr_node =	CreateExprNode(NAME_T);
						
						if(expr_node == NULL)
						{
							AR_error(AR_ERR_WARNING, L"low mem : %hs\r\n", AR_FUNC_NAME);
							ret.status = AR_E_NOMEM;
							ret.node = NULL;
							return ret;
						}

						expr_node->line = tok->line;
						expr_node->col = tok->col;

						if(tok->str_cnt >= 1024)	
						{
							AR_error(AR_ERR_WARNING, L"invalid variable length, (%Iu, %Iu)!", tok->line, tok->col);
							DestroyExprNode(expr_node);
							ret.status = AR_E_MALFORMAT;
							ret.node = NULL;
							return ret;
						}
						
						AR_wcsncpy(expr_node->name.name, tok->str, tok->str_cnt);
						expr_node->name.name[tok->str_cnt] = L'\0';
						ret.status = AR_S_YES;
						ret.node = (psrNode_t*)expr_node;
						return ret;
	
			:}
			;

%code CreateOperatorExprNode{:
	
	exprNode_t*	CreateOperatorExprNode(const psrToken_t *tok)
	{
		exprNode_t	*expr_node;
		AR_ASSERT(tok != NULL);

		expr_node = NULL;
		expr_node =	CreateExprNode(EXPR_T);

		if(expr_node == NULL)
		{
			AR_error(AR_ERR_WARNING, L"low mem : %hs\r\n", AR_FUNC_NAME);
			return NULL;
		}

		expr_node->line = tok->line;
		expr_node->col = tok->col;

		switch(tok->term_val)
		{
		case TOK_LE:
				expr_node->expr.op = CHECKER_EXPR_LE;
				break;
		case TOK_GE:
				expr_node->expr.op = CHECKER_EXPR_GE;
				break;
		case TOK_EQ:
				expr_node->expr.op = CHECKER_EXPR_EQ;
				break;
		case TOK_NE:
				expr_node->expr.op = CHECKER_EXPR_NE;
				break;
		case TOK_ANDAND:
				expr_node->expr.op = CHECKER_EXPR_AND;
				break;
		case TOK_OROR:
				expr_node->expr.op = CHECKER_EXPR_OR;
				break;
		case TOK_LESS:
				expr_node->expr.op = CHECKER_EXPR_LESS;
				break;
		case TOK_GREATER:
				expr_node->expr.op = CHECKER_EXPR_GREATER;
				break;
		case TOK_NOT:
				expr_node->expr.op = CHECKER_EXPR_NOT;
				break;
		default:
		{
				wchar_t tmp[128];
				if(tok->term_val != 0)
				{
						AR_wcsncpy(tmp, tok->str, AR_MIN(tok->str_cnt, 32));
				}else
				{
						AR_wcscpy(tmp, L"%EOI");
				}

				AR_error(AR_ERR_WARNING, L"invalid token type : %ls\r\n", tmp);
				return NULL;
		}
		}
		return expr_node;
	}

:}
;



%token	"<="		:	'"<="'		,1						%value 	"TOK_LE"			%action on_operator
			{:
						psrRetVal_t	ret;
						exprNode_t	*expr_node;

						AR_ASSERT(tok != NULL);
						AR_UNUSED(ctx);

						AR_memset(&ret, 0, sizeof(ret));

						expr_node = NULL;
						expr_node =	CreateOperatorExprNode(tok);
						
						if(expr_node == NULL)
						{
							AR_error(AR_ERR_WARNING, L"low mem : %hs\r\n", AR_FUNC_NAME);
							ret.status = AR_E_NOMEM;
							ret.node = NULL;
						}else
						{
							ret.status = AR_S_YES;
							ret.node = (psrNode_t*)expr_node;
						}
						return ret;
			:}
			;

%token	">="		:	'">="'		,1						%value 	"TOK_GE"	%action on_operator
			;

%token	"=="		:	'"=="'		,1						%value 	"TOK_EQ"	%action on_operator		
			;

%token	"!="		:	'"!="'		,1						%value		"TOK_NE"	%action on_operator		
			;


%token	"&&"		:	'"&&"'		,1						%value 	"TOK_ANDAND"	%action on_operator		
			;

%token	"||"		:	'"||"'		,1						%value		"TOK_OROR"	%action on_operator		
			;



%token	"<"		:	'"<"'		,0						%value	"TOK_LESS"		%action on_operator	
			;

%token	">"		:	'">"'		,0						%value	"TOK_GREATER"		%action on_operator	
			;

%token	"!"		:	'"!"'		,0						%value "TOK_NOT"		%action on_operator	
			;


%token	"("		:	'"("'		,0						%value "TOK_L_PAREN"		%action autoreturn_null
			{:
				psrRetVal_t ret = {AR_S_YES, NULL};
				AR_UNUSED(tok);
				AR_UNUSED(ctx);
				return ret;
			:}	
			;

%token	")"		:	'")"'		,0						%value "TOK_R_PAREN"		%action autoreturn_null
			;


%token	","		:	'","'		,0						%value "TOK_COMMA"		%action autoreturn_null
			;









%left	"||"						;
%left 	"&&"						;
%left	">" 	"<" 	"<="	">="			;
%left 	"=="	"!="					;
%right     NOTEXPR            			;



%start		expression				;


expression 	:	expr				%action autoreturn_0					
		;

	
expr		:	"("	 expr	")"		%action autoreturn_1
		{:
			psrRetVal_t		ret = {AR_S_YES, NULL};
			AR_ASSERT(count == 3 && nodes != NULL);
			
			AR_UNUSED(count);
			AR_UNUSED(name);
			AR_UNUSED(ctx);


			ret.status = AR_S_YES;
			ret.node = (psrNode_t*)nodes[1];
			nodes[1] = NULL;
			return ret;
		:}
     		|	expr "&&"	expr		%action on_binary_expression
		{:
				psrRetVal_t		ret = {AR_S_YES, NULL};
				exprNode_t		**ns = (exprNode_t**)nodes;
				exprNode_t		*res_node;
				AR_ASSERT(ns != NULL && count == 3);
				
				AR_UNUSED(count);
				AR_UNUSED(name);
				AR_UNUSED(ctx);


				res_node = ns[1];
				ns[1] = NULL;

				if(res_node == NULL)
				{
					ret.status = AR_E_ABORT;
					ret.node = NULL;
					return ret;
				}

				res_node->expr.left = ns[0];
				ns[0] = NULL;
				res_node->expr.right = ns[2];
				ns[2] = NULL;
				
				ret.status = AR_S_YES;
				ret.node = res_node;
				return ret;

		:}
     		|	expr "||"	expr		%action on_binary_expression
     		|	expr "<="	expr		%action on_binary_expression
     		|	expr ">="	expr		%action on_binary_expression
     		|	expr "<"	expr		%action on_binary_expression
     		|	expr ">"	expr		%action on_binary_expression
     		|	expr "=="	expr		%action on_binary_expression
     		|	expr "!="	expr		%action on_binary_expression
		|	unary_expr			%action autoreturn_0
		{:
			psrRetVal_t		ret = {AR_S_YES, NULL};
			AR_ASSERT(count == 1 && nodes != NULL);
	
			AR_UNUSED(count);
			AR_UNUSED(name);
			AR_UNUSED(ctx);

			ret.status = AR_S_YES;
			ret.node = (psrNode_t*)nodes[0];
			nodes[0] = NULL;
			return ret;
		:}
		|	call				%action autoreturn_0
		|	term				%action autoreturn_0
		;

unary_expr	:	"!" expr			%prec	NOTEXPR	%action on_unary_expression
		{:
				psrRetVal_t		ret = {AR_S_YES, NULL};
				exprNode_t		**ns = (exprNode_t**)nodes;
				exprNode_t		*res_node;
				AR_ASSERT(ns != NULL && count == 2);
				
				AR_UNUSED(count);
				AR_UNUSED(ctx);
				AR_UNUSED(name);

				res_node = ns[0];
				ns[0] = NULL;

				if(res_node == NULL)
				{
					ret.status = AR_E_ABORT;
					ret.node = NULL;
					return ret;
				}

				res_node ->expr.left = ns[1];
				ns[1] = NULL;

				ret.status = AR_S_YES;
				ret.node = res_node;
				return ret;
		:}
		;


term		:	VAR				%action autoreturn_0
		|	CONSTANT			%action autoreturn_0
		|	FILE_VAR			%action autoreturn_0
		;


call		:	NAME	"(" params ")"	%action on_call_expression
		{:
				psrRetVal_t		ret = {AR_S_YES, NULL};
				exprNode_t		**ns = (exprNode_t**)nodes;
				exprNode_t		*name_node,*res_node;
				AR_ASSERT(ns != NULL && count == 4);
				
				AR_UNUSED(count);
				AR_UNUSED(ctx);
				AR_UNUSED(name);

				name_node = ns[0];
				res_node = ns[2];
				

				if(name_node == NULL || res_node == NULL)
				{
					ret.status = AR_E_ABORT;
					ret.node = NULL;
					return ret;
				}
				
				AR_wcscpy(res_node->call.name, name_node->name.name);
				ns[2] = NULL;

				ret.status = AR_S_YES;
				ret.node = res_node;
				return ret;
		:}
		;





params        :    params "," param		%action insert_new_params
		{:
				psrRetVal_t		ret = {AR_S_YES, NULL};	//嗨~~，为啥非要在这里创建call Expression呢？因为我懒得写nodelist一类的东西塞进exprNode_t里了，先这样，以后再说~~
				exprNode_t		*expr_node, *new_node;
				AR_ASSERT(nodes != NULL && count == 3);
				AR_UNUSED(ctx);
				AR_memset(&ret, 0, sizeof(ret));
				
				AR_UNUSED(count);
				AR_UNUSED(ctx);
				AR_UNUSED(name);

				if(nodes[0] == NULL || nodes[2] == NULL)
				{
					ret.status = AR_E_ABORT;
					ret.node = NULL;
					return ret;
				}	

				expr_node = (exprNode_t*)nodes[0];
				new_node = (exprNode_t*)nodes[2];

				if(expr_node->call.param_cnt >= AR_NELEMS(expr_node->call.params))
				{
					AR_error(AR_ERR_WARNING, L"invalid params count : %Iu\r\n", expr_node->call.param_cnt);
					ret.status = AR_E_NOTENOUGH;
					ret.node = NULL;
					return ret;
				}
	
				expr_node->call.params[expr_node->call.param_cnt] = new_node;
				expr_node->call.param_cnt++;

				nodes[0] = nodes[2] = NULL;
				ret.status = AR_S_YES;
				ret.node = (psrNode_t*)expr_node;
				return ret;

		:}		
              |    param				%action on_call_params_expr
		{:
				psrRetVal_t		ret = {AR_S_YES, NULL};	//嗨~~，为啥非要在这里创建call Expression呢？因为我懒得写nodelist一类的东西塞进exprNode_t里了，先这样，以后再说~~
				exprNode_t		*expr_node;
				AR_ASSERT(nodes != NULL && count == 1);

				AR_UNUSED(count);
				AR_UNUSED(ctx);
				AR_UNUSED(name);

				AR_memset(&ret, 0, sizeof(ret));

				expr_node = NULL;
				expr_node =	CreateExprNode(CALL_T);
						
				if(expr_node == NULL)
				{
					AR_error(AR_ERR_WARNING, L"low mem : %hs\r\n", AR_FUNC_NAME);
					ret.status = AR_E_NOMEM;
					ret.node = NULL;
					return ret;
				}
				
				expr_node->call.params[0] = (exprNode_t*)nodes[0];
				nodes[0] = NULL;
				expr_node->call.param_cnt = 1;

				ret.status = AR_S_YES;
				ret.node = (psrNode_t*)expr_node;
				return ret;

		:}
		|	.				%action on_empty_call_params
		{:
				psrRetVal_t		ret = {AR_S_YES, NULL};	//看上头~~
				exprNode_t		*expr_node;
				AR_ASSERT(nodes != NULL && count == 0);

				AR_UNUSED(nodes);
				AR_UNUSED(count);
				AR_UNUSED(ctx);
				AR_UNUSED(name);

				AR_memset(&ret, 0, sizeof(ret));

				expr_node = NULL;
				expr_node =	CreateExprNode(CALL_T);
						
				if(expr_node == NULL)
				{
					AR_error(AR_ERR_WARNING, L"low mem : %hs\r\n", AR_FUNC_NAME);
					ret.status = AR_E_NOMEM;
					ret.node = NULL;
					return ret;
				}
				
				expr_node->call.param_cnt = 0;

				ret.status = AR_S_YES;
				ret.node = (psrNode_t*)expr_node;
				return ret;	
		:}
              ;


param		:	CONSTANT			%action autoreturn_0
		|	VAR				%action autoreturn_0
		|	FILE_VAR			%action autoreturn_0
		;	











%code main{:




static arStatus_t		AR_STDCALL handle_on_error(const psrToken_t *tok, const size_t expected[], size_t count, void *ctx)
{
		wchar_t msg[33];
		AR_ASSERT(tok != NULL);
		
		AR_UNUSED(expected);
		AR_UNUSED(count);
		AR_UNUSED(ctx);

		
		if(tok->str_cnt > 0)
		{
				AR_wcsncpy(msg, tok->str, AR_MIN(tok->str_cnt, 32));
				msg[AR_MIN(tok->str_cnt, 32)] = L'\0';
		}else
		{
				AR_wcscpy(msg, L"%EOI");
		}

		AR_error(AR_ERR_WARNING, L"invalid token : '%ls' (%Iu,%Iu)\r\n", msg, tok->line, tok->col);
		return AR_S_YES;
}


static void		AR_STDCALL free_node(psrNode_t *node, void *ctx)
{
		AR_ASSERT(node != NULL);
		AR_UNUSED(ctx);
		DestroyExprNode((exprNode_t*)node);
}


static const psrHandler_t		__g_expr_handler = 
{
		handle_on_error,
		free_node
};







:}BTM;






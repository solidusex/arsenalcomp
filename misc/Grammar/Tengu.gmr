

/******************************************PreDefined code********************************************/


%code {
/*
 * The Arsenal Library
 * Copyright (c) 2009 by Solidus
 * 
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.It is provided "as is" without express 
 * or implied warranty.
 *
 */


};






%code syntax_node {
	
	typedef enum
	\{
		TGU_NODE_TOKEN_T,
		TGU_NODE_STMT_T,
		TGU_NODE_EXPR_T,
		TGU_NODE_DECL_T,
		TGU_NODE_TABLE_FILED_T,
		TGU_NODE_TABLE_INIT_T
	\}tguSynNodeType_t;

	typedef struct __tengu_syntax_node_tag
	\{
		tguSynNodeType_t		type;
		
		union\{
				tguToken_t			*token;
				tguStmt_t			*stmt;
				tguExpr_t			*expr;
				tguDeclaration_t	*decl;
				tguTableField_t		*field;
				tguTableInit_t		*tbl_init;
		\};
	\}tguSynNode_t;


	static tguSynNode_t*	__create_synnode(tguSynNodeType_t type, void *parser_data)
	\{
		
		return NULL;
	\}

	static void	__delete_synnode(	tguSynNode_t* node)
	\{
		AR_ASSERT(node != NULL);
	\}
};



%code syntax_tree_handler {

	static void		AR_STDCALL on_free_node(psrNode_t *node, void *ctx)
	\{
		
	\}

	static void		AR_STDCALL on_error(const psrToken_t *tok, const size_t expected[], size_t count, void *ctx)
	\{

	\}
	
	static psrHandler_t	__g_handler = \{on_error, on_free_node\};
};








%name	delim 		:	"[ \r\n\t]"			
				;
%name	comment		:	"/\*([^\*]|\*+[^\*/])*\*+/"	
				;

%name	comment_line	:	"(//[^\r\n]*\r?(\n|$))"
				;

%name skip_lexem	: 	"{comment_line}|{delim}|{comment}"
				;


%name	digit			:	"[0-9]"				
				;
%name	number		:	"{digit}+"				
				;
%name	letter		:	"[A-Z_a-z]"
				;



%name hex_digit		:	"[0-9a-fA-F]"
				;

%name hex_literal 	:	"0(x|X){hex_digit}+"
				;

%name oct_literal	:	"0[0-7]+"
				;

%name dec_literal	:	"(0|[1-9][0-9]*)"
				;




%name	exponet			:	"(e|E)(\+|\-)?[0-9]+"
					;


%name float_literal		:	"(((([0-9]\.[0-9]*)|(\.[0-9]+)){exponet}?)|([0-9]+{exponet}))"
					;






/*  '"'  == \x22,  '\'' == \x27 */

%name	escape_seq		:	"(\\(\x22|\x27))"	
				;

%name	string_dq		: 	"(\x22({escape_seq}|[^\x22])*\x22)"		//只能提取"..."或"\""此类串，其它词法规则要到语义例程中处理	
				;

%name	string_sq		:	"\x27({escape_seq}|[^\x27])*\x27"		//提取'...'或'\''此类串，其它词法规则要到语义例程中处理	
				;



%name	keyword_lhd	:	"[A-Z_a-z0-9]"
				;


%name		float_constant	:	"{float_literal}(?!{keyword_lhd})"
					;
%name		hex_constant	:	"{hex_literal}(?!{keyword_lhd})"
					;
%name		oct_constant	:	"{oct_literal}(?!{keyword_lhd})"
					;
%name		dec_constant	:	"{dec_literal}(?!{keyword_lhd})"
					;


%token 	%skip			:	"{skip_lexem}"				,1				%value	"TOK_DELIM_ID"	 		;			//空白，需要过滤


%code {
	
	tguSynNode_t*	on_lexer_node(tguParser_t *parser, const psrToken_t *tok)
	\{
		return NULL;
	\}

};


%token	NAME			:	"{letter}({letter}|{digit})*"					%value	"TOK_NAME"				%action build_default_leaf
{

	return NULL;
};


%token	STRING		:	"{string_dq}|{string_sq}"						%value	"TOK_STRING"			%action build_default_leaf			;
%token	FLOAT_NUMBER	:	"{float_constant}"						,2	%value	"TOK_FLOAT_NUMBER"		%action build_default_leaf			;
%token	INT_NUMBER		:	"{hex_constant}|{oct_constant}|{dec_constant}"	,2	%value	"TOK_INT_NUMBER"		%action build_default_leaf			;









%token	"do"		:	'"do"(?!{keyword_lhd})'		,1					%value	"TOK_DO"			%action build_default_leaf			;
%token	"while"	:	'"while"(?!{keyword_lhd})'		,1					%value	"TOK_WHILE"		%action build_default_leaf			;
%token	"if"		:	'"if"(?!{keyword_lhd})'		,1					%value	"TOK_IF"			%action build_default_leaf			;
%token	"else"	:	'"else"(?!{keyword_lhd})'		,1					%value	"TOK_ELSE"			%action build_default_leaf			;

%token	"continue"	:	'"continue"(?!{keyword_lhd})'	,1					%value	"TOK_CONTINUE"		%action build_default_leaf			;
%token	"break"	:	'"break"(?!{keyword_lhd})'		,1					%value	"TOK_BREAK"		%action build_default_leaf			;
%token	"return"	:	'"return"(?!{keyword_lhd})'	,1					%value	"TOK_RETURN"		%action build_default_leaf			;

%token	"null"	:	'"null"(?!{keyword_lhd})'		,1					%value	"TOK_NULL"			%action build_default_leaf			;
%token	"true"	:	'"true"(?!{keyword_lhd})'		,1					%value	"TOK_TRUE"			%action build_default_leaf			;
%token	"false"	:	'"false"(?!{keyword_lhd})'		,1					%value	"TOK_FALSE"		%action build_default_leaf			;
%token	"var"		:	'"var"(?!{keyword_lhd})'		,1					%value	"TOK_VAR"			%action build_default_leaf			;


%token	"..."		:	'"..."'		,2								%value	"TOK_ELLIPSIS"		%action build_default_leaf			;	


%token	"++"		:	'"++"'		,1								%value	"TOK_INC"			%action build_default_leaf			;
%token	"--"		:	'"--"'		,1								%value	"TOK_DEC"			%action build_default_leaf			;


%token	"&&"		:	'"&&"'		,1								%value	"TOK_ANDAND"		%action build_default_leaf			;
%token	"||"		:	'"||"'		,1								%value	"TOK_OROR"			%action build_default_leaf			;



%token	"<="		:	'"<="'		,1								%value	"TOK_LE"			%action build_default_leaf			;
%token	">="		:	'">="'		,1								%value	"TOK_GE"			%action build_default_leaf			;
%token	"=="		:	'"=="'		,1								%value	"TOK_EQ"			%action build_default_leaf			;
%token	"!="		:	'"!="'		,1								%value	"TOK_NE"			%action build_default_leaf			;
%token	"<"		:	'"<"'			,0								%value	"TOK_LESS"			%action build_default_leaf			;
%token	">"		:	'">"'			,0								%value	"TOK_GREATER"		%action build_default_leaf			;




%token	"{"		:	'"{"'			,0								%value	"TOK_L_BRACES"		%action build_default_leaf			;
%token	"}"		:	'"}"'			,0								%value	"TOK_R_BRACES"		%action build_default_leaf			;
%token	"("		:	'"("'			,0								%value	"TOK_L_PAREN"		%action build_default_leaf			;
%token	")"		:	'")"'			,0								%value	"TOK_R_PAREN"		%action build_default_leaf			;
%token	"["		:	'"["'			,0								%value	"TOK_L_SQUARE"		%action build_default_leaf			;
%token	"]"		:	'"]"'			,0								%value	"TOK_R_SQUARE"		%action build_default_leaf			;

%token	";"		:	'";"'			,0								%value	"TOK_SEMICOLON"		%action build_default_leaf			;
%token	","		:	'","'			,0								%value	"TOK_COMMA"		%action build_default_leaf			;
%token	"="		:	'"="'			,0								%value	"TOK_ASSIGN"		%action build_default_leaf			;



%token	"+"		:	'"+"'			,0								%value	"TOK_ADD"			%action build_default_leaf			;
%token	"-"		:	'"-"'			,0								%value	"TOK_SUB"			%action build_default_leaf			;
%token	"*"		:	'"*"'			,0								%value	"TOK_MUL"			%action build_default_leaf			;
%token	"/"		:	'"/"'			,0								%value	"TOK_DIV"			%action build_default_leaf			;
%token	"%"		:	'"%"'			,0								%value	"TOK_MOD"			%action build_default_leaf			;

%token	"!"		:	'"!"'			,0								%value	"TOK_NOT"			%action build_default_leaf			;


%token	":"		:	'":"'			,0								%value	"TOK_COLON"		%action build_default_leaf			;
%token	"?"		:	'"?"'			,0								%value	"TOK_QUEST"		%action build_default_leaf			;

/*
%token	"."		:	'"."'			,0								%value	"TOK_DOT"			%action build_default_leaf			;
*/


%right	"?"	":"							;
%left		"||"								;
%left		"&&"								;
%left		"=="	"!="	"<"	"<="	">"	">="			;
%left		"+"	"-"							;
%left		"*"	"/"	"%"						;




/*
"if" "(" expression ")" statement "else" statement 
产生式的优先级依赖于其最右终结符或显性指定,这里就是"else"
*/
%nonassoc IF_WITHOUT_ELSE						;
%nonassoc "else"							;



/**************************************************************************************/
%start	program	;


program			:	translation_unit
				|	.
				;

translation_unit	:	element
				|	translation_unit	element
				;



element			:	declaration
				|	function_defination
				;


/**************************************function_defination***********************************************/


function_defination		:	"var"		NAME "(" params ")"	start_function compound_statement close_function	%action	on_function_defination
					{
						return NULL;
					}
					;


params				:	namelist	","	"..."
					|	namelist
					|	"..."
					|	.
					;



namelist				:	namelist	"," NAME
					|	NAME
					;





start_function			:	.			%action	on_start_function
					{
						return NULL;
					}
					;

close_function			:	.			%action	on_close_function	
					{
						return NULL;
					}
					;




/*************************************语句***************************************************/


statement				:	compound_statement			%action	auto_return_0
					|	expression_statement			%action	auto_return_0
					|	selection_statement			%action	auto_return_0
					|	iteration_statement			%action	auto_return_0
					|	jump_statement				%action	auto_return_0
					|	empty_statement				%action	auto_return_0
					;



/*************************************声明语句***************************************************/


declaration			:	"var"		init_declarator_list 	semi		%action	auto_return_1
					{
						psrNode_t *ret;
						ret  = nodes[1];
						nodes[1] = NULL;
						return ret;
					}
					;

init_declarator_list		:	init_declarator							%action	auto_return_0
					|	init_declarator_list "," init_declarator		%action	on_declarator_list
					{
						//tguParser_t 	*parser = (tguParser_t*)ctx;
						tguSynNode_t	**ns = (tguSynNode_t**)nodes;
						tguSynNode_t	*ret;
						tguDeclaration_t *lst, *decl, *tmp;

						if(ns[0] == NULL)
						\{
							ret = ns[2];
							ns[2] = NULL;
						\}else if(ns[2] == NULL)
						\{
							ret = ns[0];
							ns[0] = NULL;
						\}else
						\{
							lst = ns[0]->decl; 
							decl = ns[2]->decl;
							ns[2]->decl = NULL;

							for(tmp = lst; tmp->next != NULL; tmp = tmp->next);
							tmp->next = decl;
							ret = ns[0];
							ns[0] = NULL;
						\}
						 return ret;
					}
					;




%code{
	
	static tguDeclaration_t*	make_declaration_from_expression(tguParser_t 	*parser, const tguToken_t *tok, tguExpr_t *expr)
	\{
		return NULL;
	\}

	static tguDeclaration_t*	make_declaration_from_table(tguParser_t 	*parser, const tguToken_t *tok, tguTableInit_t *table_init)
	\{
		return NULL;
	\}

	static tguDeclaration_t*	make_declaration_from_null(tguParser_t 	*parser, const tguToken_t *tok)
	\{
		return NULL;
	\}

	static tguDeclaration_t*	make_declaration_from_error(tguParser_t 	*parser, const tguToken_t *tok)
	\{
		return NULL;
	\}
};



init_declarator			:	NAME	"=" 	expression				%action	on_declarator
					|	NAME "="	table_constructor		%action	on_declarator
					|	NAME							%action	on_declarator
					{
						tguParser_t 	*parser = (tguParser_t*)ctx;
						tguSynNode_t	**ns = (tguSynNode_t**)nodes;
						tguSynNode_t	*ret;
						tguTableInit_t  *tbl_init;
						tguExpr_t		*expr;
						tguDeclaration_t *decl;
						AR_ASSERT(nodes != NULL && parser != NULL && (count == 1 || count == 3));
							
						if(count == 1)
						\{
							decl = make_declaration_from_null(parser, ns[0]->token);
						\}else
						\{
							if(ns[2] == NULL)
							\{
								decl = make_declaration_from_error(parser, ns[0]->token);
							\}else 
							\{
								if(ns[2]->type == TGU_NODE_TABLE_INIT_T)
								\{
										tbl_init = ns[2]->tbl_init;
										ns[2]->tbl_init = NULL;
										decl = make_declaration_from_table(parser, ns[0]->token, tbl_init);
								\}else
								\{
										expr = ns[2]->expr;
										ns[2]->expr = NULL;
										decl = make_declaration_from_expression(parser, ns[0]->token, expr);
								\}
							\}
						\}

						ret = __create_synnode(TGU_NODE_DECL_T, (void*)decl);
						return ret;
					}
					;



%code {
	static tguTableInit_t*	make_table_init(tguParser_t 	*parser, bool_t is_empty, tguTableField_t	*field_lst)
	\{
		return NULL;
	\}

};

table_constructor		:	"{"	filed_list "}"		%action	on_table_constructor
					|	"{"	"}"				%action	on_table_constructor
					|	"{" error "}"			%action	on_table_constructor
					{
						tguParser_t 	*parser = (tguParser_t*)ctx;
						tguSynNode_t	**ns = (tguSynNode_t**)nodes;
						tguSynNode_t	*ret;
						bool_t is_empty;
						tguTableField_t *lst;
						tguTableInit_t  *tbl_init;
						
						AR_ASSERT(parser != NULL && (count == 2 || count == 3));

						if(count == 2)
						\{
							is_empty = true;
							lst = NULL;
						\}else 
						\{
							is_empty = false;
							lst = ns[1]->field;
							ns[1]->field = NULL;
						\}

						tbl_init = make_table_init(parser, is_empty, lst);
						ret = __create_synnode(TGU_NODE_TABLE_INIT_T, tbl_init);
						return ret;
					}
					;

filed_list 			:	filed_list "," filed			%action	on_filed_list
					{
						//tguParser_t 	*parser = (tguParser_t*)ctx;
						tguSynNode_t	**ns = (tguSynNode_t**)nodes;
						tguSynNode_t	*ret;
						tguTableField_t *lst, *field, *tmp;

						if(ns[0] == NULL)
						\{
							ret = ns[2];
							ns[2] = NULL;
						\}else if(ns[2] == NULL)
						\{
							ret = ns[0];
							ns[0] = NULL;
						\}else
						\{
							lst = ns[0]->field; 
							field= ns[2]->field;
							ns[2]->field= NULL;

							for(tmp = lst; tmp->next != NULL; tmp = tmp->next);
							tmp->next = field;
							ret = ns[0];
							ns[0] = NULL;
						\}
						 return ret;
					}

					|	filed						%action	auto_return_0
					;



%code {
	static tguTableField_t*	make_table_field(tguParser_t *parser, tguTableFieldType_t type, void *expr_or_field)
	\{
		return NULL;
	\}

};

filed					:	expression			%action	on_filed
					|	table_constructor	%action	on_filed
					{
						tguParser_t 	*parser = (tguParser_t*)ctx;
						tguSynNode_t	**ns = (tguSynNode_t**)nodes;
						tguSynNode_t	*ret;
						tguTableField_t *field;
						AR_ASSERT(ns != NULL && count == 1 && parser != NULL);

						if(ns[0] == NULL)
						\{
							parser->has_error = true;
							field = NULL;
							return NULL;
						\}else if(ns[0]->type == TGU_NODE_EXPR_T)
						\{
							 field = make_table_field(parser, TGU_INIT_TABLE_EXPR, (void*)ns[0]->expr);
							 ns[0]->expr = NULL;
						\}else if(ns[0]->type == TGU_NODE_TABLE_FILED_T)
						\{
							field = make_table_field(parser, TGU_INIT_TABLE_FIELD, (void*)ns[0]->field);
							ns[0]->field = NULL;
						\}else
						\{
							field = NULL;
							AR_ASSERT(false);
							return NULL;
						\}

						ret = __create_synnode(TGU_NODE_TABLE_FILED_T, field);
						return ret;
					}
					;




/**************************************compound_statement*****************************/

compound_statement		:	start_block	compound_element_list		close_block	%action	on_compound_statement
					|	"{" "}"										%action	on_compound_statement
					|	start_block  error  close_block									%action	on_compound_statement
					{
						/*
						tguParser_t 	*parser = (tguParser_t*)ctx;
						tguSynNode_t	**ns = (tguSynNode_t**)nodes;
						AR_ASSERT(nodes != NULL && (count == 2 || count == 3));

						if(count == 3)return NULL;
						AR_ASSERT(ns[1] == NULL);
						*/
						return NULL;
					}
					;



%code {
	static void insert_decl_to_block(tguBlock_t *block, tguDeclaration_t *decl)
	\{
		
	\}

	static void insert_stmt_to_block(tguBlock_t *block, tguStmt_t *stmt)
	\{
		
	\}
};

compound_element_list		:	compound_element_list		compound_element	%action	on_compound_element_list
					|	compound_element						%action	on_compound_element_list
					{
						tguParser_t 	*parser = (tguParser_t*)ctx;
						tguSynNode_t	**ns = (tguSynNode_t**)nodes;
						tguSynNodeType_t type;
						tguDeclaration_t *decl;
						tguStmt_t		*stmt;
						AR_ASSERT(nodes != NULL && (count == 2 || count == 1));
						if(count == 2) return NULL;
						type = ns[0]->type;
						if(ns[0]->type == TGU_NODE_DECL_T)
						\{
							decl = ns[0]->decl;
							ns[0]->decl = NULL;
							if(decl) 
							\{
								insert_decl_to_block(parser->top_block, decl);
							\}else 
							\{
								parser->has_error = true;
							\}
						\}else if(ns[0]->type == TGU_NODE_STMT_T)
						\{
							stmt = ns[0]->stmt;
							ns[0]->stmt = NULL;
							if(stmt)
							\{
								insert_stmt_to_block(parser->top_block, stmt);
							\}else 
							\{
								parser->has_error = true;
							\}
						\}else \{
							AR_ASSERT(false);
						\}
						return NULL;
					}
					;



compound_element		:	statement		%action	auto_return_0
					|	declaration	%action	auto_return_0
					;




%code{
	static void start_block(tguParser_t *parser, const tguLexInfo_t *info)
	\{
	\}

	static void close_block(tguParser_t *parser, const tguLexInfo_t *info)
	\{

	\}
};


start_block			:	"{"		%action	on_start_block
					{
							tguParser_t 	*parser = (tguParser_t*)ctx;
							tguSynNode_t	**ns = (tguSynNode_t**)nodes;
							start_block(parser, &ns[0]->token->lex_info);
							return NULL;
					}
					;


close_block			:	"}"		%action	on_close_block
					{
							tguParser_t 	*parser = (tguParser_t*)ctx;
							tguSynNode_t	**ns = (tguSynNode_t**)nodes;
							close_block(parser, &ns[0]->token->lex_info);
							return NULL;
					}
					;


/*****************************************************************************/

%code {
	static tguStmt_t*	make_empty_statement(tguParser_t *parser, const tguLexInfo_t *lex_info)
	\{
		return NULL;
	\}

};


empty_statement			:	";"		%action	on_empty_statement
					{
						tguSynNode_t	**ns = (tguSynNode_t**)nodes;
						tguParser_t	*parser = (tguParser_t*)ctx;
						tguSynNode_t 	*ret;
						tguStmt_t		*stmt;
						AR_ASSERT(ns != NULL && parser != NULL && count == 1);

						stmt = make_empty_statement(parser, &ns[0]->token->lex_info);
						ret = __create_synnode(TGU_NODE_STMT_T, (void*)stmt);
						return ret;
					}
					;

expression_statement		:	expression	 semi		%action auto_return_0
					{
						psrNode_t *ret = nodes[0];
						ret  = nodes[0];
						nodes[0] = NULL;
						return ret;
					}
					;





selection_statement		:	if_statement		%action auto_return_0
					|	if_else_statement	%action auto_return_0
					;

%code{
	static tguStmt_t*	make_if_statement(tguParser_t *parser, tguExpr_t *cond, tguStmt_t *if_true, tguStmt_t *if_false, const tguLexInfo_t *lex_info)
	\{
		return NULL;
	\}

};


if_statement			:	"if" "(" expression ")" statement			%prec IF_WITHOUT_ELSE		%action on_if_statement
					|	"if" "(" error ")" statement				%prec IF_WITHOUT_ELSE		%action on_if_statement
					{
						tguSynNode_t	**ns = (tguSynNode_t**)nodes;
						tguParser_t	*parser = (tguParser_t*)ctx;
						tguSynNode_t	*ret;
						tguExpr_t		*expr;
						tguStmt_t		*if_true, *stmt;
						AR_ASSERT(ns != NULL && count == 5);
						
						if(ns[2] == NULL)
						\{
							expr = NULL;
							parser->has_error = true;
						\}else
						\{
							expr = ns[2]->expr;
							ns[2]->expr = NULL;
						\}
							
						if(ns[4] == NULL)
						\{	
							if_true = NULL;
							parser->has_error = true;
						\}else
						\{
							if_true = ns[4]->stmt;
							ns[4]->stmt = NULL;
						\}

						stmt = make_if_statement(parser, expr, if_true, NULL, &ns[0]->token->lex_info);
						ret = __create_synnode(TGU_NODE_STMT_T, (void*)stmt);
						return ret;
					}
					;

if_else_statement		:	"if" "(" expression ")" statement "else" statement	%action on_if_else_statement
					|	"if" "(" error ")" statement "else" statement		%action on_if_else_statement
					{
						tguSynNode_t	**ns = (tguSynNode_t**)nodes;
						tguParser_t	*parser = (tguParser_t*)ctx;
						tguSynNode_t	*ret;
						tguExpr_t		*expr;
						tguStmt_t		*if_true;
						tguStmt_t		*if_false;
						tguStmt_t		*stmt;
						AR_ASSERT(ns != NULL && count == 5);
						if(ns[2] == NULL)
						\{
							expr = NULL;
							parser->has_error = true;
						\}else
						\{
							expr = ns[2]->expr;
							ns[2]->expr = NULL;
						\}
							
						if(ns[4] == NULL)
						\{	
							if_true = NULL;
							parser->has_error = true;
						\}else
						\{
							if_true = ns[4]->stmt;
							ns[4]->stmt = NULL;
						\}

						if(ns[6] == NULL)
						\{	
							if_false = NULL;
							parser->has_error = true;
						\}else
						\{
							if_false = ns[6]->stmt;
							ns[6]->stmt = NULL;
						\}


						stmt = make_if_statement(parser, expr, if_true, if_false,  &ns[0]->token->lex_info);	
						ret = __create_synnode(TGU_NODE_STMT_T, (void*)stmt);
						return ret;
					}
					;


iteration_statement		:	while_statement			%action	auto_return_0
					|	do_while_statement		%action	auto_return_0
					;






%code {
	static tguStmt_t*	make_while_statement(tguParser_t *parser, tguExpr_t *cond, tguStmt_t *loop, const tguLexInfo_t *lex_info)
	\{
		return NULL;
	\}

	static tguStmt_t*	make_do_while_statement(tguParser_t *parser, tguExpr_t *cond, tguStmt_t *loop, const tguLexInfo_t *lex_info)
	\{
		return NULL;
	\}


};




while_statement			:	"while" enter_loop  "(" expression ")" statement leave_loop	%action	on_while_statement
					|	"while" enter_loop  "(" error ")" statement leave_loop		%action	on_while_statement
					{
						tguSynNode_t	**ns = (tguSynNode_t**)nodes;
						tguParser_t	*parser = (tguParser_t*)ctx;
						tguSynNode_t	*ret;
						tguExpr_t		*expr;
						tguStmt_t		*stmt;
						AR_ASSERT(ns != NULL && count == 5);
						if(ns[3] == NULL)
						\{
							expr = NULL;
							parser->has_error = true;
						\}else
						\{
							expr = ns[3]->expr;
							ns[3]->expr = NULL;
						\}
							
						if(ns[5] == NULL)
						\{	
							stmt = NULL;
							parser->has_error = true;
						\}else
						\{
							stmt = ns[5]->stmt;
							ns[5]->stmt = NULL;
						\}

						stmt = make_while_statement(parser, expr, stmt, &ns[0]->token->lex_info);
						ret = __create_synnode(TGU_NODE_STMT_T, (void*)stmt);
						return ret;
					}
					;

do_while_statement		:	"do" enter_loop statement "while" "(" expression ")" leave_loop semi			%action	on_do_while_statement
					|	"do" enter_loop statement "while" "(" error ")" leave_loop semi				%action	on_do_while_statement
					{
						tguSynNode_t	**ns = (tguSynNode_t**)nodes;
						tguParser_t	*parser = (tguParser_t*)ctx;
						tguSynNode_t	*ret;
						tguExpr_t		*expr;
						tguStmt_t		*stmt;
						AR_ASSERT(ns != NULL && count == 5);
						if(ns[2] == NULL)
						\{
							stmt = NULL;
							parser->has_error = true;
						\}else
						\{
							stmt = ns[2]->stmt;
							ns[2]->stmt = NULL;
						\}
							
						if(ns[5] == NULL)
						\{	
							expr = NULL;
							parser->has_error = true;
						\}else
						\{
							expr = ns[5]->expr;
							ns[5]->expr = NULL;
						\}

						stmt =make_do_while_statement(parser, expr, stmt, &ns[0]->token->lex_info);
						ret = __create_synnode(TGU_NODE_STMT_T, (void*)stmt);
						return ret;
					}
					;




enter_loop				:	.					%action on_enter_loop
					{
						tguParser_t	*parser = NULL;
						AR_ASSERT(ctx != NULL);
						parser = (tguParser_t*)ctx;
						parser->loop_level++;
						return NULL;
					}
					;


leave_loop				:	.					%action on_leave_loop
					{
						tguParser_t	*parser = NULL;
						AR_ASSERT(ctx != NULL);
						parser = (tguParser_t*)ctx;
						AR_ASSERT(parser->loop_level > 0);
						parser->loop_level--;
						return NULL;
					}
					;






%code{
	static tguStmt_t*	make_jump_statement(tguParser_t *parser, tguStmtType_t type, tguExpr_t *expr, const tguLexInfo_t *lex_info)
	\{
		return NULL;
	\}
};


jump_statement			:	"continue" semi				%action on_continue_statement
					{
						tguSynNode_t	**ns = (tguSynNode_t**)nodes;
						tguSynNode_t 	*ret;
						tguStmt_t		*stmt;
						tguParser_t	*parser = (tguParser_t*)ctx;
						stmt = make_jump_statement(parser, TGU_STT_CONTINUE, 	NULL, &ns[0]->token->lex_info);
						ret = __create_synnode(TGU_NODE_STMT_T, (void*)stmt);
						return ret;

					}

					|	"break" 	semi				%action on_break_statement
					{
						tguSynNode_t	**ns = (tguSynNode_t**)nodes;
						tguSynNode_t 	*ret;
						tguStmt_t		*stmt;
						tguParser_t	*parser = (tguParser_t*)ctx;
						ret = AR_NEW(tguSynNode_t);
						ret->type = TGU_NODE_STMT_T;
						stmt = make_jump_statement(parser, TGU_STT_BREAK, 	NULL, &ns[0]->token->lex_info);
						ret = __create_synnode(TGU_NODE_STMT_T, (void*)stmt);
						return ret;
						
					}

					|	"return" 	semi				%action on_return_statement
					|	"return" 	expression semi		%action on_return_statement
					{
						tguSynNode_t	**ns = (tguSynNode_t**)nodes;
						tguSynNode_t 	*ret;
						tguExpr_t		*expr;
						tguParser_t	*parser = (tguParser_t*)ctx;
						tguStmt_t		*stmt;
						AR_ASSERT(nodes != NULL && count == 2 || count == 3);
						AR_ASSERT(parser->current_function != NULL);

						if(ns[1] == NULL)
						\{
							expr = NULL;
						\}else
						\{
							AR_ASSERT(ns[1]->type == TGU_NODE_EXPR_T);
							expr = ns[1]->expr;
							ns[1]->expr = NULL;
						\}

						stmt = make_jump_statement(parser, TGU_STT_RETURN, 	expr, &ns[0]->token->lex_info);
						ret = __create_synnode(TGU_NODE_STMT_T, (void*)stmt);
						return ret;
					}
					;




semi					:	";"								%action	auto_return_0
					|	error								%action	auto_return_null
					;


/*****************************************表达式*********************************************/


%code{
	static bool_t check_is_lvalue(const tguExpr_t *expr, tguParser_t *parser)
	\{
		return false;
	\}

	static bool_t check_is_constant(const tguExpr_t *expr, tguParser_t *parser)
	\{
		return false;
	\}
};


expression				:	assignment_expression		%action auto_return_0
					;
	

%code {
	static tguExpr_t*		make_assignment_expression(tguParser_t	*parser, 	tguExpr_t *addr, tguExpr_t *value, const tguLexInfo_t *lex_info)
	\{
			return NULL;
	\}

};


assignment_expression		:	constant_expression							%action 	auto_return_0
					|	unary_expression	"="	table_constructor		%action	on_assignment_expression
					|	unary_expression	"="	assignment_expression		%action	on_assignment_expression
					{
						tguSynNode_t	**ns = (tguSynNode_t**)nodes;
						tguSynNode_t 	*ret;
						tguParser_t	*parser = (tguParser_t*)ctx;
						tguExpr_t		*addr, *value, *expr;
						const tguLexInfo_t *lex_info; 
						AR_ASSERT(ns != NULL && count == 3 && parser != NULL);

						if(ns[0] == NULL)
						\{
							parser->has_error = true;
							addr = NULL;	
						\}else
						\{
							addr = ns[0]->expr;
							ns[0]->expr = NULL;
						\}
						

						if(ns[2] == NULL)
						\{
							parser->has_error = true;
							value = NULL;	
						\}else
						\{
							value = ns[2]->expr;
							ns[2]->expr = NULL;
						\}

						lex_info = addr != NULL ? &addr->lex_info : &ns[1]->token->lex_info;
						expr = make_assignment_expression(parser, addr, value, lex_info);
						ret = __create_synnode(TGU_NODE_EXPR_T, (void*)expr);

						return ret;

					}
					;




%code {
	static tguExpr_t*		make_condition_expression(tguParser_t	*parser, 	tguExpr_t *cond, tguExpr_t *if_true, tguExpr_t *if_false, const tguLexInfo_t *lex_info)
	\{
			return NULL;
	\}

};

constant_expression		:	binary_expression										%action 	auto_return_0
					|	binary_expression	"?"	expression	":"	constant_expression		%action	on_condition_expression
					{
						tguSynNode_t	**ns = (tguSynNode_t**)nodes;
						tguSynNode_t 	*ret;
						tguParser_t	*parser = (tguParser_t*)ctx;
						tguExpr_t		*cond, *if_true, *if_false, *expr;
						const tguLexInfo_t *lex_info;
						AR_ASSERT(ns != NULL && count == 3 && parser != NULL);

						if(ns[0] == NULL)
						\{
							parser->has_error = true;
							cond= NULL;	
						\}else
						\{
							cond = ns[0]->expr;
							ns[0]->expr = NULL;
						\}

						

						if(ns[2] == NULL)
						\{
							parser->has_error = true;
							if_true = NULL;	
						\}else
						\{
							if_true= ns[2]->expr;
							ns[2]->expr = NULL;
						\}
						
						if(ns[4] == NULL)
						\{
							parser->has_error = true;
							if_false = NULL;	
						\}else
						\{
							if_false= ns[4]->expr;
							ns[4]->expr = NULL;
						\}

						lex_info = cond != NULL ? &cond->lex_info : &ns[1]->token->lex_info;
						expr = make_condition_expression(parser, cond, if_true, if_false, lex_info);
						ret = __create_synnode(TGU_NODE_EXPR_T, (void*)expr);
						return ret;


					}
					;



%code {
	static tguExpr_t*		make_binary_expression(tguParser_t	*parser, 	tguExprOP_t op, tguExpr_t *left, tguExpr_t *right, const tguLexInfo_t *lex_info)
	\{
			return NULL;
	\}
};

binary_expression		:	unary_expression							%action 	auto_return_0
					|	binary_expression	"+"	binary_expression		%action	on_binary_expression
					|	binary_expression	"-"	binary_expression		%action	on_binary_expression
					|	binary_expression	"*"	binary_expression		%action	on_binary_expression
					|	binary_expression	"/"	binary_expression		%action	on_binary_expression
					|	binary_expression	"%"	binary_expression		%action	on_binary_expression
					|	binary_expression	"<"	binary_expression		%action	on_binary_expression
					|	binary_expression	"<="	binary_expression		%action	on_binary_expression
					|	binary_expression	">"	binary_expression		%action	on_binary_expression
					|	binary_expression	">="	binary_expression		%action	on_binary_expression
					|	binary_expression	"=="	binary_expression		%action	on_binary_expression
					|	binary_expression	"!="	binary_expression		%action	on_binary_expression
					|	binary_expression	"&&"	binary_expression		%action	on_binary_expression
					|	binary_expression	"||"	binary_expression		%action	on_binary_expression
					{
						tguSynNode_t	**ns = (tguSynNode_t**)nodes;
						tguSynNode_t 	*ret;
						tguParser_t	*parser = (tguParser_t*)ctx;
						tguExpr_t		*left, *right, *expr;
						tguToken_t		*tok;
						tguExprOP_t	op;
						const tguLexInfo_t *lex_info;
						AR_ASSERT(ns != NULL && count == 3 && parser != NULL);

						if(ns[0] == NULL)
						\{
							parser->has_error = true;
							left = NULL;	
						\}else
						\{
							left = ns[0]->expr;
							ns[0]->expr = NULL;
						\}

						AR_ASSERT(ns[1] != NULL);
						tok = ns[1]->token;	

						if(ns[2] == NULL)
						\{
							parser->has_error = true;
							right = NULL;	
						\}else
						\{
							right = ns[2]->expr;
							ns[2]->expr = NULL;
						\}

						switch(tok->term_val)
						\{
						case TOK_INC:
							op = TGU_OP_PLUS;
							break;
						case TOK_SUB :
							op = TGU_OP_MINUS;
							break;
						case TOK_MUL:
							op = TGU_OP_MUL;
							break;
						case TOK_DIV:
							op = TGU_OP_DIV;
							break;
						case TOK_MOD:
							op = TGU_OP_MOD;
							break;
						case TOK_LESS:
							op = TGU_OP_LESS;
							break;
						case TOK_LE:
							op = TGU_OP_LESS_OR_EQUAL;
							break;
						case TOK_GREATER:
							op = TGU_OP_GREATER;
							break;
						case TOK_GE:
							op = TGU_OP_GREATER_OR_EQUAL;
							break;
						case TOK_EQ:
							op = TGU_OP_IS_EQUAL;
							break;
						case TOK_NE:
							op = TGU_OP_NOT_EQUAL;
							break;
						case TOK_ANDAND:
							op = TGU_OP_LOGICAL_AND;
							break;
						case TOK_OROR:
							op = TGU_OP_LOGICAL_OR;
							break;
						default:
							op = TGU_OP_NONE;/*op如果在此不赋值会导致一个warning*/
							AR_ASSERT(false);
							break;
						\}
						lex_info  = left != NULL ? &left->lex_info : &tok->lex_info;
						expr = make_binary_expression(parser, op, left, right, lex_info);
						ret = __create_synnode(TGU_NODE_EXPR_T, (void*)expr);
						return ret;


					}
					;


%code {
	static tguExpr_t*		make_unary_expression(tguParser_t	*parser, 	tguExprOP_t op, tguExpr_t *expr, bool_t is_lvalue, const tguLexInfo_t *lex_info)
	\{
			return NULL;
	\}
	
	static tguExpr_t*	make_index_expression(tguParser_t *parser, tguExpr_t *expr, tguExpr_t *index_expr, const tguLexInfo_t *lex_info)
	\{	
		return NULL;
	\}

};

unary_expression	:	"+"	unary_expression	%action	on_unary_expression
				|	"-"	unary_expression	%action	on_unary_expression
				|	"!"	unary_expression	%action	on_unary_expression
				|	"++" 	unary_expression	%action	on_unary_expression
				|	"--"	unary_expression	%action	on_unary_expression
				{
						tguSynNode_t	**ns = (tguSynNode_t**)nodes;
						tguSynNode_t 	*ret;
						tguParser_t	*parser = (tguParser_t*)ctx;

						tguExpr_t		*expr;
						tguToken_t		*tok;
						tguExprOP_t	op;
						const tguLexInfo_t	*lex_info;
						AR_ASSERT(ns != NULL && count == 2 && parser != NULL);

						if(ns[1] == NULL)
						\{
							parser->has_error = true;
							expr = NULL;	
						\}else
						\{
							expr = ns[1]->expr;
							ns[1]->expr = NULL;
						\}

						AR_ASSERT(ns[0] != NULL && ns[0]->token != NULL);
						tok = ns[0]->token;	
						
						switch(tok->term_val)
						\{
						case TOK_INC:
							op = TGU_OP_PREINC;
							break;
						case TOK_DEC:
							op = TGU_OP_PREDEC;
							break;
						case TOK_ADD:
							op = TGU_OP_UNARY_PLUS;
							break;
						case TOK_SUB:
							op = TGU_OP_UNARY_MINUS;
							break;
						case TOK_NOT:
							op = TGU_OP_LOGICAL_NOT;
							break;
						default:
							op = TGU_OP_NONE;
							AR_ASSERT(false);
							break;
						\}
						lex_info = expr != NULL ? &expr->lex_info : &ns[0]->token->lex_info;
						expr = make_unary_expression(parser, op, expr, false, lex_info);
						ret = __create_synnode(TGU_NODE_EXPR_T, (void*)expr);
						return ret;

				}

				|	postfix_expression		%action 	auto_return_0
				;


postfix_expression	:	postfix_expression	"++"		%action	on_post_add_minus_expression
				|	postfix_expression	"--"		%action	on_post_add_minus_expression
				{
						tguSynNode_t	**ns = (tguSynNode_t**)nodes;
						tguSynNode_t 	*ret;
						tguParser_t	*parser = (tguParser_t*)ctx;
						tguExpr_t		*expr;
						tguToken_t		*tok;
						tguExprOP_t	op;
						const tguLexInfo_t	*lex_info; 
						AR_ASSERT(ns != NULL && count == 2 && parser != NULL);

						if(ns[0] == NULL)
						\{
							parser->has_error = true;
							expr = NULL;	
						\}else
						\{
							expr = ns[0]->expr;
							ns[0]->expr = NULL;
						\}

						AR_ASSERT(ns[1] != NULL && ns[1]->token != NULL);
						tok = ns[1]->token;	
							
						switch(tok->term_val)	
						\{
						case TOK_INC:
							op = TGU_OP_POSTINC;
							break;
						case TOK_DEC:
							op = TGU_OP_POSTDEC;
							break;
						default:
							op = TGU_OP_NONE;
							AR_ASSERT(false);
							break;
						\}
						
						lex_info = expr != NULL ? &expr->lex_info : &tok->lex_info;
						expr = make_unary_expression(parser, op, expr, false, lex_info);
						ret = __create_synnode(TGU_NODE_EXPR_T, (void*)expr);
						return ret;
				}

				|	postfix_expression "[" expression "]"		%action	on_index_expression
				|	postfix_expression "[" error "]"		%action	on_index_expression
				{
					
						tguSynNode_t	**ns = (tguSynNode_t**)nodes;
						tguSynNode_t 	*ret;
						tguParser_t	*parser = (tguParser_t*)ctx;
						tguExpr_t		*expr, *index_expr;
						const tguLexInfo_t	*lex_info;
						AR_ASSERT(ns != NULL && count == 4 && parser != NULL);

						if(ns[0] == NULL)
						\{
							parser->has_error = true;
							expr = NULL;
						\}else
						\{
							expr = ns[0]->expr;
							ns[0]->expr = NULL;
						\}

						
						
						if(ns[2] == NULL)
						\{
							index_expr = NULL;
							parser->has_error = true;
						\}else
						\{
							index_expr = ns[2]->expr;
							ns[2]->expr = NULL;
						\}
						lex_info = expr == NULL ? &expr->lex_info : &ns[1]->token->lex_info;
						expr = make_index_expression(parser, expr, index_expr, lex_info);
						ret = __create_synnode(TGU_NODE_EXPR_T, (void*)expr);
						return ret;
				}

				|	call_expression					%action auto_return_0
				|	primary_expression				%action auto_return_0
				;	
				



/*辅助函数*/
%code {
	static tguExpr_t*		make_identifier_expression(tguParser_t	*parser, 	tguToken_t *token)
	\{
			return NULL;
	\}

	static tguExpr_t*		make_constant_expression(tguParser_t	*parser, 		tguToken_t *token)
	\{
			return NULL;
	\}

};

primary_expression	:	"(" expression")"							%action	on_lp_rp_expression
				|	"(" error ")"								%action	on_lp_rp_expression
				{
					tguParser_t	*parser = (tguParser_t*)ctx;
					psrNode_t 	*ret;
					if(nodes[1] == NULL)
					\{
						parser->has_error = true;
						ret = NULL;
					\}else
					\{
						ret = nodes[1];
						nodes[1] = NULL;
					\}
					return ret;
				}

				|	NAME										%action	on_identifier_expression
				{
						tguSynNode_t	**ns = (tguSynNode_t**)nodes;
						tguSynNode_t 	*ret;
						tguParser_t	*parser = (tguParser_t*)ctx;
						tguExpr_t		*expr;
						AR_ASSERT(parser != NULL && ns != NULL && count == 1);
						expr = make_identifier_expression(parser, ns[0]->token);
						
						ret = __create_synnode(TGU_NODE_EXPR_T, (void*)expr);
						return ret;

				}

				|	FLOAT_NUMBER			%action	on_constant_expression
				|	INT_NUMBER				%action	on_constant_expression
				|	STRING				%action	on_constant_expression
				|	"true"				%action	on_constant_expression
				|	"false"				%action	on_constant_expression
				|	"null"				%action	on_constant_expression
				{
						tguSynNode_t	**ns = (tguSynNode_t**)nodes;
						tguSynNode_t 	*ret;
						tguParser_t	*parser = (tguParser_t*)ctx;
						tguExpr_t		*expr;
						AR_ASSERT(parser != NULL && ns != NULL && count == 1);
						expr = make_constant_expression(parser, ns[0]->token);
						
						ret = __create_synnode(TGU_NODE_EXPR_T, (void*)expr);
						return ret;
				}
				;


/*辅助函数*/
%code {
	static tguExpr_t*		make_call_expression(tguParser_t	*parser, tguExpr_t *call_expr, tguExpr_t *args, const tguLexInfo_t *lex_info)
	\{
			return NULL;
	\}
};


call_expression		:	postfix_expression "(" expression_list ")"		%action	on_call_expression
				|	postfix_expression "(" error ")"			%action	on_call_expression
				|	postfix_expression "(" 	")"				%action	on_call_expression
				{
						tguSynNode_t	**ns = (tguSynNode_t**)nodes;
						tguSynNode_t 	*ret;
						tguParser_t	*parser = (tguParser_t*)ctx;
						tguExpr_t		*expr, *call_expr, *args;
						const tguLexInfo_t	*lex_info;
						if(ns[0] == NULL)
						\{
							parser->has_error = true;
							call_expr = NULL;
						\}else
						\{
							call_expr= ns[0]->expr;
							ns[0]->expr = NULL;
						\}


						if(count == 4)
						\{
							if(ns[2] == NULL)
							\{
								args = NULL;
								parser->has_error = true;
							\}else
							\{
								args = ns[2]->expr;
								ns[2]->expr = NULL;
							\}
						\}else
						\{
							args = NULL;
						\}
						
						lex_info = call_expr != NULL ? &call_expr->lex_info : &ns[1]->token->lex_info;
						expr = make_call_expression(parser, call_expr, args, lex_info );
						
						ret = __create_synnode(TGU_NODE_EXPR_T, (void*)expr);
						return ret;
				}
				;

expression_list		:	expression					%action	auto_return_0
				|	expression_list "," expression	%action	on_expression_list
				{
						tguSynNode_t	**ns = (tguSynNode_t**)nodes;
						tguSynNode_t	*ret;
						tguExpr_t		*lst;
						AR_ASSERT(ns != NULL && count == 3);

						if(ns[0] == NULL) return ns[2];
						if(ns[2] == NULL) return ns[2];
						/*expression_list中有任何错误，不应该反映在此处*/
						AR_ASSERT(ns[0]->expr != NULL  && ns[2]->expr != NULL);

						for(lst = ns[0]->expr; lst->next != NULL; lst = lst->next);
						
						lst->next = ns[2]->expr;
						ns[2]->expr = NULL;
						ret = ns[0];
						ns[0] = NULL;
						return ret;
				}
				;


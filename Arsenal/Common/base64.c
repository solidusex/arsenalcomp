/*
 * The Arsenal Library
 * Copyright (c) 2009 by Solidus
 * 
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.It is provided "as is" without express 
 * or implied warranty.
 *
 */

#include "common.h"


AR_NAMESPACE_BEGIN


/***********************************************************base64*********************************************************/

static const char ___g_base64_digits[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

static size_t __base64_need_len(const byte_t *input, size_t ilen)
{
		size_t need_n;
		AR_UNUSED(input);
		need_n = 0;
		need_n = ilen / 3 * 4;

		if(need_n % 3)
		{
				need_n += 4;
		}

		return need_n;
}



size_t AR_base64_encode(byte_t  *out, size_t olen, const byte_t *input, size_t ilen)
{
		size_t r, need_n;

		AR_ASSERT(input != NULL && ilen > 0);

		need_n = __base64_need_len(input, ilen);
		if(out == NULL)
		{
				return need_n;
		}

		if(olen < need_n)
		{
				return 0;
		}

		
		r = ilen;
		
		while(r >= 3)
		{
				*out++ = ___g_base64_digits[input[0] >> 2];
				*out++ = ___g_base64_digits[((input[0] << 4) & 0x30)|(input[1] >> 4)];
				*out++ = ___g_base64_digits[((input[1] << 2) & 0x3c)|(input[2] >> 6)];
				*out++ = ___g_base64_digits[input[2] & 0x3f];
				input += 3;
				r -= 3;
		}

		if(r > 0)
		{
				byte_t fragment;
				*out++ = ___g_base64_digits[input[0] >> 2];
				fragment = (input[0] << 4) & 0x30;

				if(r > 1)
				{
						fragment |= input[1] >> 4;
				}

				*out++ = ___g_base64_digits[fragment];
				*out++ = (r < 2) ? '=' : ___g_base64_digits[(input[1] << 2) & 0x3c];
				*out++ = '=';
		}

		return need_n;
}



static const byte_t __g_base64_to_sixtet[] = 
{
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3E, 0x00, 0x00, 0x00, 0x3F, 
	0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 
	0x0F, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 
	0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x30, 0x31, 0x32, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};



size_t AR_base64_decode(byte_t  *out, size_t olen, const byte_t *input, size_t ilen)
{
		byte_t *o;
		size_t need_n,i,j,k;
		byte_t tmp[4] = {0,0,0,0};
		

		AR_ASSERT(input != NULL && ilen > 0);

		need_n = 3 * ilen / 4;

		if(out == NULL)
		{
				return need_n;
		}

		if(olen < need_n)
		{
				return 0;
		}


		for(i = 0, o = out, need_n = 0, k = 0; i < ilen && input[i] != '\0' && input[i] != '='; ++i)
		{
				if(input[i] == ' ' || input[i] == '\n')
				{
						continue;
				}

				tmp[k++] = __g_base64_to_sixtet[input[i]];
				
				if(input[i+1] == '\0' || input[i+1] == '=' || k == 4)
				{
						
						uint_32_t w = 0;

#if defined(ARCH_BIG_ENDIAN)
						
						{
						w |= tmp[0];
						w |= tmp[1] << 6;
						w |= tmp[2] << 2*6;
						w |= tmp[3] << 3*6;
						}
						
						
#else
						{
						byte_t *t;
						t = (byte_t*)&w;

						t[0] |= tmp[0] << 2;
						t[0] |= (tmp[1] & 0x30 ) >> 4;
						t[1] |= (tmp[1] & 0xf ) << 4;
						t[1] |= (tmp[2] & 0x3c ) >> 2;
						t[2] |= (tmp[2] & 0x3 ) << 6;
						t[2] |= tmp[3];
						}

#endif

						
						for(j = 0; j * 8 < k * 6; ++j)
						{
								*o++ = w & 0xff;
								w >>= 8;
								++need_n;
						}

						tmp[0] = tmp[1] = tmp[2] = tmp[3] = 0;
						k = 0;
				}
		}

		
		return need_n;
}





AR_NAMESPACE_END

